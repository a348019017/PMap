!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(){const e=["fromCssColorString","PerInstanceColorAppearance","VERTEX_FORMAT","_polygonHierarchy","1282662sMcEAx","entities","flat","3233975IcJuBM","withAlpha","ClassificationType","type","CESIUM_3D_TILE","fromColor","Cartesian3","maxdistance","features","MultiPolygon","328834YZbSAb","43570eFsfdD","2892380USXAyY","21zqHvlh","ColorGeometryInstanceAttribute","Polygon","455106aBKQDQ","fromDegreesArray","add","2685448xWgLde","geometry","Color","#ff0000","maxcount","coordinates","PolygonGeometry","map","tollerance"];return(t=function(){return e})()}function i(e,n){const a=t();return(i=function(e,t){return a[e-=466]})(e,n)}function n(e,t){var i=a();return(n=function(e,t){return i[e-=490]})(e,t)}function a(){var e=["#06f4f7","href","parseInt","wgs84ToWindowCoordinates","setAttribute","5928yEWdMy","178486mQsYbC","width","toDataURL","7小时以上","4445nBonal","none","SceneTransforms","4336792aRfSfX","length","data","FRAMEBUFFER","getContext","color","#08f210","body","display","_gl","3528SzQrHC","toCartesian","beginPath","#0000f6","fillStyle","3-4小时","2-3小时","#00baf6","map","1-2小时","13277196kGBhbt","click","4-5小时","src","506838llCryu","120480fIzkGK","Cartographic","#f9a100","createElement","6-7小时","height","appendChild","set","style","download","FRAMEBUFFER_COMPLETE","readPixels","putImageData","scene","222wRbjGh","canvas"];return(a=function(){return e})()}!function(e,t){const n=i,a=e();for(;;)try{if(398391===-parseInt(n(487))/1+-parseInt(n(488))/2+-parseInt(n(493))/3+-parseInt(n(489))/4+parseInt(n(477))/5+parseInt(n(474))/6*(parseInt(n(490))/7)+parseInt(n(496))/8)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(t),function(e,t){for(var i=n,a=e();;)try{if(275934===-parseInt(i(499))/1+parseInt(i(522))/2+-parseInt(i(514))/3*(-parseInt(i(521))/4)+parseInt(i(500))/5+-parseInt(i(539))/6*(parseInt(i(526))/7)+-parseInt(i(529))/8+parseInt(i(495))/9)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(a);const s=c;!function(e,t){const i=c,n=e();for(;;)try{if(409633===-parseInt(i(413))/1+parseInt(i(442))/2+parseInt(i(387))/3+parseInt(i(414))/4+-parseInt(i(411))/5*(parseInt(i(390))/6)+parseInt(i(430))/7*(-parseInt(i(383))/8)+parseInt(i(426))/9)break;n.push(n.shift())}catch(e){n.push(n.shift())}}(l);const o=Cesium[s(397)],r=Cesium.defined,h=Cesium[s(419)];function l(){const e=["normalShadingSmooth","_pointBias","} \nvec3 getNormalEC() \n{ \n","USE_SOFT_SHADOWS","130466sWAmWD","_isPointLight","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","VERSION","SHADOW_MAP","createShadowReceiveVertexShader","USE_SHADOW_DEPTH_TEXTURE","_numberOfCascades","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",", 1.0); \n","_terrainBias","24IcXTTz","_usesDepthTexture","findPositionVarying","findNormalVarying","514206mCFlqq","split","_polygonOffsetSupported","10644opNcDz","USE_NORMAL_SHADING","_isSpotLight","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","ENABLE_DAYNIGHT_SHADING","    return vec4(","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","ShaderSource","USE_NORMAL_SHADING_SMOOTH","GENERATE_POSITION_AND_NORMAL","parseInt","); \n","defines","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","    return normalize(","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","slice","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","push","debugCascadeColors","800zpiAyV","normalOffset","762989DPSiIx","2403620KqCxHp","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","ENABLE_VERTEX_LIGHTING","GENERATE_POSITION","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","ShadowMapShader","softShadows","uniform sampler2D shadowMap_texture; \n","sources","czm_shadow_receive_main","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","11728431kgjRhO","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","createShadowReceiveFragmentShader","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","1596553rpbSla","normalShading","replaceMain","USE_CUBE_MAP_SHADOW","uniform samplerCube shadowMap_textureCube; \n","    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n","    return vec3(1.0); \n","} \n"];return(l=function(){return e})()}let m;function c(e,t){const i=l();return(c=function(e,t){return i[e-=381]})(e,t)}function d(e,t){const i=s;e?function(e){const t=s,i=Number[t(400)](Cesium[t(445)][t(388)](".")[1])>=101;m=h[t(428)],i?(h[t(447)]=function(e,i,n){const a=t,s=e[a(402)].slice(0),r=e[a(422)][a(407)](0);return s[a(409)](a(446)),i&&(n?s[a(409)](a(399)):s[a(409)](a(417))),new o({defines:s,sources:r})},h[t(428)]=function(e,i,n,a,s){const h=t,l=o[h(386)](e),m=!a&&r(l)||a&&s,c=o[h(385)](e),d=r(c),u=i[h(384)],p=i._polygonOffsetSupported,f=i[h(443)],C=i[h(392)],w=i[h(449)]>1,g=i[h(410)],_=i[h(420)],v=f?i[h(439)]:a?i[h(382)]:i._primitiveBias,E=e[h(402)].slice(0),x=e[h(422)][h(407)](0),y=x.length;for(let e=0;e<y;++e)x[e]=o[h(432)](x[e],h(423));f?E.push(h(433)):u&&E[h(409)](h(448)),_&&!f&&E[h(409)](h(441)),w&&n&&a&&(m?E[h(409)]("ENABLE_VERTEX_LIGHTING"):E.push("ENABLE_DAYNIGHT_SHADING")),n&&v.normalShading&&m&&(E[h(409)](h(391)),v[h(438)]>0&&E.push(h(398)));let S,P="";return P+=f?h(434):"uniform sampler2D shadowMap_texture; \n",S=d?"    return vec4("+c+", 1.0); \n":h(444),P+=h(396)+S+h(440)+(m?"    return normalize("+l+"); \n":h(436))+h(418)+(v[h(412)]&&m?h(425):"")+h(437),P+=h(450),P+=h(405),a?P+=h(393):p||(P+="    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n"),P+=f?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":C?h(415):w?h(429)+(g?h(435):""):h(427),P+="   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ",x[h(409)](P),new o({defines:E,sources:x})}):h[t(428)]=function(e,i,n,a,s){const h=t,l=o[h(386)](e),m=!a&&r(l)||a&&s,c=o[h(385)](e),d=r(c),u=i._usesDepthTexture,p=i[h(389)],f=i._isPointLight,C=i[h(392)],w=i[h(449)]>1,g=i.debugCascadeColors,_=i.softShadows,v=f?i[h(439)]:a?i[h(382)]:i._primitiveBias,E=e[h(402)][h(407)](0),x=e.sources[h(407)](0),y=x.length;for(let e=0;e<y;++e)x[e]=o.replaceMain(x[e],h(423));f?E[h(409)]("USE_CUBE_MAP_SHADOW"):u&&E[h(409)](h(448)),_&&!f&&E[h(409)]("USE_SOFT_SHADOWS"),w&&n&&a&&(m?E[h(409)](h(416)):E.push(h(394))),n&&v[h(431)]&&m&&(E[h(409)](h(391)),v[h(438)]>0&&E[h(409)](h(398)));let S,P="";return P+=f?"uniform samplerCube shadowMap_textureCube; \n":h(421),S=d?h(395)+c+h(381):h(444),P+=h(408)+S+"} \nvec3 getNormalEC() \n{ \n"+(m?h(404)+l+h(401):h(436))+h(418)+(v[h(412)]&&m?h(425):"")+h(437),P+="void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",P+=h(405),a?P+=h(393):p||(P+=h(403)),P+=f?h(424):C?h(415):w?h(429)+(g?"    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n":""):h(427),P+=h(406),x.push(P),new o({defines:E,sources:x})}}():h[i(428)]=m}const u=f;!function(e,t){const i=f,n=e();for(;;)try{if(413170===parseInt(i(324))/1*(parseInt(i(383))/2)+parseInt(i(255))/3+parseInt(i(296))/4+-parseInt(i(341))/5+parseInt(i(314))/6*(parseInt(i(311))/7)+parseInt(i(275))/8*(-parseInt(i(312))/9)+parseInt(i(283))/10)break;n.push(n.shift())}catch(e){n.push(n.shift())}}(C);Cesium[u(361)][u(393)]=u(393),Cesium[u(361)][u(360)][u(293)](Cesium[u(361)][u(393)],{fabric:{type:Cesium.Material[u(393)],uniforms:{image:Cesium[u(361)][u(390)],legend:Cesium[u(361)][u(390)]},source:"\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n"},translucent:function(e){return!0}});class p{constructor(e,t){const i=u;let n=this;if(this[i(278)]=t,this[i(384)]=t[i(382)],this._sampleCallback=t[i(297)],this[i(310)]=!1,t[i(326)]){t[i(321)]=t[i(321)][i(292)]((e=>Cesium[i(387)][i(335)](e)));const a=Cesium.sampleTerrainMostDetailed(e.terrainProvider,t[i(321)]);Promise[i(355)](a).then((function(a){const s=i;let o=-9999;a=a[s(292)]((e=>(e[s(375)]>o&&(o=e[s(375)]),Cesium.Cartographic[s(271)](e)))),t[s(375)]=o,t[s(321)]=a,n[s(331)](e,t)}))}else n[i(331)](e,t)}[u(389)](e){const t=u;this[t(304)]&&this[t(327)](e)}[u(381)](e){const t=u;var i=viewer[t(373)][t(318)];const n=i[t(279)];if(n[t(337)](n.FRAMEBUFFER)===n[t(264)]){let n=Cesium[t(325)].wgs84ToWindowCoordinates(viewer[t(373)],e);return i[t(307)]({x:Number.parseInt(n.x),y:Number[t(371)](n.y),width:1,height:1,framebuffer:this[t(346)]})[0]*(this[t(265)]/6)/255}return-1}[u(316)](){this[u(386)]=0}scaleHeight(e){const t=u;let i=Cesium[t(266)].eastNorthUpToFixedFrame(this[t(332)]),n=Cesium[t(260)][t(319)](i,new Cesium.Matrix4),a=e-this[t(300)][t(375)],s=Cesium[t(260)].fromTranslation(new(Cesium[t(313)])(0,0,a)),o=Cesium.Matrix4.multiply(s,n,new Cesium.Matrix4);this[t(304)].modelMatrix=Cesium[t(260)][t(294)](i,o,new(Cesium[t(260)]))}[u(331)](e,t){const i=u;let a=this;this[i(330)]=!0,this[i(254)]=0,this._legendimage="";var s=e[i(373)][i(318)];if(t[i(268)]&&(this._legendimage=function(e,t){var i=n;const a=16*e[i(530)];var s=document[i(503)](i(515));s[i(523)]=a,s[i(505)]=16;var o=s[i(533)]("2d");o[i(541)]();for(let t=0;t<e[i(530)];t++){let n=e[t][i(534)],a=16*t,s=0;o[i(543)]=n,o.fillRect(a,s,16,16)}var r=new Image;return r.src=s[i(524)](),r}(t[i(268)]),Cesium[i(370)][i(364)](this[i(274)][i(287)]).fetchImage()[i(379)]((function(t){const n=i;var s,o=e[n(373)].context;s=Cesium[n(344)](t[n(286)])?new Cesium.Texture({context:o,pixelFormat:t[n(286)],width:t[n(363)],height:t.height,source:{arrayBufferView:t[n(338)]}}):new(Cesium[n(259)])({context:o,source:t}),a[n(322)]=s}))),this[i(351)]=new Cesium.Cartesian3,t[i(321)]){var o=new(Cesium[i(388)])({context:s,colorTextures:[new Cesium.Texture({context:s,width:s[i(368)][i(363)],height:s[i(368)][i(375)]})],depthStencilRenderbuffer:new(Cesium[i(269)])({context:s,width:s[i(368)].width,height:s[i(368)][i(375)],format:Cesium[i(309)].DEPTH_STENCIL})});this[i(346)]=o;var r=new(Cesium[i(290)])(t[i(321)]);let n=new Cesium.PolygonGeometry({polygonHierarchy:r,height:t.height,vertexFormat:Cesium[i(289)].VERTEX_FORMAT});this.center=Cesium[i(288)].fromPoints(t[i(321)])[i(300)],this[i(300)]=Cesium[i(387)][i(335)](this[i(300)]),this[i(300)][i(375)]=t[i(375)],this.centerWC=Cesium[i(387)][i(271)](this[i(300)]);var h=new(Cesium[i(362)])({geometry:n,attributes:{color:Cesium.ColorGeometryInstanceAttribute[i(334)](Cesium.Color.fromCssColorString("#ffffff")[i(378)](0))}});let a=new(Cesium[i(365)])({geometryInstances:h,asynchronous:!1,appearance:new Cesium.EllipsoidSurfaceAppearance({material:new(Cesium[i(361)])({fabric:{type:i(393),uniforms:{legend:this[i(274)]}},minificationFilter:Cesium.TextureMinificationFilter[i(315)],magnificationFilter:Cesium.TextureMagnificationFilter[i(315)]})})});this[i(304)]=a;let l=new Date(Date[i(376)]());l[i(302)](16,0,0),this[i(386)]=0,this[i(265)]=48,l=Cesium[i(350)][i(270)](l),this._starttime=l;let m=this[i(357)]({time:l}),c=new(Cesium[i(320)])({context:e[i(373)].context,lightCamera:m,enabled:!0});this[i(336)]=c,this[i(285)]=new Cesium.ClearCommand({color:new(Cesium[i(358)])(0,0,0,0),pass:Cesium[i(395)][i(328)],owner:this,framebuffer:this._fb}),this[i(261)]=!1,Cesium[i(354)][i(280)]({blending:Cesium[i(256)][i(369)]});let u=this;this.polygonprimitrive[i(298)][i(379)]((t=>{const n=i;d(!0);let a=t._colorCommands,s=a.map((t=>{const i=f;t[i(385)]=!0;let n=Cesium.ShadowMap.createReceiveDerivedCommand([u._shadowmap],t,!0,e[i(373)][i(299)],{});n[i(396)][i(385)]=!1;const a=Cesium[i(276)](Cesium.BlendingState[i(343)],!0),s=new(Cesium[i(358)])(0,0,0,0);return a[i(345)]=s,n[i(396)][i(353)].blending=a,n[i(396)].pass=7,n[i(396)][i(340)]=u[i(346)],n[i(396)]}));u[n(303)]=s,d(!1),u[n(317)]=a.map((e=>{const t=n;let i=Cesium[t(276)](e);return i[t(267)].image_1=function(){return o[t(394)][0]},i[t(267)][t(342)]=function(){return u[t(322)]},i})),u[n(304)].show=!1,u[n(261)]=!0})),e.scene[i(347)].add(this[i(304)])}}[u(295)](){const e=u;var t=viewer[e(373)][e(318)];return new(Cesium[e(388)])({context:t,colorTextures:[new(Cesium[e(259)])({context:t,width:t[e(368)][e(363)],height:t[e(368)][e(375)]})],depthStencilRenderbuffer:new(Cesium[e(269)])({context:t,width:t[e(368)][e(363)],height:t[e(368)][e(375)],format:Cesium.RenderbufferFormat[e(272)]})})}setSamplePoints(e){const t=u;this[t(384)]=e,this[t(310)]=!1}[u(257)](e){const t=u;if(!this[t(330)])return;let i=this;if(this._isready&&Cesium.defined(this[t(303)]))if(e[t(262)][t(397)][t(301)](this._cameraPosition)||(this._index=0,this[t(310)]=!1,this._cameraPosition=Cesium[t(276)](e[t(262)][t(397)])),0==this[t(386)]&&e[t(281)][t(291)](this[t(285)]),this[t(386)]<this[t(265)]){let n=Cesium[t(350)][t(258)](this[t(339)],10*this._index,new(Cesium[t(350)])),a=this[t(357)]({time:n});this[t(336)]._lightCamera[t(397)]=a[t(397)],this[t(336)][t(356)].direction=a[t(329)],this[t(336)].dirty=!0,e[t(374)].push(this[t(336)]),this._extraCmds.forEach((e=>{const n=t;e[n(392)]=i[n(304)].modelMatrix})),e[t(281)].push(...this._extraCmds),this[t(386)]++}else{if(this[t(384)]&&this[t(305)]&&!this[t(310)]){let e=this[t(384)][t(292)]((e=>Cesium[t(387)].fromCartesian(e)));var a=function(e,t,i){var a=n,s=viewer.scene.context;const o=s[a(538)];if(o.checkFramebufferStatus(o[a(532)])===o[a(510)])return t[a(493)]((t=>{var n=a;null!=i&&(t.height=i),t=Cesium[n(501)][n(540)](t);let o=Cesium[n(528)][n(519)](viewer[n(513)],t);return s[n(511)]({x:Number[n(518)](o.x),y:Number[n(518)](o.y),width:1,height:1,framebuffer:e})}))}(this[t(346)],e,this[t(278)][t(375)]);this._sampleCallback(a),this[t(310)]=!0}this[t(317)][t(372)]((e=>{const n=t;e[n(392)]=i.polygonprimitrive[n(392)]})),e[t(281)].push(...this.polygonCmds)}}[u(357)](e){const t=u;let i=new Cesium.Cartesian3,n=new(Cesium[t(367)]);Cesium[t(344)](Cesium[t(266)][t(323)](e[t(263)],n))||(n=Cesium[t(266)][t(277)](e[t(263)],n));let a=Cesium[t(273)].computeSunPositionInEarthInertialFrame(e[t(263)],i);Cesium[t(367)][t(380)](n,a,a);let s=new(Cesium[t(313)]);Cesium.Cartesian3.normalize(a,s);let o=new Cesium.Camera(viewer[t(373)]);return o[t(397)]=a,o[t(329)]=s,o}[u(282)](){}createShadowMap(e,t){const i=u;this[i(306)]=e,this[i(352)]=e[i(373)].shadowMap,this[i(377)]=this.shadowMap.lightCamera,this[i(366)]=t.visibleAreaColor||Cesium[i(358)][i(359)],this[i(308)]=t[i(308)]||Cesium[i(358)][i(333)],this[i(348)]=.5}[u(349)](){}[u(391)](){const e=u;this[e(304)]&&viewer[e(373)][e(347)][e(284)](this[e(304)])}}function f(e,t){const i=C();return(f=function(e,t){return i[e-=254]})(e,t)}function C(){const e=["internalFormat","src","BoundingSphere","EllipsoidSurfaceAppearance","PolygonHierarchy","push","map","addMaterial","multiply","createFramebuffer","1040216YjcIsg","sampleCallback","readyPromise","_context","center","equals","setHours","_extraCmds","polygonprimitrive","_sampleCallback","viewer","readPixels","invisibleAreaColor","RenderbufferFormat","_isSampleDone","798rdGmVo","3039219mVPUMc","Cartesian3","31542AQlRrQ","NEAREST","refresh","polygonCmds","context","inverse","ShadowMap","positions","vtxfTexture","computeIcrfToFixedMatrix","4220kKANMi","SceneTransforms","clampground","scaleHeight","OPAQUE","direction","show","init","centerWC","RED","fromColor","fromCartesian","_shadowmap","checkFramebufferStatus","bufferView","_starttime","framebuffer","2626415kRwywD","legend_0","ADDITIVE_BLEND","defined","color","_fb","primitives","alpha","clear","JulianDate","_cameraPosition","shadowMap","renderState","RenderState","resolve","_lightCamera","setSunAndMoonDirections","Color","GREEN","_materialCache","Material","GeometryInstance","width","createIfNeeded","Primitive","visibleAreaColor","Matrix3","canvas","ALPHA_BLEND","Resource","parseInt","forEach","scene","shadowMaps","height","now","lightCamera","withAlpha","then","multiplyByVector","pickPosition","samplePoints","4GsLndr","_samplePoints","receiveShadows","_index","Cartographic","Framebuffer","setHeight","DefaultImageId","destory","modelMatrix","RZType","_colorTextures","Pass","receiveCommand","position","secondsOfDay","425208odpygv","BlendingState","update","addMinutes","Texture","Matrix4","_isready","camera","time","FRAMEBUFFER_COMPLETE","_count","Transforms","uniformMap","legends","Renderbuffer","fromDate","toCartesian","DEPTH_STENCIL","Simon1994PlanetaryPositions","_legendimage","8tVmBNv","clone","computeTemeToPseudoFixedMatrix","_option","_gl","fromCache","commandList","createShadowMaps","2666160btsIKy","remove","_clearColorCommand"];return(C=function(){return e})()}e.RZPrimitiveX=p}));
