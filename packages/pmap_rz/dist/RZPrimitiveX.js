!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(e,i){const a=n();return(t=function(e,t){return a[e-=464]})(e,i)}function n(){const e=["type","fromColor","maxdistance","1577259lbfYCo","fromCssColorString","VERTEX_FORMAT","entities","features","tollerance","coordinates","Polygon","PerInstanceColorAppearance","3791354hqlGcX","PolygonGeometry","EllipsoidSurfaceAppearance","ClassificationType","fromDegreesArrayHeights","ColorGeometryInstanceAttribute","37HqnXHw","MultiPolygon","Cartesian3","_polygonHierarchy","1309452muBKiD","withAlpha","PolygonHierarchy","21969032MBgiAm","44778WxbulP","add","#ff0000","maxcount","fromDegreesArray","map","6201625SypFHa","917392gjuQtP","CESIUM_3D_TILE","Primitive"];return(n=function(){return e})()}function i(){var e=["href","click","697107voQhVq","2295sIiGSb","318ZFkBAg","wgs84ToWindowCoordinates","putImageData","#08f210","8435aQEynC","set","7856gxvLUz","7小时以上","#00baf6","FRAMEBUFFER_COMPLETE","3037853JDobyx","toDataURL","createElement","#06f4f7","canvas","_gl","map","length","6-7小时","scene","getContext","parseInt","width","setAttribute","fillRect","download","317306DqUUWQ","body","appendChild","readPixels","none","#f5f701","checkFramebufferStatus","SceneTransforms","FRAMEBUFFER","height","4koAECg","1-2小时","createImageData","2-3小时","8592860oebnDM","#f9a100","src","display","421361GAodcg","4-5小时","context"];return(i=function(){return e})()}function a(e,t){var n=i();return(a=function(e,t){return n[e-=178]})(e,t)}!function(e,n){const i=t,a=e();for(;;)try{if(650436===-parseInt(i(475))/1*(parseInt(i(483))/2)+parseInt(i(496))/3+-parseInt(i(490))/4+-parseInt(i(489))/5+parseInt(i(479))/6+-parseInt(i(469))/7+parseInt(i(482))/8)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(n),function(e,t){for(var n=a,i=e();;)try{if(233969===-parseInt(n(210))/1+parseInt(n(192))/2+-parseInt(n(215))/3*(-parseInt(n(202))/4)+parseInt(n(221))/5*(parseInt(n(217))/6)+-parseInt(n(227))/7+-parseInt(n(223))/8*(parseInt(n(216))/9)+parseInt(n(206))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(i);const s=o;function o(e,t){const n=c();return(o=function(e,t){return n[e-=149]})(e,t)}!function(e,t){const n=o,i=e();for(;;)try{if(299124===-parseInt(n(149))/1+-parseInt(n(162))/2*(-parseInt(n(168))/3)+-parseInt(n(193))/4*(-parseInt(n(198))/5)+parseInt(n(161))/6+-parseInt(n(179))/7*(-parseInt(n(171))/8)+parseInt(n(163))/9*(parseInt(n(199))/10)+-parseInt(n(196))/11*(parseInt(n(157))/12))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(c);const r=Cesium.ShaderSource,h=Cesium[s(212)],l=Cesium[s(214)];let m;function c(){const e=["    return vec3(1.0); \n","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","createShadowReceiveFragmentShader","32dBhKTe","_isPointLight","_usesDepthTexture","66LBwTZU",", 1.0); \n","306770mRPrsV","20BgLqjd","normalOffset","push","USE_CUBE_MAP_SHADOW","length","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","_pointBias","USE_SHADOW_DEPTH_TEXTURE","ENABLE_DAYNIGHT_SHADING","normalShading","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","slice","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","defined","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","ShadowMapShader","_primitiveBias","338127ldsOVV","split","_terrainBias","    return vec4(","   \n      float rd=0.016667;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","uniform samplerCube shadowMap_textureCube; \n","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","1118508jNtkLW","sources","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","255402LhVlzF","14XnwrAc","303147ZfSEHb","USE_NORMAL_SHADING_SMOOTH","    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n","parseInt","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","87708qFUwkj","defines","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","128gbrTIS","uniform sampler2D shadowMap_texture; \n","_isSpotLight","findNormalVarying","    return normalize(","USE_SOFT_SHADOWS","softShadows","} \n","171101qRZpuV","findPositionVarying","_numberOfCascades","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","USE_NORMAL_SHADING","} \nvec3 getNormalEC() \n{ \n","czm_shadow_receive_main","   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.016667;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ","ENABLE_VERTEX_LIGHTING","replaceMain","); \n"];return(c=function(){return e})()}function d(e){const t=s;e?function(){const e=s,t=Number[e(166)](Cesium.VERSION[e(150)](".")[1])>=101;m=l[e(192)],t?(l.createShadowReceiveVertexShader=function(t,n,i){const a=e,s=t[a(169)][a(210)](0),o=t[a(158)][a(210)](0);return s[a(201)]("SHADOW_MAP"),n&&(i?s[a(201)]("GENERATE_POSITION_AND_NORMAL"):s.push("GENERATE_POSITION")),new r({defines:s,sources:o})},l.createShadowReceiveFragmentShader=function(t,n,i,a,s){const o=e,l=r[o(174)](t),m=!a&&h(l)||a&&s,c=r[o(180)](t),d=h(c),u=n[o(195)],f=n._polygonOffsetSupported,p=n._isPointLight,C=n[o(173)],w=n[o(181)]>1,g=n.debugCascadeColors,_=n[o(177)],v=p?n[o(205)]:a?n._terrainBias:n[o(215)],E=t[o(169)].slice(0),x=t[o(158)][o(210)](0),y=x[o(203)];for(let e=0;e<y;++e)x[e]=r.replaceMain(x[e],o(185));p?E[o(201)](o(202)):u&&E.push("USE_SHADOW_DEPTH_TEXTURE"),_&&!p&&E[o(201)](o(176)),w&&i&&a&&(m?E[o(201)](o(187)):E[o(201)](o(207))),i&&v[o(208)]&&m&&(E[o(201)](o(183)),v.normalShadingSmooth>0&&E.push(o(164)));let S,D="";return D+=o(p?155:172),S=d?"    return vec4("+c+o(197):"#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n",D+=o(167)+S+o(184)+(m?"    return normalize("+l+"); \n":"    return vec3(1.0); \n")+o(159)+(v.normalOffset&&m?"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n":"")+o(178),D+=o(213),D+=o(204),a?D+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":f||(D+="    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n"),D+=p?o(211):C?o(160):w?o(209)+(g?o(165):""):o(154),D+=o(186),x[o(201)](D),new r({defines:E,sources:x})}):l[e(192)]=function(t,n,i,a,s){const o=e,l=r[o(174)](t),m=!a&&h(l)||a&&s,c=r[o(180)](t),d=h(c),u=n._usesDepthTexture,f=n._polygonOffsetSupported,p=n[o(194)],C=n._isSpotLight,w=n[o(181)]>1,g=n.debugCascadeColors,_=n[o(177)],v=p?n[o(205)]:a?n[o(151)]:n[o(215)],E=t[o(169)][o(210)](0),x=t[o(158)][o(210)](0),y=x.length;for(let e=0;e<y;++e)x[e]=r[o(188)](x[e],o(185));p?E[o(201)](o(202)):u&&E.push(o(206)),_&&!p&&E[o(201)]("USE_SOFT_SHADOWS"),w&&i&&a&&(m?E[o(201)]("ENABLE_VERTEX_LIGHTING"):E[o(201)]("ENABLE_DAYNIGHT_SHADING")),i&&v[o(208)]&&m&&(E[o(201)](o(183)),v.normalShadingSmooth>0&&E.push(o(164)));let S,D="";return D+=p?"uniform samplerCube shadowMap_textureCube; \n":o(172),S=d?o(152)+c+o(197):o(191),D+="uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n"+S+o(184)+(m?o(175)+l+o(189):o(190))+o(159)+(v[o(200)]&&m?o(170):"")+o(178),D+=o(213),D+=o(204),a?D+=o(182):f||(D+=o(156)),D+=p?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":C?o(160):w?"    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n"+(g?"    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n":""):o(154),D+=o(153),x[o(201)](D),new r({defines:E,sources:x})}}():l[t(192)]=m}const u=p;function f(){const e=["OPAQUE","legend_0","camera","position","destory","context","forEach","_isSampleDone","ShadowMap","_shadowmap","_sampleCallback","5BPZArP","#ffffff","Renderbuffer","sampleCallback","readPixels","_colorCommands","917004aYvDAe","5878390ljVZLG","width","FRAMEBUFFER","fromCssColorString","shadowMap","wgs84ToWindowCoordinates","_clearColorCommand","1140852ikFznE","addMinutes","withAlpha","97uPKvSw","createShadowMaps","fromColor","inverse","fromPoints","951480kvzolq","image_1","Transforms","defined","_legendimage","RZType","Camera","8zPHHiC","then","Framebuffer","TextureMagnificationFilter","DEPTH_STENCIL","positions","_extraCmds","RenderState","toCartesian","map","ClearCommand","uniformMap","remove","Texture","push","height","time","3247090mvaLbJ","SceneTransforms","RED","pickPosition","primitives","invisibleAreaColor","JulianDate","receiveCommand","modelMatrix","color","BlendingState","now","_isready","setHours","update","EllipsoidSurfaceAppearance","198RBiVla","11fmudtX","_cameraPosition","_starttime","dirty","_option","NEAREST","refresh","computeTemeToPseudoFixedMatrix","ADDITIVE_BLEND","_count","ColorGeometryInstanceAttribute","createShadowMap","parseInt","visibleAreaColor","fromDate","scene","Matrix4","FRAMEBUFFER_COMPLETE","PolygonGeometry","samplePoints","_index","Primitive","Matrix3","pass","init","Cartesian3","commandList","Color","equals","center","fromTranslation","RenderbufferFormat","receiveShadows","_colorTextures","ALPHA_BLEND","direction","polygonCmds","fromCache","setSunAndMoonDirections","fromCartesian","resolve","terrainProvider","clone","Pass","Material","eastNorthUpToFixedFrame","show","centerWC","_lightCamera","lightCamera","canvas","BoundingSphere","alpha","PolygonHierarchy","scaleHeight","multiply","secondsOfDay","_fb","sampleTerrainMostDetailed","renderState","DefaultImageId","658566MUTfyO","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","computeIcrfToFixedMatrix","Cartographic","createFramebuffer","polygonprimitrive","_samplePoints","normalize","GREEN","multiplyByVector","shadowMaps"];return(f=function(){return e})()}function p(e,t){const n=f();return(p=function(e,t){return n[e-=162]})(e,t)}!function(e,t){const n=p,i=e();for(;;)try{if(236859===-parseInt(n(254))/1*(-parseInt(n(299))/2)+parseInt(n(259))/3+-parseInt(n(243))/4+parseInt(n(237))/5*(parseInt(n(251))/6)+parseInt(n(283))/7+-parseInt(n(266))/8*(-parseInt(n(215))/9)+parseInt(n(244))/10*(-parseInt(n(300))/11))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(f);const C=u(216);Cesium[u(198)][u(264)]=u(264),Cesium.Material._materialCache.addMaterial(Cesium[u(198)][u(264)],{fabric:{type:Cesium[u(198)][u(264)],uniforms:{image:Cesium[u(198)][u(214)],legend:Cesium[u(198)][u(214)]},source:C},translucent:function(e){return!0}});class w{constructor(e,t){const n=u;let i=this;if(this._option=t,this[n(221)]=t[n(173)],this[n(236)]=t[n(240)],this._isSampleDone=!1,t.clampground){t[n(271)]=t[n(271)][n(275)]((e=>Cesium[n(218)][n(193)](e)));const a=Cesium[n(212)](e[n(195)],t[n(271)]);Promise[n(194)](a).then((function(a){const s=n;let o=-9999;a=a.map((e=>(e[s(281)]>o&&(o=e[s(281)]),Cesium[s(218)][s(274)](e)))),t.height=o,t.positions=a,i[s(178)](e,t)}))}else i[n(178)](e,t)}setHeight(e){const t=u;this[t(220)]&&this[t(208)](e)}[u(286)](e){const t=u;var n=viewer.scene[t(231)];const i=n._gl;if(i.checkFramebufferStatus(i[t(246)])===i[t(171)]){let i=Cesium[t(284)][t(249)](viewer.scene,e);return 10*n[t(241)]({x:Number[t(166)](i.x),y:Number.parseInt(i.y),width:1,height:1,framebuffer:this[t(211)]})[0]/255}return-1}[u(306)](){this._index=0}scaleHeight(e){const t=u;let n=Cesium.Transforms[t(199)](this[t(201)]),i=Cesium[t(170)][t(257)](n,new(Cesium[t(170)])),a=e-this.center[t(281)],s=Cesium[t(170)][t(184)](new Cesium.Cartesian3(0,0,a)),o=Cesium.Matrix4[t(209)](s,i,new(Cesium[t(170)]));this[t(220)][t(291)]=Cesium.Matrix4[t(209)](n,o,new(Cesium[t(170)]))}init(e,t){const n=u;this[n(200)]=!0,this[n(210)]=0,this._legendimage="";var i=e[n(169)][n(231)];if(t.legends&&(this._legendimage=function(e,t){var n=a;const i=16*e[n(183)];var s=document[n(178)](n(180));s[n(188)]=i,s[n(201)]=16;var o=s[n(186)]("2d");o.beginPath();for(let t=0;t<e[n(183)];t++){let i=e[t].color,a=16*t,s=0;o.fillStyle=i,o[n(190)](a,s,16,16)}var r=new Image;return r[n(208)]=s[n(228)](),r}(t.legends),this.vtxfTexture=new(Cesium[n(279)])({context:i,source:this[n(263)]})),this[n(301)]=new(Cesium[n(179)]),t.positions){var s=new(Cesium[n(268)])({context:i,colorTextures:[new(Cesium[n(279)])({context:i,width:i[n(204)].width,height:i.canvas.height})],depthStencilRenderbuffer:new(Cesium[n(239)])({context:i,width:i[n(204)][n(245)],height:i[n(204)].height,format:Cesium[n(185)][n(270)]})});this._fb=s;var o=new(Cesium[n(207)])(t[n(271)]);let a=new(Cesium[n(172)])({polygonHierarchy:o,height:t[n(281)],vertexFormat:Cesium[n(298)].VERTEX_FORMAT});this[n(183)]=Cesium[n(205)][n(258)](t[n(271)])[n(183)],this.center=Cesium[n(218)][n(193)](this[n(183)]),this.center[n(281)]=t[n(281)],this.centerWC=Cesium.Cartographic[n(274)](this[n(183)]);var r=new Cesium.GeometryInstance({geometry:a,attributes:{color:Cesium[n(164)][n(256)](Cesium.Color[n(247)](n(238))[n(253)](0))}});let h=new(Cesium[n(175)])({geometryInstances:r,asynchronous:!1,appearance:new Cesium.EllipsoidSurfaceAppearance({material:new(Cesium[n(198)])({fabric:{type:"RZType",uniforms:{legend:this[n(263)]}},minificationFilter:Cesium.TextureMinificationFilter[n(305)],magnificationFilter:Cesium[n(269)][n(305)]})})});this[n(220)]=h;let l=new Date(Date[n(294)]());l[n(296)](17,0,0),this[n(174)]=0,this[n(163)]=60,l=Cesium[n(289)][n(168)](l),this[n(302)]=l;let m=this[n(192)]({time:l}),c=new(Cesium[n(234)])({context:e[n(169)][n(231)],lightCamera:m,enabled:!0});this[n(235)]=c,this[n(250)]=new(Cesium[n(276)])({color:new Cesium.Color(0,0,0,0),pass:Cesium[n(197)][n(226)],owner:this,framebuffer:this._fb}),this[n(295)]=!1,Cesium[n(273)][n(191)]({blending:Cesium[n(293)][n(188)]});let u=this;this[n(220)].readyPromise[n(267)]((t=>{const i=n;d(!0);let a=t[i(242)],o=a[i(275)]((t=>{const n=i;t[n(186)]=!0;let a=Cesium[n(234)].createReceiveDerivedCommand([u[n(235)]],t,!0,e[n(169)]._context,{});a.receiveCommand.receiveShadows=!1;const s=Cesium[n(196)](Cesium.BlendingState[n(162)],!0),o=new(Cesium[n(181)])(0,0,0,0);return s[n(292)]=o,a.receiveCommand[n(213)].blending=s,a.receiveCommand[n(177)]=7,a[n(290)].framebuffer=u[n(211)],a[n(290)]}));u[i(272)]=o,d(!1),u.polygonCmds=a[i(275)]((e=>{const t=i;let n=Cesium[t(196)](e);return n[t(277)][t(260)]=function(){return s[t(187)][0]},n[t(277)][t(227)]=function(){return u.vtxfTexture},n})),u[i(220)][i(200)]=!1,u._isready=!0})),e[n(169)][n(287)].add(this.polygonprimitrive)}}[u(219)](){const e=u;var t=viewer[e(169)][e(231)];return new Cesium.Framebuffer({context:t,colorTextures:[new Cesium.Texture({context:t,width:t.canvas[e(245)],height:t[e(204)][e(281)]})],depthStencilRenderbuffer:new(Cesium[e(239)])({context:t,width:t[e(204)][e(245)],height:t[e(204)].height,format:Cesium[e(185)][e(270)]})})}setSamplePoints(e){const t=u;this[t(221)]=e,this[t(233)]=!1}[u(297)](e){const t=u;if(!this[t(200)])return;let n=this;if(this[t(295)]&&Cesium[t(262)](this[t(272)]))if(e[t(228)][t(229)][t(182)](this[t(301)])||(this._index=0,this._isSampleDone=!1,this[t(301)]=Cesium[t(196)](e[t(228)][t(229)])),0==this[t(174)]&&e[t(180)][t(280)](this._clearColorCommand),this[t(174)]<this._count){let i=Cesium.JulianDate[t(252)](this[t(302)],10*this[t(174)],new(Cesium[t(289)])),a=this[t(192)]({time:i});this[t(235)][t(202)][t(229)]=a[t(229)],this._shadowmap[t(202)][t(189)]=a[t(189)],this[t(235)][t(303)]=!0,e[t(225)][t(280)](this._shadowmap),this[t(272)][t(232)]((e=>{const i=t;e[i(291)]=n[i(220)][i(291)]})),e.commandList[t(280)](...this[t(272)]),this[t(174)]++}else{if(this[t(221)]&&this._sampleCallback&&!this[t(233)]){let e=this[t(221)][t(275)]((e=>Cesium[t(218)][t(193)](e)));var i=function(e,t,n){var i=a,s=viewer[i(185)].context;const o=s[i(181)];if(o.checkFramebufferStatus(o[i(200)])===o[i(226)])return t[i(182)]((t=>{var a=i;null!=n&&(t[a(201)]=n),t=Cesium.Cartographic.toCartesian(t);let o=Cesium[a(199)][a(218)](viewer.scene,t);return s[a(195)]({x:Number.parseInt(o.x),y:Number[a(187)](o.y),width:1,height:1,framebuffer:e})}))}(this[t(211)],e,this[t(304)][t(281)]);this[t(236)](i),this[t(233)]=!0}this[t(190)][t(232)]((e=>{const i=t;e[i(291)]=n[i(220)][i(291)]})),e[t(180)].push(...this[t(190)])}}setSunAndMoonDirections(e){const t=u;let n=new Cesium.Cartesian3,i=new(Cesium[t(176)]);Cesium.defined(Cesium[t(261)][t(217)](e.time,i))||(i=Cesium[t(261)][t(307)](e[t(282)],i));let a=Cesium.Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(e.time,n);Cesium[t(176)][t(224)](i,a,a);let s=new(Cesium[t(179)]);Cesium[t(179)][t(222)](a,s);let o=new(Cesium[t(265)])(viewer[t(169)]);return o[t(229)]=a,o[t(189)]=s,o}[u(255)](){}[u(165)](e,t){const n=u;this.viewer=e,this.shadowMap=e[n(169)].shadowMap,this.lightCamera=this[n(248)][n(203)],this[n(167)]=t[n(167)]||Cesium[n(181)][n(223)],this[n(288)]=t[n(288)]||Cesium[n(181)][n(285)],this[n(206)]=.5}clear(){}[u(230)](){const e=u;this[e(220)]&&viewer.scene[e(287)][e(278)](this[e(220)])}}e.RZPrimitiveX=w}));
