!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(e,n){const a=i();return(t=function(e,t){return a[e-=464]})(e,n)}function i(){const e=["type","fromColor","maxdistance","1577259lbfYCo","fromCssColorString","VERTEX_FORMAT","entities","features","tollerance","coordinates","Polygon","PerInstanceColorAppearance","3791354hqlGcX","PolygonGeometry","EllipsoidSurfaceAppearance","ClassificationType","fromDegreesArrayHeights","ColorGeometryInstanceAttribute","37HqnXHw","MultiPolygon","Cartesian3","_polygonHierarchy","1309452muBKiD","withAlpha","PolygonHierarchy","21969032MBgiAm","44778WxbulP","add","#ff0000","maxcount","fromDegreesArray","map","6201625SypFHa","917392gjuQtP","CESIUM_3D_TILE","Primitive"];return(i=function(){return e})()}function n(){var e=["href","click","697107voQhVq","2295sIiGSb","318ZFkBAg","wgs84ToWindowCoordinates","putImageData","#08f210","8435aQEynC","set","7856gxvLUz","7小时以上","#00baf6","FRAMEBUFFER_COMPLETE","3037853JDobyx","toDataURL","createElement","#06f4f7","canvas","_gl","map","length","6-7小时","scene","getContext","parseInt","width","setAttribute","fillRect","download","317306DqUUWQ","body","appendChild","readPixels","none","#f5f701","checkFramebufferStatus","SceneTransforms","FRAMEBUFFER","height","4koAECg","1-2小时","createImageData","2-3小时","8592860oebnDM","#f9a100","src","display","421361GAodcg","4-5小时","context"];return(n=function(){return e})()}function a(e,t){var i=n();return(a=function(e,t){return i[e-=178]})(e,t)}function o(){const e=["push","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","3337956aHHgJR","USE_SOFT_SHADOWS","USE_NORMAL_SHADING","sources","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","_numberOfCascades","636447bHqriB","); \n",", 1.0); \n","debugCascadeColors","normalShadingSmooth","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","198IdSOCg","    return vec3(1.0); \n","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","GENERATE_POSITION","_terrainBias","    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n","GENERATE_POSITION_AND_NORMAL","_polygonOffsetSupported","    return normalize(","USE_NORMAL_SHADING_SMOOTH","3249182uLmerK","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","USE_SHADOW_DEPTH_TEXTURE","length","VERSION","normalShading","ShadowMapShader","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","_usesDepthTexture","SHADOW_MAP","88tKCXam","createShadowReceiveFragmentShader","51845840SGlmon","} \n","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","czm_shadow_receive_main","slice","ENABLE_VERTEX_LIGHTING","USE_CUBE_MAP_SHADOW","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","createShadowReceiveVertexShader","11FTkCHV","   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ","324037oqWpkZ","uniform sampler2D shadowMap_texture; \n","3196984TvxhQK","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","ENABLE_DAYNIGHT_SHADING","_primitiveBias","defines","10SguDJD","findNormalVarying","parseInt","replaceMain","defined","    return vec4(","_isSpotLight","    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","_pointBias","softShadows","8523cZfZyB","findPositionVarying"];return(o=function(){return e})()}!function(e,i){const n=t,a=e();for(;;)try{if(650436===-parseInt(n(475))/1*(parseInt(n(483))/2)+parseInt(n(496))/3+-parseInt(n(490))/4+-parseInt(n(489))/5+parseInt(n(479))/6+-parseInt(n(469))/7+parseInt(n(482))/8)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(i),function(e,t){for(var i=a,n=e();;)try{if(233969===-parseInt(i(210))/1+parseInt(i(192))/2+-parseInt(i(215))/3*(-parseInt(i(202))/4)+parseInt(i(221))/5*(parseInt(i(217))/6)+-parseInt(i(227))/7+-parseInt(i(223))/8*(parseInt(i(216))/9)+parseInt(i(206))/10)break;n.push(n.shift())}catch(e){n.push(n.shift())}}(n);const s=c;!function(e,t){const i=c,n=e();for(;;)try{if(899686===-parseInt(i(222))/1+-parseInt(i(169))/2+parseInt(i(216))/3+parseInt(i(195))/4*(-parseInt(i(201))/5)+-parseInt(i(228))/6*(parseInt(i(193))/7)+-parseInt(i(180))/8*(parseInt(i(212))/9)+-parseInt(i(182))/10*(-parseInt(i(191))/11))break;n.push(n.shift())}catch(e){n.push(n.shift())}}(o);const r=Cesium.ShaderSource,h=Cesium[s(205)],m=Cesium[s(175)];let l;function c(e,t){const i=o();return(c=function(e,t){return i[e-=167]})(e,t)}function d(e,t){const i=s;e?function(e){const t=s,i=Number[t(203)](Cesium[t(173)].split(".")[1])>=101;l=m[t(181)],i?(m[t(190)]=function(e,i,n){const a=t,o=e.defines[a(186)](0),s=e.sources[a(186)](0);return o[a(214)](a(179)),i&&(n?o[a(214)](a(234)):o[a(214)](a(231))),new r({defines:o,sources:s})},m.createShadowReceiveFragmentShader=function(e,i,n,a,o){const s=t,m=r[s(202)](e),l=!a&&h(m)||a&&o,c=r[s(213)](e),d=h(c),u=i[s(178)],p=i[s(235)],f=i._isPointLight,C=i._isSpotLight,w=i[s(221)]>1,g=i[s(225)],_=i[s(211)],v=f?i[s(210)]:a?i._terrainBias:i[s(199)],y=e[s(200)][s(186)](0),x=e.sources[s(186)](0),E=x[s(172)];for(let e=0;e<E;++e)x[e]=r[s(204)](x[e],"czm_shadow_receive_main");f?y.push("USE_CUBE_MAP_SHADOW"):u&&y[s(214)](s(171)),_&&!f&&y[s(214)](s(217)),w&&n&&a&&(l?y.push(s(187)):y[s(214)]("ENABLE_DAYNIGHT_SHADING")),n&&v[s(174)]&&l&&(y[s(214)](s(218)),v.normalShadingSmooth>0&&y.push("USE_NORMAL_SHADING_SMOOTH"));let S,P="";return P+=f?"uniform samplerCube shadowMap_textureCube; \n":s(194),S=d?s(206)+c+s(224):s(209),P+=s(197)+S+"} \nvec3 getNormalEC() \n{ \n"+(l?s(167)+m+s(223):s(229))+s(227)+(v.normalOffset&&l?"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n":"")+s(183),P+=s(215),P+=s(189),a?P+=s(220):p||(P+=s(177)),P+=f?s(196):C?s(184):w?s(176)+(g?s(208):""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",P+=s(192),x[s(214)](P),new r({defines:y,sources:x})}):m[t(181)]=function(e,i,n,a,o){const s=t,m=r[s(202)](e),l=!a&&h(m)||a&&o,c=r[s(213)](e),d=h(c),u=i[s(178)],p=i[s(235)],f=i._isPointLight,C=i[s(207)],w=i[s(221)]>1,g=i[s(225)],_=i.softShadows,v=f?i[s(210)]:a?i[s(232)]:i[s(199)],y=e.defines[s(186)](0),x=e[s(219)][s(186)](0),E=x.length;for(let e=0;e<E;++e)x[e]=r[s(204)](x[e],s(185));f?y.push(s(188)):u&&y[s(214)](s(171)),_&&!f&&y.push(s(217)),w&&n&&a&&(l?y[s(214)](s(187)):y[s(214)](s(198))),n&&v.normalShading&&l&&(y[s(214)](s(218)),v[s(226)]>0&&y.push(s(168)));let S,P="";return P+=f?"uniform samplerCube shadowMap_textureCube; \n":"uniform sampler2D shadowMap_texture; \n",S=d?"    return vec4("+c+s(224):s(209),P+=s(170)+S+"} \nvec3 getNormalEC() \n{ \n"+(l?s(167)+m+"); \n":"    return vec3(1.0); \n")+s(227)+(v.normalOffset&&l?s(230):"")+"} \n",P+=s(215),P+=s(189),a?P+=s(220):p||(P+="    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n"),P+=f?s(196):C?"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n":w?s(176)+(g?s(233):""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",P+="   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ",x[s(214)](P),new r({defines:y,sources:x})}}():m[i(181)]=l}function u(e,t){const i=f();return(u=function(e,t){return i[e-=398]})(e,t)}const p=u;function f(){const e=["ALPHA_BLEND","Pass","BoundingSphere","SceneTransforms","36TyouKL","shadowMap","ShadowMap","defined","ADDITIVE_BLEND","color","addMinutes","Cartographic","width","toCartesian","#ffffff","context","_lightCamera","789677NkdXDP","BlendingState","_materialCache","setHeight","computeTemeToPseudoFixedMatrix","receiveShadows","setSunAndMoonDirections","createFramebuffer","RenderState","uniformMap","clampground","Texture","_gl","centerWC","JulianDate","canvas","_shadowmap","polygonprimitrive","Camera","fromCache","clear","legend_0","Transforms","4147312OzsqUo","destory","readyPromise","terrainProvider","height","refresh","direction","478956BfnUGq","push","Color","legends","1044710sVGSjx","createIfNeeded","Matrix4","eastNorthUpToFixedFrame","TextureMinificationFilter","_clearColorCommand","scene","update","OPAQUE","NEAREST","DEPTH_STENCIL","_samplePoints","normalize","setHours","Cartesian3","Simon1994PlanetaryPositions","lightCamera","_fb","visibleAreaColor","blending","175tCxQKu","fetchImage","GREEN","invisibleAreaColor","position","_isSampleDone","positions","then","parseInt","primitives","27316eQhILe","Renderbuffer","createShadowMap","TextureMagnificationFilter","clone","time","Material","ColorGeometryInstanceAttribute","polygonCmds","fromColor","createShadowMaps","show","_extraCmds","129120iexCZj","inverse","setSamplePoints","54ZqnaFb","Matrix3","9943021zTlBqT","_legendimage","image_1","viewer","computeIcrfToFixedMatrix","_index","map","dirty","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","internalFormat","GeometryInstance","fromPoints","Primitive","_isready","RZType","computeSunPositionInEarthInertialFrame","equals","add","sampleTerrainMostDetailed","scaleHeight","_cameraPosition","readPixels","receiveCommand","pass","fromDate","sampleCallback","center","multiply","_count","10nWXNih","commandList","VERTEX_FORMAT","_option","_context","init","alpha","now","checkFramebufferStatus","bufferView","remove","modelMatrix","Resource","RenderbufferFormat","Framebuffer","ClearCommand","DefaultImageId","framebuffer","fromCartesian"];return(f=function(){return e})()}!function(e,t){const i=u,n=e();for(;;)try{if(351958===-parseInt(i(476))/1*(parseInt(i(442))/2)+-parseInt(i(542))/3+-parseInt(i(429))/4*(-parseInt(i(419))/5)+parseInt(i(499))/6*(parseInt(i(512))/7)+parseInt(i(535))/8+parseInt(i(445))/9*(parseInt(i(399))/10)+-parseInt(i(447))/11)break;n.push(n.shift())}catch(e){n.push(n.shift())}}(f);const C=p(455);Cesium.Material[p(461)]=p(461),Cesium[p(435)][p(514)].addMaterial(Cesium[p(435)][p(461)],{fabric:{type:Cesium.Material[p(461)],uniforms:{image:Cesium[p(435)][p(492)],legend:Cesium[p(435)].DefaultImageId},source:C},translucent:function(e){return!0}});class w{constructor(e,t){const i=p;let n=this;if(this._option=t,this._samplePoints=t.samplePoints,this._sampleCallback=t[i(472)],this._isSampleDone=!1,t[i(522)]){t[i(425)]=t[i(425)][i(453)]((e=>Cesium[i(506)][i(494)](e)));const a=Cesium[i(465)](e[i(538)],t.positions);Promise.resolve(a).then((function(a){const o=i;let s=-9999;a=a[o(453)]((e=>(e.height>s&&(s=e[o(539)]),Cesium[o(506)][o(508)](e)))),t.height=s,t[o(425)]=a,n.init(e,t)}))}else n[i(481)](e,t)}[p(515)](e){const t=p;this.polygonprimitrive&&this[t(466)](e)}pickPosition(e){const t=p;var i=viewer[t(405)][t(510)];const n=i[t(524)];if(n[t(484)](n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE){let n=Cesium[t(498)].wgs84ToWindowCoordinates(viewer.scene,e);return 10*i[t(468)]({x:Number[t(427)](n.x),y:Number[t(427)](n.y),width:1,height:1,framebuffer:this[t(416)]})[0]/255}return-1}[p(540)](){this[p(452)]=0}[p(466)](e){const t=p;let i=Cesium[t(534)][t(402)](this[t(525)]),n=Cesium[t(401)][t(443)](i,new(Cesium[t(401)])),a=e-this[t(473)][t(539)],o=Cesium[t(401)].fromTranslation(new Cesium.Cartesian3(0,0,a)),s=Cesium[t(401)][t(474)](o,n,new(Cesium[t(401)]));this.polygonprimitrive[t(487)]=Cesium[t(401)][t(474)](i,s,new(Cesium[t(401)]))}[p(481)](e,t){const i=p;let n=this;this.show=!0,this.secondsOfDay=0,this[i(448)]="";var o=e[i(405)][i(510)];if(t[i(398)]&&(this._legendimage=function(e,t){var i=a;const n=16*e[i(183)];var o=document[i(178)](i(180));o[i(188)]=n,o[i(201)]=16;var s=o[i(186)]("2d");s.beginPath();for(let t=0;t<e[i(183)];t++){let n=e[t].color,a=16*t,o=0;s.fillStyle=n,s[i(190)](a,o,16,16)}var r=new Image;return r[i(208)]=o[i(228)](),r}(t.legends),Cesium[i(488)][i(400)](this[i(448)].src)[i(420)]()[i(426)]((function(t){const a=i;var o,s=e[a(405)][a(510)];o=Cesium[a(502)](t.internalFormat)?new(Cesium[a(523)])({context:s,pixelFormat:t[a(456)],width:t[a(507)],height:t[a(539)],source:{arrayBufferView:t[a(485)]}}):new Cesium.Texture({context:s,source:t}),n.vtxfTexture=o}))),this[i(467)]=new(Cesium[i(413)]),t.positions){var s=new(Cesium[i(490)])({context:o,colorTextures:[new Cesium.Texture({context:o,width:o[i(527)][i(507)],height:o.canvas.height})],depthStencilRenderbuffer:new Cesium.Renderbuffer({context:o,width:o[i(527)].width,height:o[i(527)][i(539)],format:Cesium.RenderbufferFormat[i(409)]})});this[i(416)]=s;var r=new Cesium.PolygonHierarchy(t.positions);let n=new Cesium.PolygonGeometry({polygonHierarchy:r,height:t[i(539)],vertexFormat:Cesium.EllipsoidSurfaceAppearance[i(478)]});this[i(473)]=Cesium[i(497)][i(458)](t[i(425)]).center,this.center=Cesium[i(506)][i(494)](this[i(473)]),this[i(473)][i(539)]=t[i(539)],this[i(525)]=Cesium[i(506)][i(508)](this[i(473)]);var h=new(Cesium[i(457)])({geometry:n,attributes:{color:Cesium[i(436)][i(438)](Cesium[i(544)].fromCssColorString(i(509)).withAlpha(0))}});let a=new(Cesium[i(459)])({geometryInstances:h,asynchronous:!1,appearance:new Cesium.EllipsoidSurfaceAppearance({material:new(Cesium[i(435)])({fabric:{type:"RZType",uniforms:{legend:this[i(448)]}},minificationFilter:Cesium[i(403)][i(408)],magnificationFilter:Cesium[i(432)][i(408)]})})});this[i(529)]=a;let m=new Date(Date[i(483)]());m[i(412)](16,0,0),this[i(452)]=0,this[i(475)]=48,m=Cesium[i(526)][i(471)](m),this._starttime=m;let l=this[i(518)]({time:m}),c=new(Cesium[i(501)])({context:e[i(405)].context,lightCamera:l,enabled:!0});this._shadowmap=c,this[i(404)]=new(Cesium[i(491)])({color:new(Cesium[i(544)])(0,0,0,0),pass:Cesium[i(496)][i(407)],owner:this,framebuffer:this[i(416)]}),this[i(460)]=!1,Cesium[i(520)][i(531)]({blending:Cesium[i(513)][i(495)]});let u=this;this.polygonprimitrive[i(537)][i(426)]((t=>{const n=i;d(!0);let a=t._colorCommands,o=a[n(453)]((t=>{const i=n;t[i(517)]=!0;let a=Cesium[i(501)].createReceiveDerivedCommand([u[i(528)]],t,!0,e[i(405)][i(480)],{});a[i(469)][i(517)]=!1;const o=Cesium[i(433)](Cesium.BlendingState[i(503)],!0),s=new(Cesium[i(544)])(0,0,0,0);return o[i(504)]=s,a[i(469)].renderState[i(418)]=o,a[i(469)][i(470)]=7,a[i(469)][i(493)]=u._fb,a[i(469)]}));u._extraCmds=o,d(!1),u[n(437)]=a[n(453)]((e=>{const t=n;let i=Cesium[t(433)](e);return i[t(521)][t(449)]=function(){return s._colorTextures[0]},i.uniformMap[t(533)]=function(){return u.vtxfTexture},i})),u.polygonprimitrive[n(440)]=!1,u[n(460)]=!0})),e[i(405)][i(428)][i(464)](this.polygonprimitrive)}}[p(519)](){const e=p;var t=viewer[e(405)][e(510)];return new(Cesium[e(490)])({context:t,colorTextures:[new(Cesium[e(523)])({context:t,width:t[e(527)][e(507)],height:t[e(527)][e(539)]})],depthStencilRenderbuffer:new(Cesium[e(430)])({context:t,width:t[e(527)][e(507)],height:t[e(527)][e(539)],format:Cesium[e(489)][e(409)]})})}[p(444)](e){this[p(410)]=e,this._isSampleDone=!1}[p(406)](e){const t=p;if(!this[t(440)])return;let i=this;if(this._isready&&Cesium.defined(this[t(441)]))if(e.camera.position[t(463)](this[t(467)])||(this[t(452)]=0,this[t(424)]=!1,this[t(467)]=Cesium[t(433)](e.camera[t(423)])),0==this[t(452)]&&e[t(477)].push(this[t(404)]),this._index<this[t(475)]){let n=Cesium[t(526)][t(505)](this._starttime,10*this[t(452)],new(Cesium[t(526)])),a=this.setSunAndMoonDirections({time:n});this._shadowmap[t(511)].position=a[t(423)],this[t(528)]._lightCamera[t(541)]=a[t(541)],this[t(528)][t(454)]=!0,e.shadowMaps[t(543)](this[t(528)]),this[t(441)].forEach((e=>{const n=t;e.modelMatrix=i.polygonprimitrive[n(487)]})),e.commandList.push(...this[t(441)]),this[t(452)]++}else{if(this[t(410)]&&this._sampleCallback&&!this[t(424)]){let e=this._samplePoints[t(453)]((e=>Cesium[t(506)][t(494)](e)));var n=function(e,t,i){var n=a,o=viewer[n(185)].context;const s=o[n(181)];if(s.checkFramebufferStatus(s[n(200)])===s[n(226)])return t[n(182)]((t=>{var a=n;null!=i&&(t[a(201)]=i),t=Cesium.Cartographic.toCartesian(t);let s=Cesium[a(199)][a(218)](viewer.scene,t);return o[a(195)]({x:Number.parseInt(s.x),y:Number[a(187)](s.y),width:1,height:1,framebuffer:e})}))}(this[t(416)],e,this[t(479)][t(539)]);this._sampleCallback(n),this[t(424)]=!0}this[t(437)].forEach((e=>{const n=t;e.modelMatrix=i[n(529)][n(487)]})),e[t(477)].push(...this[t(437)])}}[p(518)](e){const t=p;let i=new Cesium.Cartesian3,n=new(Cesium[t(446)]);Cesium[t(502)](Cesium[t(534)][t(451)](e[t(434)],n))||(n=Cesium.Transforms[t(516)](e[t(434)],n));let a=Cesium[t(414)][t(462)](e[t(434)],i);Cesium.Matrix3.multiplyByVector(n,a,a);let o=new(Cesium[t(413)]);Cesium.Cartesian3[t(411)](a,o);let s=new(Cesium[t(530)])(viewer[t(405)]);return s[t(423)]=a,s[t(541)]=o,s}[p(439)](){}[p(431)](e,t){const i=p;this[i(450)]=e,this.shadowMap=e[i(405)][i(500)],this[i(415)]=this[i(500)][i(415)],this.visibleAreaColor=t[i(417)]||Cesium[i(544)][i(421)],this.invisibleAreaColor=t[i(422)]||Cesium.Color.RED,this[i(482)]=.5}[p(532)](){}[p(536)](){const e=p;this[e(529)]&&viewer[e(405)].primitives[e(486)](this.polygonprimitrive)}}e.RZPrimitiveX=w}));
