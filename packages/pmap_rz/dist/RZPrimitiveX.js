!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(){const e=["1208SsVkPP","withAlpha","71407HujuGP","coordinates","405HCuaxu","add","_polygonHierarchy","Color","map","tollerance","312480UKzpHh","EllipsoidSurfaceAppearance","2040mCKQCh","1577770RpnlXo","RED","138HHjjVP","1SHNZXB","geometry","flat","PerInstanceColorAppearance","maxdistance","CESIUM_3D_TILE","type","ColorGeometryInstanceAttribute","532438eTuJPi","7017505eXGRuO","15320GswtXC","PolygonGeometry","Primitive","Cartesian3","GeometryInstance","PolygonHierarchy","maxcount","fromColor","features","ClassificationType","fromDegreesArray","fromCssColorString","MultiPolygon"];return(t=function(){return e})()}function i(e,n){const a=t();return(i=function(e,t){return a[e-=165]})(e,n)}function n(e,t){var i=a();return(n=function(e,t){return i[e-=299]})(e,t)}function a(){var e=["#06f4f7","#f50205","length","463000dmsBhC","FRAMEBUFFER","1-2小时","_gl","689781KmhRKz","973555yiPnMR","Cartographic","3540264gPPqQZ","4-5小时","set","width","#f9a100","appendChild","context","7小时以上","getContext","src","canvas","2161532sHUCWU","SceneTransforms","toCartesian","style","fillStyle","createElement","none","height","click","toDataURL","download","#f5f701","checkFramebufferStatus","parseInt","display","wgs84ToWindowCoordinates","fillRect","color","2-3小时","setAttribute","6-7小时","beginPath","FRAMEBUFFER_COMPLETE","7185997KkbFNG","#a7f637","#08f210","readPixels","body","1978884MEDYNA","scene"];return(a=function(){return e})()}!function(e,t){const n=i,a=e();for(;;)try{if(135031===parseInt(n(184))/1*(-parseInt(n(192))/2)+-parseInt(n(178))/3+parseInt(n(168))/4*(-parseInt(n(180))/5)+-parseInt(n(183))/6*(-parseInt(n(170))/7)+-parseInt(n(194))/8*(parseInt(n(172))/9)+-parseInt(n(181))/10+parseInt(n(193))/11)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(t),function(e,t){for(var i=n,a=e();;)try{if(585006===parseInt(i(345))/1+-parseInt(i(340))/2+parseInt(i(349))/3+-parseInt(i(312))/4+-parseInt(i(299))/5+parseInt(i(301))/6+parseInt(i(335))/7)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(a);const s=o;function o(e,t){const i=u();return(o=function(e,t){return i[e-=269]})(e,t)}!function(e,t){const i=o,n=e();for(;;)try{if(211583===-parseInt(i(324))/1+-parseInt(i(294))/2+parseInt(i(284))/3*(parseInt(i(332))/4)+-parseInt(i(322))/5*(parseInt(i(325))/6)+-parseInt(i(296))/7+parseInt(i(331))/8*(-parseInt(i(326))/9)+parseInt(i(304))/10)break;n.push(n.shift())}catch(e){n.push(n.shift())}}(u);const r=Cesium[s(277)],m=Cesium[s(303)],l=Cesium[s(333)];let h;function c(e,t){e?function(e){const t=s,i=Number[t(330)](Cesium.VERSION.split(".")[1])>=101;h=l[t(312)],i?(l[t(290)]=function(e,i,n){const a=t,s=e[a(274)][a(335)](0),o=e[a(270)][a(335)](0);return s[a(317)](a(328)),i&&(n?s[a(317)]("GENERATE_POSITION_AND_NORMAL"):s[a(317)](a(308))),new r({defines:s,sources:o})},l[t(312)]=function(e,i,n,a,s){const o=t,l=r[o(272)](e),h=!a&&m(l)||a&&s,c=r[o(293)](e),u=m(c),d=i._usesDepthTexture,f=i[o(280)],p=i._isPointLight,C=i[o(269)],w=i[o(271)]>1,g=i[o(287)],_=i.softShadows,v=p?i[o(291)]:a?i._terrainBias:i[o(300)],y=e[o(274)][o(335)](0),x=e[o(270)][o(335)](0),E=x[o(278)];for(let e=0;e<E;++e)x[e]=r[o(327)](x[e],o(273));p?y[o(317)]("USE_CUBE_MAP_SHADOW"):d&&y[o(317)](o(275)),_&&!p&&y[o(317)]("USE_SOFT_SHADOWS"),w&&n&&a&&(h?y.push(o(288)):y[o(317)]("ENABLE_DAYNIGHT_SHADING")),n&&v[o(279)]&&h&&(y[o(317)]("USE_NORMAL_SHADING"),v[o(305)]>0&&y[o(317)](o(286)));let S,P="";return P+=p?"uniform samplerCube shadowMap_textureCube; \n":"uniform sampler2D shadowMap_texture; \n",S=u?o(297)+c+o(283):o(301),P+=o(298)+S+o(319)+(h?o(316)+l+o(289):"    return vec3(1.0); \n")+o(295)+(v.normalOffset&&h?o(323):"")+o(313),P+="void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",P+=o(281),a?P+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":f||(P+=o(315)),P+=p?o(318):C?o(307):w?o(309)+(g?o(329):""):o(302),P+=o(299),x[o(317)](P),new r({defines:y,sources:x})}):l[t(312)]=function(e,i,n,a,s){const o=t,l=r[o(272)](e),h=!a&&m(l)||a&&s,c=r.findPositionVarying(e),u=m(c),d=i[o(282)],f=i._polygonOffsetSupported,p=i[o(321)],C=i[o(269)],w=i[o(271)]>1,g=i[o(287)],_=i[o(334)],v=p?i._pointBias:a?i[o(276)]:i._primitiveBias,y=e[o(274)].slice(0),x=e[o(270)][o(335)](0),E=x.length;for(let e=0;e<E;++e)x[e]=r[o(327)](x[e],o(273));p?y[o(317)]("USE_CUBE_MAP_SHADOW"):d&&y[o(317)](o(275)),_&&!p&&y[o(317)](o(320)),w&&n&&a&&(h?y.push("ENABLE_VERTEX_LIGHTING"):y[o(317)]("ENABLE_DAYNIGHT_SHADING")),n&&v.normalShading&&h&&(y[o(317)](o(336)),v[o(305)]>0&&y[o(317)](o(286)));let S,P="";return P+=p?"uniform samplerCube shadowMap_textureCube; \n":o(292),S=u?o(297)+c+o(283):o(301),P+="uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n"+S+o(319)+(h?o(316)+l+o(289):o(337))+o(295)+(v[o(310)]&&h?o(323):"")+o(313),P+=o(285),P+=o(281),a?P+=o(314):f||(P+="    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n"),P+=p?o(318):C?o(307):w?o(309)+(g?o(306):""):o(302),P+=o(311),x[o(317)](P),new r({defines:y,sources:x})}}():l.createShadowReceiveFragmentShader=h}function u(){const e=["USE_SOFT_SHADOWS","_isPointLight","295WBEUVt","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","292272ruDgRO","27822VHFKiD","27lMpFUs","replaceMain","SHADOW_MAP","    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n","parseInt","649016WNARDM","2364ixxFBl","ShadowMapShader","softShadows","slice","USE_NORMAL_SHADING","    return vec3(1.0); \n","_isSpotLight","sources","_numberOfCascades","findNormalVarying","czm_shadow_receive_main","defines","USE_SHADOW_DEPTH_TEXTURE","_terrainBias","ShaderSource","length","normalShading","_polygonOffsetSupported","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","_usesDepthTexture",", 1.0); \n","333VviksZ","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","USE_NORMAL_SHADING_SMOOTH","debugCascadeColors","ENABLE_VERTEX_LIGHTING","); \n","createShadowReceiveVertexShader","_pointBias","uniform sampler2D shadowMap_texture; \n","findPositionVarying","67270mOwimv","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","708855XbwFNS","    return vec4(","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ","_primitiveBias","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","defined","10901180qVcwpN","normalShadingSmooth","    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","GENERATE_POSITION","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","normalOffset","   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","createShadowReceiveFragmentShader","} \n","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","    return normalize(","push","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","} \nvec3 getNormalEC() \n{ \n"];return(u=function(){return e})()}const d=f;function f(e,t){const i=p();return(f=function(e,t){return i[e-=196]})(e,t)}function p(){const e=["Renderbuffer","pass","readyPromise","multiply","_isSampleDone","_sampleCallback","_shadowmap","fromPoints","_index","renderState","computeSunPositionInEarthInertialFrame","1694695HrQrzs","_realMode","addMinutes","switchToPerspectiveFrustum","camera","setSunAndMoonDirections","ADDITIVE_BLEND","canvas","color","clone","Matrix4","checkFramebufferStatus","RenderbufferFormat","4WoDlfs","Framebuffer","polygonprimitrive","direction","Cartographic","1232ClLiCI","Texture","push","initx","add","GeometryInstance","1799290yWyzsf","inverse","width","_samplePoints","height","fromCssColorString","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","Cartesian4","then","PolygonHierarchy","remove","Matrix3","_gl","commandList","toCartesian","VERTEX_FORMAT","Material","fromDate","setHeight","context","_colorCommands","setHours","_colorTextures","withAlpha","forEach","vtxfTexture","readPixels","positions","realMode","modelViewProjection","TextureMinificationFilter","legend_0","RenderState","_extraCmds","EllipsoidSurfaceAppearance","ALPHA_BLEND","_starttime","PolygonGeometry","DefaultImageId","NEAREST","_clearColorCommand","time","polygonCmds","wgs84ToWindowCoordinates","addMaterial","image_1","createIfNeeded","fromTranslation","Transforms","_legendimage","destory","equals","position","_isready","HeadingPitchRange","FRAMEBUFFER","_fb","resolve","scaleHeight","dirty","_materialCache","receiveCommand","fromCache","4692885xPDsrW","divideByScalar","2JtODJf","primitives","eastNorthUpToFixedFrame","map","now","center","21776FoGSjL","BlendingState","RZType2","defined","_lightCamera","src","scene","Cartesian3","RZType","1221867sAWYit","DEPTH_STENCIL","SceneTransforms","legends","fromCartesian","clampground","fetchImage","parseInt","_cameraPosition","pickPosition","Color","FRAMEBUFFER_COMPLETE","ClearCommand","Pass","85066dVnUnE","Primitive","sampleCallback","normalize","bufferView","receiveShadows","shadowMaps","show","init","flyToBoundingSphere","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,materialInput.st).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","ShadowMap","_option","samplePoints","modelMatrix","_count","152022lHOqat","sampleTerrainMostDetailed","centerWC","JulianDate"];return(p=function(){return e})()}!function(e,t){const i=f,n=e();for(;;)try{if(900853===-parseInt(i(254))/1*(-parseInt(i(283))/2)+parseInt(i(252))/3+-parseInt(i(327))/4*(parseInt(i(314))/5)+parseInt(i(299))/6+parseInt(i(332))/7*(-parseInt(i(260))/8)+-parseInt(i(269))/9+parseInt(i(338))/10)break;n.push(n.shift())}catch(e){n.push(n.shift())}}(p);const C=d(344),w=d(293);Cesium[d(205)][d(268)]=d(268),Cesium[d(205)][d(249)].addMaterial(Cesium.Material[d(268)],{fabric:{type:Cesium.Material.RZType,uniforms:{image:Cesium[d(205)][d(227)],legend:Cesium[d(205)][d(227)]},source:C},translucent:function(e){return!0}}),Cesium[d(205)].RZType2=d(262),Cesium.Material[d(249)][d(233)](Cesium[d(205)][d(262)],{fabric:{type:Cesium[d(205)][d(262)],uniforms:{image:Cesium[d(205)][d(227)],legend:Cesium[d(205)][d(227)]},source:w},translucent:function(e){return!0}});class g{constructor(e,t){const i=d;let n=this;if(this._option=t,this[i(341)]=t[i(296)],this[i(308)]=t[i(285)],this._isSampleDone=!1,this._realMode=null!=t[i(217)]&&t.realMode,t[i(274)]){t[i(216)]=t[i(216)][i(257)]((e=>Cesium[i(331)][i(273)](e)));const a=Cesium[i(300)](e.terrainProvider,t[i(216)]);Promise[i(246)](a)[i(197)]((function(a){const s=i;let o=-9999;a=a.map((e=>(e[s(342)]>o&&(o=e.height),Cesium.Cartographic[s(203)](e)))),t[s(342)]=o,t[s(216)]=a,n[s(335)](e,t)}))}else n[i(335)](e,t)}[d(207)](e){this[d(329)]&&this.scaleHeight(e)}[d(278)](e){const t=d;var i=viewer[t(266)][t(208)];const n=i[t(201)];if(n[t(325)](n[t(244)])===n[t(280)]){let n=Cesium[t(271)][t(232)](viewer[t(266)],e);return i[t(215)]({x:Number[t(276)](n.x),y:Number[t(276)](n.y),width:1,height:1,framebuffer:this[t(245)]})[0]*(this._count/6)/255}return-1}refresh(){this[d(311)]=0}[d(247)](e){const t=d;let i=Cesium[t(237)][t(256)](this[t(301)]),n=Cesium[t(324)][t(339)](i,new(Cesium[t(324)])),a=e-this[t(259)][t(342)],s=Cesium[t(324)][t(236)](new(Cesium[t(267)])(0,0,a)),o=Cesium[t(324)][t(306)](s,n,new(Cesium[t(324)]));this[t(329)].modelMatrix=Cesium[t(324)][t(306)](i,o,new(Cesium[t(324)]))}[d(335)](e,t){const i=d;let n=this;if(this[i(315)])this[i(291)](e,t);else{let a=t[i(216)][i(257)]((e=>{const n=i;let a=Cesium[n(331)][n(273)](e);return a.height=t.height,Cesium[n(331)][n(203)](a)})),s=Cesium.BoundingSphere.fromPoints(a);e[i(266)][i(318)][i(317)](),e[i(266)][i(318)][i(292)](s,{offset:new(Cesium[i(243)])(0,-1.57,0),complete:function(){n.init(e,t)}})}}init(e,t){const i=d;let a=this;this[i(290)]=!0,this.secondsOfDay=0,this._legendimage="";var s=e[i(266)][i(208)];if(t[i(272)]&&(this[i(238)]=function(e,t){var i=n;const a=16*e[i(344)];var s=document[i(317)]("canvas");s[i(304)]=a,s.height=16;var o=s[i(309)]("2d");o[i(333)]();for(let t=0;t<e[i(344)];t++){let n=e[t][i(329)],a=16*t,s=0;o[i(316)]=n,o[i(328)](a,s,16,16)}var r=new Image;return r[i(310)]=s[i(321)](),r}(t[i(272)]),Cesium.Resource[i(235)](this[i(238)][i(265)])[i(275)]()[i(197)]((function(t){const n=i;var s,o=e.scene.context;s=Cesium[n(263)](t.internalFormat)?new(Cesium[n(333)])({context:o,pixelFormat:t.internalFormat,width:t[n(340)],height:t[n(342)],source:{arrayBufferView:t[n(287)]}}):new(Cesium[n(333)])({context:o,source:t}),a[n(214)]=s}))),this[i(277)]=new(Cesium[i(267)]),t[i(216)]){var o=new(Cesium[i(328)])({context:s,colorTextures:[new(Cesium[i(333)])({context:s,width:s[i(321)].width,height:s[i(321)].height})],depthStencilRenderbuffer:new Cesium.Renderbuffer({context:s,width:s[i(321)][i(340)],height:s[i(321)][i(342)],format:Cesium[i(326)][i(270)]})});let n;if(this._fb=o,!this._realMode){let a=t[i(216)][i(257)]((n=>{const a=i;let s=Cesium[a(331)].fromCartesian(n);s[a(342)]=t[a(342)],n=Cesium.Cartographic[a(203)](s);let o=Cesium[a(324)].multiplyByVector(e[a(266)][a(208)].uniformState[a(218)],new(Cesium[a(196)])(n.x,n.y,n.z,1),new(Cesium[a(196)])),r=Cesium[a(196)][a(336)](Cesium[a(196)][a(253)](Cesium.Cartesian4[a(253)](o,o.w,new Cesium.Cartesian4),2,new(Cesium[a(196)])),new(Cesium[a(196)])(.5,.5),new(Cesium[a(196)]));return r.x=r.x>1?1:r.x,r.x=r.x<0?0:r.x,r.y=r.y>1?1:r.y,r.y=r.y<0?0:r.y,new Cesium.Cartesian2(r.x,r.y)}));n=new(Cesium[i(198)])(a)}var r=new(Cesium[i(198)])(t.positions);let a;a=n?new Cesium.PolygonGeometry({polygonHierarchy:r,height:t[i(342)],vertexFormat:Cesium[i(223)][i(204)],textureCoordinates:n}):new(Cesium[i(226)])({polygonHierarchy:r,height:t.height,vertexFormat:Cesium[i(223)][i(204)]}),this.center=Cesium.BoundingSphere[i(310)](t[i(216)])[i(259)],this[i(259)]=Cesium[i(331)].fromCartesian(this[i(259)]),this.center.height=t[i(342)],this[i(301)]=Cesium.Cartographic.toCartesian(this.center);var m=new(Cesium[i(337)])({geometry:a,attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium[i(279)][i(343)]("#ffffff")[i(212)](0))}});let l=new(Cesium[i(284)])({geometryInstances:m,asynchronous:!1,appearance:new(Cesium[i(223)])({material:new(Cesium[i(205)])({fabric:{type:this._realMode?i(268):i(262),uniforms:{legend:this[i(238)]}},minificationFilter:Cesium[i(219)][i(228)],magnificationFilter:Cesium.TextureMagnificationFilter[i(228)]})})});this[i(329)]=l;let h=new Date(Date[i(258)]());h[i(210)](16,0,0),this._index=0,this[i(298)]=48,h=Cesium.JulianDate[i(206)](h),this[i(225)]=h;let u=this[i(319)]({time:h}),d=new(Cesium[i(294)])({context:e[i(266)][i(208)],lightCamera:u,enabled:!0});this._shadowmap=d,this[i(229)]=new(Cesium[i(281)])({color:new(Cesium[i(279)])(0,0,0,0),pass:Cesium[i(282)].OPAQUE,owner:this,framebuffer:this[i(245)]}),this[i(242)]=!1,Cesium[i(221)][i(251)]({blending:Cesium[i(261)][i(224)]});let f=this;this[i(329)][i(305)][i(197)]((t=>{const n=i;c(!0);let a=t[n(209)],s=a[n(257)]((t=>{const i=n;t[i(288)]=!0;let a=Cesium[i(294)].createReceiveDerivedCommand([f._shadowmap],t,!0,e[i(266)]._context,{});a[i(250)][i(288)]=!1;const s=Cesium[i(323)](Cesium[i(261)][i(320)],!0),o=new Cesium.Color(0,0,0,0);return s[i(322)]=o,a[i(250)][i(312)].blending=s,a[i(250)][i(304)]=7,a[i(250)].framebuffer=f[i(245)],a[i(250)]}));f[n(222)]=s,c(!1),f.polygonCmds=a[n(257)]((e=>{const t=n;let i=Cesium[t(323)](e);return i.uniformMap[t(234)]=function(){return o[t(211)][0]},i.uniformMap[t(220)]=function(){return f[t(214)]},i})),f.polygonprimitrive[n(290)]=!1,f[n(242)]=!0})),e[i(266)][i(255)][i(336)](this[i(329)])}}createFramebuffer(){const e=d;var t=viewer[e(266)][e(208)];return new(Cesium[e(328)])({context:t,colorTextures:[new(Cesium[e(333)])({context:t,width:t[e(321)].width,height:t[e(321)][e(342)]})],depthStencilRenderbuffer:new(Cesium[e(303)])({context:t,width:t[e(321)][e(340)],height:t[e(321)].height,format:Cesium[e(326)].DEPTH_STENCIL})})}setSamplePoints(e){const t=d;this[t(341)]=e,this[t(307)]=!1}update(e){const t=d;if(!this[t(290)])return;let i=this;if(this[t(242)]&&Cesium[t(263)](this[t(222)]))if(!e.camera[t(241)][t(240)](this._cameraPosition)&&this[t(315)]&&(this._index=0,this[t(307)]=!1,this._cameraPosition=Cesium[t(323)](e[t(318)].position)),0==this[t(311)]&&e.commandList[t(334)](this[t(229)]),this[t(311)]<this[t(298)]){let n=Cesium.JulianDate[t(316)](this._starttime,10*this[t(311)],new(Cesium[t(302)])),a=this.setSunAndMoonDirections({time:n});this._shadowmap[t(264)][t(241)]=a.position,this[t(309)][t(264)][t(330)]=a[t(330)],this._shadowmap[t(248)]=!0,e[t(289)][t(334)](this[t(309)]),this._extraCmds[t(213)]((e=>{const n=t;e[n(297)]=i[n(329)].modelMatrix})),e[t(202)][t(334)](...this[t(222)]),this[t(311)]++}else{if(this[t(341)]&&this[t(308)]&&!this._isSampleDone){let e=this._samplePoints.map((e=>Cesium[t(331)][t(273)](e)));var a=function(e,t,i){var a=n,s=viewer[a(341)].context;const o=s[a(348)];if(o[a(324)](o[a(346)])===o[a(334)])return t.map((t=>{var n=a;null!=i&&(t[n(319)]=i),t=Cesium[n(300)][n(314)](t);let o=Cesium[n(313)][n(327)](viewer.scene,t);return s[n(338)]({x:Number[n(325)](o.x),y:Number[n(325)](o.y),width:1,height:1,framebuffer:e})}))}(this[t(245)],e,this[t(295)][t(342)]);this[t(308)](a),this[t(307)]=!0}this[t(231)].forEach((e=>{const n=t;e[n(297)]=i[n(329)][n(297)]})),e[t(202)][t(334)](...this[t(231)])}}setSunAndMoonDirections(e){const t=d;let i=new(Cesium[t(267)]),n=new Cesium.Matrix3;Cesium[t(263)](Cesium[t(237)].computeIcrfToFixedMatrix(e.time,n))||(n=Cesium.Transforms.computeTemeToPseudoFixedMatrix(e[t(230)],n));let a=Cesium.Simon1994PlanetaryPositions[t(313)](e[t(230)],i);Cesium[t(200)].multiplyByVector(n,a,a);let s=new(Cesium[t(267)]);Cesium[t(267)][t(286)](a,s);let o=new Cesium.Camera(viewer[t(266)]);return o[t(241)]=a,o[t(330)]=s,o}clear(){}[d(239)](){const e=d;this[e(329)]&&viewer[e(266)][e(255)][e(199)](this.polygonprimitrive)}}e.RZPrimitiveX=g}));
