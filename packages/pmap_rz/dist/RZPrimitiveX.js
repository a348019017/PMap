!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(e,n){const a=i();return(t=function(e,t){return a[e-=464]})(e,n)}function i(){const e=["type","fromColor","maxdistance","1577259lbfYCo","fromCssColorString","VERTEX_FORMAT","entities","features","tollerance","coordinates","Polygon","PerInstanceColorAppearance","3791354hqlGcX","PolygonGeometry","EllipsoidSurfaceAppearance","ClassificationType","fromDegreesArrayHeights","ColorGeometryInstanceAttribute","37HqnXHw","MultiPolygon","Cartesian3","_polygonHierarchy","1309452muBKiD","withAlpha","PolygonHierarchy","21969032MBgiAm","44778WxbulP","add","#ff0000","maxcount","fromDegreesArray","map","6201625SypFHa","917392gjuQtP","CESIUM_3D_TILE","Primitive"];return(i=function(){return e})()}function n(){var e=["href","click","697107voQhVq","2295sIiGSb","318ZFkBAg","wgs84ToWindowCoordinates","putImageData","#08f210","8435aQEynC","set","7856gxvLUz","7小时以上","#00baf6","FRAMEBUFFER_COMPLETE","3037853JDobyx","toDataURL","createElement","#06f4f7","canvas","_gl","map","length","6-7小时","scene","getContext","parseInt","width","setAttribute","fillRect","download","317306DqUUWQ","body","appendChild","readPixels","none","#f5f701","checkFramebufferStatus","SceneTransforms","FRAMEBUFFER","height","4koAECg","1-2小时","createImageData","2-3小时","8592860oebnDM","#f9a100","src","display","421361GAodcg","4-5小时","context"];return(n=function(){return e})()}function a(e,t){var i=n();return(a=function(e,t){return i[e-=178]})(e,t)}!function(e,i){const n=t,a=e();for(;;)try{if(650436===-parseInt(n(475))/1*(parseInt(n(483))/2)+parseInt(n(496))/3+-parseInt(n(490))/4+-parseInt(n(489))/5+parseInt(n(479))/6+-parseInt(n(469))/7+parseInt(n(482))/8)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(i),function(e,t){for(var i=a,n=e();;)try{if(233969===-parseInt(i(210))/1+parseInt(i(192))/2+-parseInt(i(215))/3*(-parseInt(i(202))/4)+parseInt(i(221))/5*(parseInt(i(217))/6)+-parseInt(i(227))/7+-parseInt(i(223))/8*(parseInt(i(216))/9)+parseInt(i(206))/10)break;n.push(n.shift())}catch(e){n.push(n.shift())}}(n);const s=o;function o(e,t){const i=c();return(o=function(e,t){return i[e-=149]})(e,t)}!function(e,t){const i=o,n=e();for(;;)try{if(299124===-parseInt(i(149))/1+-parseInt(i(162))/2*(-parseInt(i(168))/3)+-parseInt(i(193))/4*(-parseInt(i(198))/5)+parseInt(i(161))/6+-parseInt(i(179))/7*(-parseInt(i(171))/8)+parseInt(i(163))/9*(parseInt(i(199))/10)+-parseInt(i(196))/11*(parseInt(i(157))/12))break;n.push(n.shift())}catch(e){n.push(n.shift())}}(c);const r=Cesium.ShaderSource,h=Cesium[s(212)],l=Cesium[s(214)];let m;function c(){const e=["    return vec3(1.0); \n","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","createShadowReceiveFragmentShader","32dBhKTe","_isPointLight","_usesDepthTexture","66LBwTZU",", 1.0); \n","306770mRPrsV","20BgLqjd","normalOffset","push","USE_CUBE_MAP_SHADOW","length","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","_pointBias","USE_SHADOW_DEPTH_TEXTURE","ENABLE_DAYNIGHT_SHADING","normalShading","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","slice","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","defined","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","ShadowMapShader","_primitiveBias","338127ldsOVV","split","_terrainBias","    return vec4(","   \n      float rd=0.016667;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","uniform samplerCube shadowMap_textureCube; \n","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","1118508jNtkLW","sources","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","255402LhVlzF","14XnwrAc","303147ZfSEHb","USE_NORMAL_SHADING_SMOOTH","    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n","parseInt","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","87708qFUwkj","defines","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","128gbrTIS","uniform sampler2D shadowMap_texture; \n","_isSpotLight","findNormalVarying","    return normalize(","USE_SOFT_SHADOWS","softShadows","} \n","171101qRZpuV","findPositionVarying","_numberOfCascades","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","USE_NORMAL_SHADING","} \nvec3 getNormalEC() \n{ \n","czm_shadow_receive_main","   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.016667;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ","ENABLE_VERTEX_LIGHTING","replaceMain","); \n"];return(c=function(){return e})()}function d(e){const t=s;e?function(){const e=s,t=Number[e(166)](Cesium.VERSION[e(150)](".")[1])>=101;m=l[e(192)],t?(l.createShadowReceiveVertexShader=function(t,i,n){const a=e,s=t[a(169)][a(210)](0),o=t[a(158)][a(210)](0);return s[a(201)]("SHADOW_MAP"),i&&(n?s[a(201)]("GENERATE_POSITION_AND_NORMAL"):s.push("GENERATE_POSITION")),new r({defines:s,sources:o})},l.createShadowReceiveFragmentShader=function(t,i,n,a,s){const o=e,l=r[o(174)](t),m=!a&&h(l)||a&&s,c=r[o(180)](t),d=h(c),u=i[o(195)],f=i._polygonOffsetSupported,p=i._isPointLight,C=i[o(173)],w=i[o(181)]>1,g=i.debugCascadeColors,_=i[o(177)],v=p?i[o(205)]:a?i._terrainBias:i[o(215)],E=t[o(169)].slice(0),x=t[o(158)][o(210)](0),y=x[o(203)];for(let e=0;e<y;++e)x[e]=r.replaceMain(x[e],o(185));p?E[o(201)](o(202)):u&&E.push("USE_SHADOW_DEPTH_TEXTURE"),_&&!p&&E[o(201)](o(176)),w&&n&&a&&(m?E[o(201)](o(187)):E[o(201)](o(207))),n&&v[o(208)]&&m&&(E[o(201)](o(183)),v.normalShadingSmooth>0&&E.push(o(164)));let D,S="";return S+=o(p?155:172),D=d?"    return vec4("+c+o(197):"#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n",S+=o(167)+D+o(184)+(m?"    return normalize("+l+"); \n":"    return vec3(1.0); \n")+o(159)+(v.normalOffset&&m?"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n":"")+o(178),S+=o(213),S+=o(204),a?S+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":f||(S+="    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n"),S+=p?o(211):C?o(160):w?o(209)+(g?o(165):""):o(154),S+=o(186),x[o(201)](S),new r({defines:E,sources:x})}):l[e(192)]=function(t,i,n,a,s){const o=e,l=r[o(174)](t),m=!a&&h(l)||a&&s,c=r[o(180)](t),d=h(c),u=i._usesDepthTexture,f=i._polygonOffsetSupported,p=i[o(194)],C=i._isSpotLight,w=i[o(181)]>1,g=i.debugCascadeColors,_=i[o(177)],v=p?i[o(205)]:a?i[o(151)]:i[o(215)],E=t[o(169)][o(210)](0),x=t[o(158)][o(210)](0),y=x.length;for(let e=0;e<y;++e)x[e]=r[o(188)](x[e],o(185));p?E[o(201)](o(202)):u&&E.push(o(206)),_&&!p&&E[o(201)]("USE_SOFT_SHADOWS"),w&&n&&a&&(m?E[o(201)]("ENABLE_VERTEX_LIGHTING"):E[o(201)]("ENABLE_DAYNIGHT_SHADING")),n&&v[o(208)]&&m&&(E[o(201)](o(183)),v.normalShadingSmooth>0&&E.push(o(164)));let D,S="";return S+=p?"uniform samplerCube shadowMap_textureCube; \n":o(172),D=d?o(152)+c+o(197):o(191),S+="uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n"+D+o(184)+(m?o(175)+l+o(189):o(190))+o(159)+(v[o(200)]&&m?o(170):"")+o(178),S+=o(213),S+=o(204),a?S+=o(182):f||(S+=o(156)),S+=p?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":C?o(160):w?"    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n"+(g?"    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n":""):o(154),S+=o(153),x[o(201)](S),new r({defines:E,sources:x})}}():l[t(192)]=m}const u=f;function f(e,t){const i=C();return(f=function(e,t){return i[e-=405]})(e,t)}!function(e,t){const i=f,n=e();for(;;)try{if(945135===parseInt(i(408))/1*(parseInt(i(502))/2)+parseInt(i(443))/3*(-parseInt(i(415))/4)+parseInt(i(546))/5*(parseInt(i(534))/6)+-parseInt(i(423))/7+parseInt(i(526))/8*(-parseInt(i(477))/9)+parseInt(i(414))/10*(parseInt(i(539))/11)+-parseInt(i(521))/12*(-parseInt(i(484))/13))break;n.push(n.shift())}catch(e){n.push(n.shift())}}(C);const p=u(538);function C(){const e=["wgs84ToWindowCoordinates","fromCssColorString","3goDDzn","modelMatrix","fromPoints","RenderbufferFormat","vtxfTexture","bufferView","addMinutes","destory","createReceiveDerivedCommand","shadowMap","BoundingSphere","BlendingState","readPixels","Cartesian3","legends","viewer","fromCartesian","_context","Matrix3","RZType","withAlpha","_index","terrainProvider","Material","setSunAndMoonDirections","then","normalize","computeSunPositionInEarthInertialFrame","_count","fromDate","_legendimage","Camera","map","fromTranslation","2313SYxrpD","TextureMagnificationFilter","_starttime","Transforms","setSamplePoints","FRAMEBUFFER","parseInt","6101927ByDavN","computeTemeToPseudoFixedMatrix","center","toCartesian","PolygonGeometry","_samplePoints","_extraCmds","Cartographic","PolygonHierarchy","src","height","EllipsoidSurfaceAppearance","GREEN","defined","visibleAreaColor","init","sampleTerrainMostDetailed","ALPHA_BLEND","17346qrxdWZ","createShadowMaps","GeometryInstance","Texture","uniformMap","blending","time","SceneTransforms","equals","receiveCommand","show","color","commandList","positions","push","invisibleAreaColor","Resource","_fb","ShadowMap","36Ineesd","primitives","computeIcrfToFixedMatrix","multiply","RenderState","13672LkUJWw","alpha","ColorGeometryInstanceAttribute","fromCache","polygonCmds","samplePoints","setHours","Pass","2244630TDzqsM","_clearColorCommand","Matrix4","OPAQUE","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","21945ZYJVXu","pickPosition","_isSampleDone","now","_option","canvas","#ffffff","5LsZTyJ","_shadowmap","clear","centerWC","Simon1994PlanetaryPositions","polygonprimitrive","scaleHeight","TextureMinificationFilter","image_1","Color","NEAREST","inverse","add","receiveShadows","57XUgxAD","multiplyByVector","framebuffer","_colorCommands","width","Renderbuffer","6130AEximn","5804192Ydbrmi","DefaultImageId","context","_isready","secondsOfDay","position","forEach","clone","4648994nwFCJU","Framebuffer","camera","_cameraPosition","direction","remove","resolve","dirty","internalFormat","readyPromise","JulianDate","scene","checkFramebufferStatus","_materialCache","setHeight","lightCamera","clampground","createFramebuffer"];return(C=function(){return e})()}Cesium[u(466)][u(462)]=u(462),Cesium[u(466)][u(436)].addMaterial(Cesium[u(466)][u(462)],{fabric:{type:Cesium[u(466)][u(462)],uniforms:{image:Cesium.Material.DefaultImageId,legend:Cesium[u(466)][u(416)]},source:p},translucent:function(e){return!0}});class w{constructor(e,t){const i=u;let n=this;if(this[i(543)]=t,this._samplePoints=t[i(531)],this._sampleCallback=t.sampleCallback,this[i(541)]=!1,t[i(439)]){t[i(515)]=t[i(515)][i(475)]((e=>Cesium.Cartographic.fromCartesian(e)));const a=Cesium[i(500)](e[i(465)],t[i(515)]);Promise[i(429)](a)[i(468)]((function(a){const s=i;let o=-9999;a=a[s(475)]((e=>(e[s(494)]>o&&(o=e[s(494)]),Cesium[s(491)].toCartesian(e)))),t[s(494)]=o,t[s(515)]=a,n.init(e,t)}))}else n[i(499)](e,t)}[u(437)](e){const t=u;this[t(551)]&&this[t(552)](e)}[u(540)](e){const t=u;var i=viewer[t(434)].context;const n=i._gl;if(n[t(435)](n[t(482)])===n.FRAMEBUFFER_COMPLETE){let n=Cesium[t(509)][t(441)](viewer.scene,e);return 10*i[t(455)]({x:Number[t(483)](n.x),y:Number[t(483)](n.y),width:1,height:1,framebuffer:this[t(519)]})[0]/255}return-1}refresh(){this[u(464)]=0}[u(552)](e){const t=u;let i=Cesium[t(480)].eastNorthUpToFixedFrame(this[t(549)]),n=Cesium[t(536)][t(405)](i,new(Cesium[t(536)])),a=e-this.center[t(494)],s=Cesium.Matrix4[t(476)](new Cesium.Cartesian3(0,0,a)),o=Cesium[t(536)][t(524)](s,n,new(Cesium[t(536)]));this.polygonprimitrive[t(444)]=Cesium[t(536)][t(524)](i,o,new(Cesium[t(536)]))}[u(499)](e,t){const i=u;let n=this;this[i(512)]=!0,this[i(419)]=0,this._legendimage="";var s=e.scene[i(417)];if(t[i(457)]&&(this[i(473)]=function(e,t){var i=a;const n=16*e[i(183)];var s=document[i(178)](i(180));s[i(188)]=n,s[i(201)]=16;var o=s[i(186)]("2d");o.beginPath();for(let t=0;t<e[i(183)];t++){let n=e[t].color,a=16*t,s=0;o.fillStyle=n,o[i(190)](a,s,16,16)}var r=new Image;return r[i(208)]=s[i(228)](),r}(t[i(457)]),Cesium[i(518)].createIfNeeded(this[i(473)][i(493)]).fetchImage().then((function(t){const a=i;var s,o=e[a(434)][a(417)];s=Cesium[a(497)](t[a(431)])?new Cesium.Texture({context:o,pixelFormat:t[a(431)],width:t[a(412)],height:t[a(494)],source:{arrayBufferView:t[a(448)]}}):new Cesium.Texture({context:o,source:t}),n.vtxfTexture=s}))),this[i(426)]=new(Cesium[i(456)]),t[i(515)]){var o=new(Cesium[i(424)])({context:s,colorTextures:[new(Cesium[i(505)])({context:s,width:s[i(544)][i(412)],height:s[i(544)][i(494)]})],depthStencilRenderbuffer:new Cesium.Renderbuffer({context:s,width:s[i(544)].width,height:s[i(544)].height,format:Cesium.RenderbufferFormat.DEPTH_STENCIL})});this._fb=o;var r=new(Cesium[i(492)])(t[i(515)]);let n=new(Cesium[i(488)])({polygonHierarchy:r,height:t[i(494)],vertexFormat:Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT});this.center=Cesium[i(453)][i(445)](t[i(515)])[i(486)],this[i(486)]=Cesium[i(491)][i(459)](this[i(486)]),this[i(486)].height=t[i(494)],this[i(549)]=Cesium[i(491)][i(487)](this[i(486)]);var h=new(Cesium[i(504)])({geometry:n,attributes:{color:Cesium[i(528)].fromColor(Cesium[i(555)][i(442)](i(545))[i(463)](0))}});let a=new Cesium.Primitive({geometryInstances:h,asynchronous:!1,appearance:new(Cesium[i(495)])({material:new(Cesium[i(466)])({fabric:{type:i(462),uniforms:{legend:this._legendimage}},minificationFilter:Cesium[i(553)].NEAREST,magnificationFilter:Cesium[i(478)][i(556)]})})});this.polygonprimitrive=a;let l=new Date(Date[i(542)]());l[i(532)](17,0,0),this[i(464)]=0,this[i(471)]=60,l=Cesium[i(433)][i(472)](l),this[i(479)]=l;let m=this[i(467)]({time:l}),c=new(Cesium[i(520)])({context:e.scene[i(417)],lightCamera:m,enabled:!0});this[i(547)]=c,this[i(535)]=new Cesium.ClearCommand({color:new Cesium.Color(0,0,0,0),pass:Cesium[i(533)][i(537)],owner:this,framebuffer:this[i(519)]}),this._isready=!1,Cesium[i(525)][i(529)]({blending:Cesium[i(454)][i(501)]});let u=this;this[i(551)][i(432)][i(468)]((t=>{const n=i;d(!0);let a=t[n(411)],s=a[n(475)]((t=>{const i=n;t[i(407)]=!0;let a=Cesium[i(520)][i(451)]([u[i(547)]],t,!0,e[i(434)][i(460)],{});a[i(511)][i(407)]=!1;const s=Cesium[i(422)](Cesium.BlendingState.ADDITIVE_BLEND,!0),o=new(Cesium[i(555)])(0,0,0,0);return s[i(513)]=o,a[i(511)].renderState[i(507)]=s,a.receiveCommand.pass=7,a[i(511)][i(410)]=u[i(519)],a[i(511)]}));u._extraCmds=s,d(!1),u.polygonCmds=a[n(475)]((e=>{const t=n;let i=Cesium[t(422)](e);return i[t(506)][t(554)]=function(){return o._colorTextures[0]},i[t(506)].legend_0=function(){return u[t(447)]},i})),u[n(551)][n(512)]=!1,u[n(418)]=!0})),e[i(434)][i(522)][i(406)](this[i(551)])}}[u(440)](){const e=u;var t=viewer[e(434)][e(417)];return new(Cesium[e(424)])({context:t,colorTextures:[new(Cesium[e(505)])({context:t,width:t.canvas[e(412)],height:t[e(544)].height})],depthStencilRenderbuffer:new(Cesium[e(413)])({context:t,width:t[e(544)].width,height:t[e(544)].height,format:Cesium[e(446)].DEPTH_STENCIL})})}[u(481)](e){this[u(489)]=e,this._isSampleDone=!1}update(e){const t=u;if(!this[t(512)])return;let i=this;if(this[t(418)]&&Cesium[t(497)](this._extraCmds))if(e[t(425)][t(420)][t(510)](this[t(426)])||(this._index=0,this._isSampleDone=!1,this[t(426)]=Cesium.clone(e[t(425)][t(420)])),0==this[t(464)]&&e.commandList[t(516)](this[t(535)]),this._index<this._count){let n=Cesium[t(433)][t(449)](this[t(479)],10*this[t(464)],new Cesium.JulianDate),a=this.setSunAndMoonDirections({time:n});this[t(547)]._lightCamera[t(420)]=a[t(420)],this._shadowmap._lightCamera.direction=a[t(427)],this[t(547)][t(430)]=!0,e.shadowMaps[t(516)](this[t(547)]),this[t(490)][t(421)]((e=>{const n=t;e[n(444)]=i[n(551)].modelMatrix})),e[t(514)][t(516)](...this[t(490)]),this._index++}else{if(this[t(489)]&&this._sampleCallback&&!this[t(541)]){let e=this[t(489)].map((e=>Cesium.Cartographic[t(459)](e)));var n=function(e,t,i){var n=a,s=viewer[n(185)].context;const o=s[n(181)];if(o.checkFramebufferStatus(o[n(200)])===o[n(226)])return t[n(182)]((t=>{var a=n;null!=i&&(t[a(201)]=i),t=Cesium.Cartographic.toCartesian(t);let o=Cesium[a(199)][a(218)](viewer.scene,t);return s[a(195)]({x:Number.parseInt(o.x),y:Number[a(187)](o.y),width:1,height:1,framebuffer:e})}))}(this._fb,e,this._option[t(494)]);this._sampleCallback(n),this[t(541)]=!0}this[t(530)].forEach((e=>{const n=t;e[n(444)]=i[n(551)][n(444)]})),e[t(514)][t(516)](...this[t(530)])}}[u(467)](e){const t=u;let i=new(Cesium[t(456)]),n=new(Cesium[t(461)]);Cesium[t(497)](Cesium[t(480)][t(523)](e[t(508)],n))||(n=Cesium[t(480)][t(485)](e[t(508)],n));let a=Cesium[t(550)][t(470)](e[t(508)],i);Cesium[t(461)][t(409)](n,a,a);let s=new Cesium.Cartesian3;Cesium[t(456)][t(469)](a,s);let o=new(Cesium[t(474)])(viewer[t(434)]);return o.position=a,o[t(427)]=s,o}[u(503)](){}createShadowMap(e,t){const i=u;this[i(458)]=e,this[i(452)]=e[i(434)][i(452)],this.lightCamera=this[i(452)][i(438)],this.visibleAreaColor=t[i(498)]||Cesium[i(555)][i(496)],this[i(517)]=t.invisibleAreaColor||Cesium[i(555)].RED,this[i(527)]=.5}[u(548)](){}[u(450)](){const e=u;this.polygonprimitrive&&viewer[e(434)].primitives[e(428)](this[e(551)])}}e.RZPrimitiveX=w}));
