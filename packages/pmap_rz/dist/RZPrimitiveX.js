!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(){const e=["tollerance","map","#ff0000","GeometryInstance","Color","RED","21138gQhLat","72kqzmMl","Polygon","5760gBraeL","110RhxvIl","PerInstanceColorAppearance","fromDegreesArrayHeights","2868MokQpX","add","21486bkcGMk","13784310dEUkLj","ClassificationPrimitive","maxdistance","1835bOCpMj","maxcount","14301CHjJaJ","5644YeKHzY","fromCssColorString","coordinates","VERTEX_FORMAT","PolygonGeometry","ClassificationType","withAlpha","666886WdKgkT","163407YyLRwl","fromColor","445zTQbwC","fromDegreesArray","type","Primitive","EllipsoidSurfaceAppearance","entities","MultiPolygon","Cartesian3","CESIUM_3D_TILE","flat","PolygonHierarchy","features"];return(t=function(){return e})()}function n(e,i){const a=t();return(n=function(e,t){return a[e-=199]})(e,i)}function i(){var e=["#00baf6","SceneTransforms","6877750cTlnco","createElement","FRAMEBUFFER","scene","FRAMEBUFFER_COMPLETE","#f9a100","length","none","Cartographic","#0000f6","#a7f637","1RisMLS","#06f4f7","body","940wIOvUI","checkFramebufferStatus","download","4-5小时","color","1-2小时","6-7小时","2819299MrLPzC","1880VTgHZG","小于1小时","7小时以上","5-6小时","href","1596282bIfAfQ","16awDbFh","30qYPGYI","21159TecAZR","data","set","src","context","_gl","display","321710cXGakD","appendChild","createImageData","height","3-4小时","click","toDataURL","beginPath","putImageData","readPixels","5268esbxkx","45gzANVt","wgs84ToWindowCoordinates","parseInt","setAttribute","fillStyle","25233LvMwtK","#f50205","toCartesian","width","canvas"];return(i=function(){return e})()}function a(e,t){var n=i();return(a=function(e,t){return n[e-=168]})(e,t)}!function(e,t){const i=n,a=e();for(;;)try{if(826181===parseInt(i(234))/1*(parseInt(i(224))/2)+-parseInt(i(232))/3*(-parseInt(i(209))/4)+-parseInt(i(221))/5*(-parseInt(i(217))/6)+parseInt(i(223))/7*(-parseInt(i(211))/8)+-parseInt(i(218))/9+parseInt(i(212))/10*(parseInt(i(231))/11)+-parseInt(i(215))/12*(parseInt(i(208))/13))break;a.push(a.shift())}catch(e){a.push(a.shift())}}(t),function(e,t){for(var n=a,i=e();;)try{if(676060===-parseInt(n(191))/1*(-parseInt(n(207))/2)+-parseInt(n(168))/3*(-parseInt(n(202))/4)+parseInt(n(217))/5*(parseInt(n(209))/6)+-parseInt(n(201))/7*(-parseInt(n(208))/8)+parseInt(n(210))/9*(parseInt(n(194))/10)+-parseInt(n(180))/11+parseInt(n(227))/12*(-parseInt(n(173))/13))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(i);const s=c;function o(){const e=["); \n","7clgVIE","sources","6eGJQDI","findPositionVarying","VERSION","4eOWYve","GENERATE_POSITION_AND_NORMAL","GENERATE_POSITION","createShadowReceiveVertexShader","_numberOfCascades","USE_CUBE_MAP_SHADOW","1549539mRkJSz","_polygonOffsetSupported","   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.016667;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","defines","1825465NxTTqp","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","split","2286282wQJntM","    return normalize(","USE_SOFT_SHADOWS","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","382254pscJtD","slice","_primitiveBias","10DhnhLq","softShadows","USE_NORMAL_SHADING","ShadowMapShader","normalShading","    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n","} \n","ShaderSource","uniform sampler2D shadowMap_texture; \n","_usesDepthTexture","debugCascadeColors","parseInt","USE_NORMAL_SHADING_SMOOTH","_terrainBias","259793oqejFh","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","length","} \nvec3 getNormalEC() \n{ \n","normalShadingSmooth","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","5553680Ezpavi","defined","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","ENABLE_VERTEX_LIGHTING","findNormalVarying","_pointBias","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","3639400YKSYuv","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","push","_isPointLight","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n",", 1.0); \n","czm_shadow_receive_main","uniform samplerCube shadowMap_textureCube; \n","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","replaceMain","createShadowReceiveFragmentShader","normalOffset"];return(o=function(){return e})()}!function(e,t){const n=c,i=e();for(;;)try{if(256211===parseInt(n(281))/1+-parseInt(n(264))/2*(-parseInt(n(311))/3)+-parseInt(n(314))/4*(-parseInt(n(257))/5)+-parseInt(n(260))/6*(-parseInt(n(309))/7)+-parseInt(n(294))/8+parseInt(n(320))/9*(-parseInt(n(267))/10)+-parseInt(n(287))/11)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(o);const r=Cesium[s(274)],h=Cesium[s(288)],l=Cesium[s(270)];let m;function c(e,t){const n=o();return(c=function(e,t){return n[e-=253]})(e,t)}function d(e){const t=s;e?function(){const e=s,t=Number[e(278)](Cesium[e(313)][e(259)](".")[1])>=101;m=l[e(306)],t?(l[e(317)]=function(t,n,i){const a=e,s=t[a(256)].slice(0),o=t[a(310)][a(265)](0);return s[a(296)]("SHADOW_MAP"),n&&(i?s.push(a(315)):s[a(296)](a(316))),new r({defines:s,sources:o})},l[e(306)]=function(t,n,i,a,s){const o=e,l=r.findNormalVarying(t),m=!a&&h(l)||a&&s,c=r[o(312)](t),d=h(c),p=n._usesDepthTexture,u=n[o(253)],f=n[o(297)],C=n._isSpotLight,w=n._numberOfCascades>1,g=n.debugCascadeColors,_=n[o(268)],v=f?n[o(292)]:a?n[o(280)]:n[o(266)],E=t.defines.slice(0),x=t[o(310)][o(265)](0),S=x[o(283)];for(let e=0;e<S;++e)x[e]=r.replaceMain(x[e],o(301));f?E[o(296)](o(319)):p&&E.push("USE_SHADOW_DEPTH_TEXTURE"),_&&!f&&E[o(296)](o(262)),w&&i&&a&&(m?E[o(296)](o(290)):E[o(296)]("ENABLE_DAYNIGHT_SHADING")),i&&v.normalShading&&m&&(E[o(296)](o(269)),v[o(285)]>0&&E[o(296)](o(279)));let y,P="";return P+=o(f?302:275),y=d?"    return vec4("+c+o(300):o(258),P+=o(295)+y+"} \nvec3 getNormalEC() \n{ \n"+(m?o(261)+l+o(308):"    return vec3(1.0); \n")+o(289)+(v.normalOffset&&m?o(286):"")+o(273),P+=o(255),P+="    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n",a?P+=o(299):u||(P+=o(282)),P+=f?o(303):C?o(293):w?o(263)+(g?"    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n":""):o(298),P+=o(254),x[o(296)](P),new r({defines:E,sources:x})}):l[e(306)]=function(t,n,i,a,s){const o=e,l=r[o(291)](t),m=!a&&h(l)||a&&s,c=r[o(312)](t),d=h(c),p=n[o(276)],u=n[o(253)],f=n[o(297)],C=n._isSpotLight,w=n[o(318)]>1,g=n[o(277)],_=n[o(268)],v=f?n._pointBias:a?n[o(280)]:n[o(266)],E=t[o(256)].slice(0),x=t[o(310)].slice(0),S=x.length;for(let e=0;e<S;++e)x[e]=r[o(305)](x[e],o(301));f?E[o(296)](o(319)):p&&E[o(296)]("USE_SHADOW_DEPTH_TEXTURE"),_&&!f&&E[o(296)](o(262)),w&&i&&a&&(m?E[o(296)](o(290)):E[o(296)]("ENABLE_DAYNIGHT_SHADING")),i&&v[o(271)]&&m&&(E.push(o(269)),v[o(285)]>0&&E.push(o(279)));let y,P="";return P+=o(f?302:275),y=d?"    return vec4("+c+", 1.0); \n":o(258),P+="uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n"+y+o(284)+(m?o(261)+l+"); \n":"    return vec3(1.0); \n")+o(289)+(v[o(307)]&&m?o(286):"")+o(273),P+=o(255),P+=o(304),a?P+=o(299):u||(P+=o(282)),P+=f?o(303):C?"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n":w?o(263)+(g?o(272):""):o(298),P+="   \n      float rd=0.016667;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ",x[o(296)](P),new r({defines:E,sources:x})}}():l[t(306)]=m}function p(e,t){const n=f();return(p=function(e,t){return n[e-=426]})(e,t)}const u=p;function f(){const e=["direction","GREEN","fromDate","scene","clear","time","push","lightCamera","camera","BoundingSphere","shadowMap","391832FMJZUR","Framebuffer","Cartesian3","multiply","destory","center","alpha","context","receiveShadows","setSunAndMoonDirections","legends","setSamplePoints","_lightCamera","createReceiveDerivedCommand","resolve","7802193aaSlCo","RZType","toCartesian","Matrix3","modelMatrix","_option","_isready","_samplePoints","color","Color","canvas","10040JPnJKr","_extraCmds","Camera","ADDITIVE_BLEND","OPAQUE","RenderbufferFormat","_context","EllipsoidSurfaceAppearance","setHeight","image_1","viewer","width","scaleHeight","BlendingState","polygonCmds","uniformMap","terrainProvider","receiveCommand","fromCartesian","vtxfTexture","57UVoGns","ClearCommand","Material","init","fromColor","_clearColorCommand","_shadowmap","_fb","sampleCallback","forEach","clampground","_cameraPosition","renderState","_colorCommands","_isSampleDone","addMinutes","fromPoints","inverse","12660360XeuKkH","RED","#ffffff","NEAREST","PolygonHierarchy","blending","commandList","map","Primitive","invisibleAreaColor","17372RBuLGW","Pass","ALPHA_BLEND","polygonprimitrive","Cartographic","_legendimage","show","computeSunPositionInEarthInertialFrame","then","primitives","height","VERTEX_FORMAT","Transforms","refresh","329815QkptJR","223MRuKjn","multiplyByVector","JulianDate","Texture","visibleAreaColor","now","computeTemeToPseudoFixedMatrix","fromCache","Matrix4","_count","framebuffer","PolygonGeometry","sampleTerrainMostDetailed","fromCssColorString","defined","5045586Somxll","clone","ShadowMap","6651VJzzfZ","positions","legend_0","samplePoints","DEPTH_STENCIL","Renderbuffer","Simon1994PlanetaryPositions","normalize","remove","DefaultImageId","_starttime","_sampleCallback","pass","secondsOfDay","position","_index"];return(f=function(){return e})()}!function(e,t){const n=p,i=e();for(;;)try{if(972518===parseInt(n(499))/1*(-parseInt(n(484))/2)+-parseInt(n(456))/3*(-parseInt(n(544))/4)+-parseInt(n(498))/5+-parseInt(n(514))/6+parseInt(n(559))/7+parseInt(n(474))/8+parseInt(n(517))/9*(-parseInt(n(436))/10))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(f);Cesium[u(458)].RZType=u(426),Cesium[u(458)]._materialCache.addMaterial(Cesium[u(458)][u(426)],{fabric:{type:Cesium.Material.RZType,uniforms:{image:Cesium.Material[u(526)],legend:Cesium[u(458)].DefaultImageId},source:"\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n"},translucent:function(e){return!0}});class C{constructor(e,t){const n=u;let i=this;if(this[n(430)]=t,this._samplePoints=t[n(520)],this[n(528)]=t[n(464)],this[n(470)]=!1,t[n(466)]){t[n(518)]=t[n(518)][n(481)]((e=>Cesium[n(488)].fromCartesian(e)));const a=Cesium[n(511)](e[n(452)],t[n(518)]);Promise[n(558)](a)[n(492)]((function(a){const s=n;let o=-9999;a=a[s(481)]((e=>(e[s(494)]>o&&(o=e[s(494)]),Cesium[s(488)][s(427)](e)))),t[s(494)]=o,t[s(518)]=a,i.init(e,t)}))}else i[n(459)](e,t)}[u(444)](e){this[u(487)]&&this.scaleHeight(e)}[u(497)](){this._index=0}[u(448)](e){const t=u;let n=Cesium[t(496)].eastNorthUpToFixedFrame(this.centerWC),i=Cesium.Matrix4[t(473)](n,new(Cesium[t(507)])),a=e-this[t(549)][t(494)],s=Cesium[t(507)].fromTranslation(new Cesium.Cartesian3(0,0,a)),o=Cesium[t(507)][t(547)](s,i,new Cesium.Matrix4);this[t(487)][t(429)]=Cesium[t(507)][t(547)](n,o,new(Cesium[t(507)]))}[u(459)](e,t){const n=u;this.show=!0,this[n(530)]=0,this[n(489)]="";var i=e.scene.context;if(t[n(554)]&&(this[n(489)]=function(e,t){var n=a;const i=16*e[n(186)];var s=document[n(181)](n(177));s[n(176)]=i,s[n(220)]=16;var o=s.getContext("2d");o[n(224)]();for(let t=0;t<e.length;t++){let i=e[t][n(198)],a=16*t,s=0;o[n(172)]=i,o.fillRect(a,s,16,16)}var r=new Image;return r[n(213)]=s[n(223)](),r}(t[n(554)]),this[n(455)]=new(Cesium[n(502)])({context:i,source:this._legendimage})),this._cameraPosition=new(Cesium[n(546)]),t[n(518)]){var s=new Cesium.Framebuffer({context:i,colorTextures:[new(Cesium[n(502)])({context:i,width:i[n(435)][n(447)],height:i[n(435)].height})],depthStencilRenderbuffer:new(Cesium[n(522)])({context:i,width:i.canvas.width,height:i[n(435)][n(494)],format:Cesium[n(441)][n(521)]})});this[n(463)]=s;var o=new(Cesium[n(478)])(t[n(518)]);let a=new(Cesium[n(510)])({polygonHierarchy:o,height:t[n(494)],vertexFormat:Cesium[n(443)][n(495)]});this[n(549)]=Cesium[n(542)][n(472)](t[n(518)]).center,this[n(549)]=Cesium.Cartographic[n(454)](this[n(549)]),this[n(549)][n(494)]=t[n(494)],this.centerWC=Cesium[n(488)].toCartesian(this[n(549)]);var r=new Cesium.GeometryInstance({geometry:a,attributes:{color:Cesium.ColorGeometryInstanceAttribute[n(460)](Cesium[n(434)][n(512)](n(476)).withAlpha(0))}});let h=new(Cesium[n(482)])({geometryInstances:r,asynchronous:!1,appearance:new Cesium.EllipsoidSurfaceAppearance({material:new(Cesium[n(458)])({fabric:{type:n(426),uniforms:{legend:this[n(489)]}},minificationFilter:Cesium.TextureMinificationFilter[n(477)],magnificationFilter:Cesium.TextureMagnificationFilter.NEAREST})})});this[n(487)]=h;let l=new Date(Date[n(504)]());l.setHours(17,0,0),this[n(532)]=0,this[n(508)]=60,l=Cesium.JulianDate[n(535)](l),this[n(527)]=l;let m=this[n(553)]({time:l}),c=new Cesium.ShadowMap({context:e[n(536)][n(551)],lightCamera:m,enabled:!0});this[n(462)]=c,this[n(461)]=new(Cesium[n(457)])({color:new(Cesium[n(434)])(0,0,0,0),pass:Cesium[n(485)][n(440)],owner:this,framebuffer:this._fb}),this[n(431)]=!1,Cesium.RenderState[n(506)]({blending:Cesium[n(449)][n(486)]});let p=this;this[n(487)].readyPromise[n(492)]((t=>{const i=n;d(!0);let a=t[i(469)],o=a.map((t=>{const n=i;t[n(552)]=!0;let a=Cesium[n(516)][n(557)]([p._shadowmap],t,!0,e[n(536)][n(442)],{});a[n(453)].receiveShadows=!1;const s=Cesium[n(515)](Cesium[n(449)][n(439)],!0),o=new(Cesium[n(434)])(0,0,0,0);return s[n(433)]=o,a[n(453)][n(468)][n(479)]=s,a[n(453)][n(529)]=7,a.receiveCommand[n(509)]=p[n(463)],a[n(453)]}));p[i(437)]=o,d(!1),p[i(450)]=a[i(481)]((e=>{const t=i;let n=Cesium.clone(e);return n[t(451)][t(445)]=function(){return s._colorTextures[0]},n[t(451)][t(519)]=function(){return p[t(455)]},n})),p[i(487)][i(490)]=!1,p[i(431)]=!0})),e[n(536)][n(493)].add(this[n(487)])}}createFramebuffer(){const e=u;var t=viewer[e(536)][e(551)];return new(Cesium[e(545)])({context:t,colorTextures:[new(Cesium[e(502)])({context:t,width:t[e(435)][e(447)],height:t[e(435)][e(494)]})],depthStencilRenderbuffer:new(Cesium[e(522)])({context:t,width:t[e(435)][e(447)],height:t[e(435)].height,format:Cesium.RenderbufferFormat[e(521)]})})}[u(555)](e){const t=u;this[t(432)]=e,this[t(470)]=!1}update(e){const t=u;if(!this[t(490)])return;let n=this;if(this[t(431)]&&Cesium.defined(this[t(437)]))if(e[t(541)][t(531)].equals(this[t(467)])||(this[t(532)]=0,this._isSampleDone=!1,this._cameraPosition=Cesium[t(515)](e[t(541)].position)),0==this[t(532)]&&e[t(480)][t(539)](this._clearColorCommand),this._index<this[t(508)]){let i=Cesium[t(501)][t(471)](this._starttime,10*this[t(532)],new(Cesium[t(501)])),a=this[t(553)]({time:i});this._shadowmap[t(556)][t(531)]=a.position,this[t(462)][t(556)][t(533)]=a[t(533)],this[t(462)].dirty=!0,e.shadowMaps[t(539)](this._shadowmap),this[t(437)][t(465)]((e=>{const i=t;e.modelMatrix=n[i(487)][i(429)]})),e[t(480)][t(539)](...this[t(437)]),this[t(532)]++}else{if(this[t(432)]&&this._sampleCallback&&!this[t(470)]){let e=this._samplePoints[t(481)]((e=>Cesium[t(488)][t(454)](e)));var i=function(e,t,n){var i=a,s=viewer.scene.context;const o=s[i(215)];if(o[i(195)](o[i(182)])===o.FRAMEBUFFER_COMPLETE)return t.map((t=>{var a=i;null!=n&&(t[a(220)]=n),t=Cesium[a(188)][a(175)](t);let o=Cesium[a(179)][a(169)](viewer[a(183)],t);return s[a(226)]({x:Number.parseInt(o.x),y:Number[a(170)](o.y),width:1,height:1,framebuffer:e})}))}(this[t(463)],e,this[t(430)][t(494)]);this[t(528)](i),this[t(470)]=!0}this.polygonCmds.forEach((e=>{const i=t;e[i(429)]=n[i(487)][i(429)]})),e[t(480)][t(539)](...this[t(450)])}}[u(553)](e){const t=u;let n=new(Cesium[t(546)]),i=new(Cesium[t(428)]);Cesium[t(513)](Cesium[t(496)].computeIcrfToFixedMatrix(e[t(538)],i))||(i=Cesium[t(496)][t(505)](e[t(538)],i));let a=Cesium[t(523)][t(491)](e[t(538)],n);Cesium.Matrix3[t(500)](i,a,a);let s=new(Cesium[t(546)]);Cesium[t(546)][t(524)](a,s);let o=new(Cesium[t(438)])(viewer.scene);return o.position=a,o[t(533)]=s,o}createShadowMaps(){}createShadowMap(e,t){const n=u;this[n(446)]=e,this.shadowMap=e[n(536)][n(543)],this[n(540)]=this[n(543)][n(540)],this[n(503)]=t.visibleAreaColor||Cesium.Color[n(534)],this[n(483)]=t.invisibleAreaColor||Cesium[n(434)][n(475)],this[n(550)]=.5}[u(537)](){}[u(548)](){const e=u;this.polygonprimitrive&&viewer[e(536)].primitives[e(525)](this[e(487)])}}e.RZPrimitiveX=C}));
