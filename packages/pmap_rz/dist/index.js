!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(){var e=["#0000f6","879306DguQfL","FRAMEBUFFER_COMPLETE","none","22QfhBQd","getContext","261862bncCji","26761XxBAHW","appendChild","color","checkFramebufferStatus","2-3小时","7995180upZuqw","fillRect","12348sWvaMi","style","3-4小时","5-6小时","2qbvWUp","840ZssGBm","data","parseInt","7小时以上","小于1小时","60shnCgz","download","#f9a100","beginPath","display","2943080OevWFS","4-5小时","FRAMEBUFFER","createImageData","Cartographic","setAttribute","height","createElement","#f50205","href","492705XJCrFQ","canvas","click","944GZsDqo","toDataURL","_gl","src","toCartesian","context","fillStyle","width","length","body","#06f4f7"];return(t=function(){return e})()}function n(e,t){var n=i;const a=16*e[n(367)];var r=document[n(353)](n(357));r.width=a,r[n(405)]=16;var s=r[n(375)]("2d");s[n(397)]();for(let t=0;t<e.length;t++){let i=e[t][n(379)],a=16*t,r=0;s[n(365)]=i,s[n(383)](a,r,16,16)}var o=new Image;return o[n(362)]=r[n(360)](),o}function i(e,n){var a=t();return(i=function(e,t){return a[e-=353]})(e,n)}!function(e,t){for(var n=i,a=e();;)try{if(388008===parseInt(n(376))/1*(-parseInt(n(388))/2)+-parseInt(n(371))/3+parseInt(n(399))/4+-parseInt(n(389))/5*(parseInt(n(384))/6)+parseInt(n(377))/7*(-parseInt(n(359))/8)+parseInt(n(356))/9*(-parseInt(n(394))/10)+parseInt(n(374))/11*(parseInt(n(382))/12))break;a.push(a.shift())}catch(e){a.push(a.shift())}}(t);const a=r;function r(e,t){const n=l();return(r=function(e,t){return n[e-=356]})(e,t)}!function(e,t){const n=r,i=e();for(;;)try{if(580836===parseInt(n(360))/1+-parseInt(n(517))/2*(parseInt(n(499))/3)+parseInt(n(483))/4+parseInt(n(457))/5*(-parseInt(n(377))/6)+-parseInt(n(477))/7+-parseInt(n(383))/8+parseInt(n(406))/9)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(l);const s=a(446);class o{constructor(e,t){const n=a;this[n(421)](e,t),this.init(t),this[n(456)]()}[a(497)](e,t){const n=a,i=e[n(373)];if(!defined(i))return!1;i[n(403)](t);const{clippingPlanesState:r,enabled:s}=i;if(s){const t=e[n(356)];t[n(366)]=i.texture,t[n(495)]=Matrix4[n(501)](Matrix4[n(389)](Matrix4[n(467)](i[n(434)],t[n(495)]),e[n(463)],t[n(495)]),t[n(495)])}return(e[n(372)]!==r||e[n(471)]!==s)&&(e[n(372)]=r,e._clippingPlanesEnabled=s,!0)}[a(421)](e,t){const n=a;this[n(431)]=e,this[n(474)]=t[n(474)]||Cesium[n(435)].GREEN,this[n(508)]=t[n(508)]||Cesium[n(435)][n(387)],this[n(472)]=.5}[a(408)](e){const t=a;let n=e,i=Cesium[t(429)][t(437)](e)[t(442)],r=Cesium[t(367)].eastNorthUpToFixedFrame(i),s=Cesium[t(493)].inverseTransformation(r,new(Cesium[t(493)])),o=n[t(443)],l=[];for(let e=0;e<o;++e){let t=(e+1)%o,i=this.createPlane(n[e],n[t],s);l.push(i)}return new(Cesium[t(514)])({planes:l,modelMatrix:r,unionClippingRegions:!0})}pickPosition(e){const t=a;var n=viewer[t(376)][t(507)];const i=n[t(370)];if(i.checkFramebufferStatus(i[t(482)])===i.FRAMEBUFFER_COMPLETE){let i=Cesium[t(440)][t(391)](viewer.scene,e);return n[t(371)]({x:Number[t(492)](i.x),y:Number[t(492)](i.y),width:1,height:1,framebuffer:this._fb})[0]*(this._count/6)/255}return-1}[a(424)](e,t,n){const i=a,r=this[i(466)](e,n),s=this.getOriginCoordinateSystemPoint(t,n),o=new(Cesium[i(511)])(0,0,-10),l=Cesium[i(511)][i(357)](s,r,new Cesium.Cartesian3);let c=Cesium[i(511)][i(460)](l,o,new(Cesium[i(511)]));c=Cesium.Cartesian3[i(359)](c,c);const m=Cesium[i(469)][i(464)](r,c);return new(Cesium[i(468)])(m.normal,m[i(439)])}[a(466)](e,t){return Cesium[a(493)].multiplyByPoint(t,e,new Cesium.Cartesian3(0,0,0))}[a(456)](){const e=a,t=this,n=this[e(459)][e(369)];let i=viewer[e(376)][e(364)][e(368)].colorFramebufferManager;const r=i[e(500)](0),s=i[e(426)](),o=new Cesium.ShaderSource({defines:[e(504)],sources:["\nvarying vec2 v_textureCoordinates;\nuniform sampler2D colorTexture;   //这里可以不用colortexture，仅适用depthtexture即可\nuniform sampler2D depthTexture;\nuniform sampler2D shadowMap_texture;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec3 shadowMap_lightDirectionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\n\nuniform float helsing_alpha;\nuniform vec4 helsing_visibleAreaColor;\nuniform vec4 helsing_invisibleAreaColor;\n\n\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = 0.3;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    float visibility = _czm_shadowDepthCompare(shadowMap, uv, depth);\n\n    return visibility;\n}\n\nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n  \n} \n\n\nvoid main(){\n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    //float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n    // if(currentDepth.r >= 1.0){\n    //     gl_FragColor = color;\n    //     return;\n    // }\n    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n    \n    vec4 positionEC = toEye(v_textureCoordinates,depth);\n    depth = -positionEC.z;\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    //shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n\n    //shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015);\n\n    float maxDepth = shadowMap_cascadeSplits[1].w;\n    // Stop early if the eye depth exceeds the last cascade \n          if (depth > maxDepth) \n          { \n              gl_FragColor.rgb=color.rgb;\n              gl_FragColor.a=color.a;\n              return; \n          }\n          // Get the cascade based on the eye-space depth \n          vec4 weights = czm_cascadeWeights(depth); \n          // Apply normal offset\n          float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n          applyNormalOffset(positionEC, normalEC, nDotL); \n          // Transform position into the cascade \n          vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n          // Get visibility \n          shadowParameters.texCoords = shadowPosition.xy; \n          shadowParameters.depth = shadowPosition.z; \n          shadowParameters.nDotL = nDotL; \n          float visibility =  czm_shadowVisibility(shadowMap_texture, shadowParameters); \n          // Fade out shadows that are far away \n          float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n          float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n          visibility = mix(visibility, 1.0, fade); \n          //color.rgb*=visibility;\n          gl_FragColor.rgb=color.rgb;\n          gl_FragColor.a=color.a;\n          //gl_FragColor *= czm_cascadeColor(weights);;\n          //gl_FragColor = mix(color, helsing_visibleAreaColor, helsing_alpha);\n\n          float rd=0.016667;\n           vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n           vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n\n     // 可视域模式\n     if (visibility > 0.90){\n      gl_FragColor = helsing_visibleAreaColor;\n  }\n  else{\n      gl_FragColor = helsing_unvisibleAreaColor;\n  }\n    \n}"]});var l=viewer[e(376)].context[e(404)](o,{uniformMap:{colorTexture:function(){return r},depthTexture:function(){return s},helsing_alpha:function(){return t[e(472)]},helsing_visibleAreaColor:function(){return t[e(474)]},helsing_invisibleAreaColor:function(){return t.invisibleAreaColor},shadowMap_cascadeSplits:function(){const n=e;return t[n(459)][n(362)]},shadowMap_cascadeMatrices:function(){const n=e;return t[n(459)][n(394)]},shadowMap_cascadeDistances:function(){const n=e;return t[n(459)][n(407)]},shadowMap_texture:function(){const n=e;return t[n(459)][n(491)]},shadowMap_matrix:function(){const n=e;return t.shadowMap[n(458)]},shadowMap_lightPositionEC:function(){const n=e;return t[n(459)][n(380)]},shadowMap_lightDirectionEC:function(){const n=e;return t[n(459)][n(448)]},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const i=e,a=new(Cesium[i(413)]);return a.x=1/t[i(459)][i(386)].x,a.y=1/t[i(459)][i(386)].y,Cesium[i(363)][i(420)](a.x,a.y,n[i(489)],n[i(419)],new(Cesium[i(363)]))},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){const i=e;return Cesium[i(363)][i(420)](n[i(390)],t[i(459)][i(441)],t[i(459)].maximumDistance,.3,new(Cesium[i(363)]))}}});l[e(396)]=Cesium[e(399)][e(505)],this._viewportQuadCommand=l;var c=Cesium[e(423)][e(432)]({});const m=Cesium[e(473)](Cesium[e(486)][e(388)],!0),h=new(Cesium[e(435)])(0,0,0,0);m[e(506)]=h,c[e(428)]=m,this[e(452)].renderState=c,this[e(452)][e(398)]=t[e(358)],this[e(395)]=!0}[a(512)](e){const t=a;let n=Cesium[t(400)][t(437)](e)[t(411)](e);return Cesium[t(487)][t(384)](n)===Cesium[t(450)][t(361)]&&(e=e[t(462)]()[t(433)]()),e}init(e){const t=a;let i=this,r=new Date(Date[t(502)]());r.setHours(8,0,0),this[t(451)]=0,this[t(481)]=60,this[t(381)]=10,r=Cesium[t(449)][t(479)](r),this[t(444)]=r;const o=viewer[t(376)][t(364)].globeDepth[t(503)][t(426)]();let l=new(Cesium[t(480)])({context:viewer[t(376)][t(507)],lightCamera:viewer[t(376)][t(430)],enabled:!0});this[t(459)]=l,this[t(459)][t(478)]=!0;var c=viewer[t(376)].context,m=new(Cesium[t(461)])({context:c,colorTextures:[new(Cesium[t(416)])({context:c,width:c[t(455)][t(379)],height:c.canvas[t(447)]})],depthStencilRenderbuffer:new(Cesium[t(410)])({context:c,width:c[t(455)][t(379)],height:c.canvas[t(447)],format:Cesium[t(513)][t(496)]})});this[t(358)]=m,e[t(382)]&&(this[t(494)]=n(e[t(382)]),Cesium.Resource.createIfNeeded(this[t(494)][t(425)]).fetchImage()[t(365)]((function(e){const n=t;var a,r=viewer[n(376)][n(507)];a=Cesium[n(385)](e[n(397)])?new(Cesium[n(416)])({context:r,pixelFormat:e.internalFormat,width:e[n(379)],height:e[n(447)],source:{arrayBufferView:e[n(417)]}}):new(Cesium[n(416)])({context:r,source:e}),i[n(427)]=a})));var h=Cesium[t(423)].fromCache({});const d=new Cesium.ShaderSource({sources:[s],defines:[t(504)]});if(e[t(510)]){e[t(510)]=this.clockwisePositions(e[t(510)]),this[t(490)]=this.createClippingPlane(e[t(510)]),d[t(374)][t(485)]("ENABLE_CLIPPING_PLANES");let n=t(509),i=t(405),a=Cesium[t(516)](this[t(490)],viewer[t(376)][t(507)])[t(438)](n,i),r=s.replace(t(402),a);d.sources[0]=r}const u=new(Cesium[t(493)]),p=new(Cesium[t(493)]);var f=c[t(404)](d,{uniformMap:{colorTexture:function(){return i[t(358)]._colorTextures[0]},depthTexture:function(){return o},legendTexture:function(){return i[t(427)]},u_clippingPlanes:function(){const e=t,n=i[e(490)];return Cesium[e(385)](n)&&Cesium[e(385)](n[e(418)])?n.texture:viewer.scene[e(507)][e(436)]},u_clippingPlanesMatrix:function(){const e=t,n=i[e(490)],a=Cesium[e(385)](n)?Cesium[e(493)][e(488)](viewer[e(376)][e(507)].uniformState[e(364)],n[e(434)],u):Cesium.Matrix4.IDENTITY;return Cesium[e(493)][e(445)](a,p)},u_clippingPlanesEdgeStyle:function(){const e=t,n=i[e(490)];if(Cesium.defined(n)){const t=n.edgeColor;return t[e(472)]=n[e(470)],t}return Cesium[e(435)][e(515)]}},renderState:h});f.pass=Cesium[t(399)].OVERLAY,this[t(498)]=f,this[t(453)]=new Cesium.ClearCommand({color:new(Cesium[t(435)])(0,0,0,0),pass:Cesium[t(399)][t(392)],owner:this,framebuffer:this[t(358)]}),this[t(484)]=new(Cesium[t(511)]),viewer[t(376)][t(465)].changed.addEventListener((()=>{i[t(451)]=0})),viewer[t(376)][t(465)][t(422)]=.01,this[t(395)]=!1}refresh(){this[a(451)]=0}[a(403)](e){const t=a;if(this[t(395)]){var n=this[t(490)];if(Cesium[t(385)](n)&&n.enabled&&n[t(403)](e),0==this._index&&e[t(475)][t(485)](this[t(453)]),this[t(451)]<this[t(481)]){let n=Cesium.JulianDate.addMinutes(this._starttime,10*this[t(451)],new(Cesium[t(449)]));viewer[t(415)][t(409)]=n;const i=viewer[t(376)][t(507)][t(476)];Cesium.Cartesian3[t(412)](i[t(401)],viewer.scene[t(430)][t(414)]),e[t(393)].push(this.shadowMap),this._viewportQuadCommand&&e[t(475)][t(485)](this[t(452)]),this[t(451)]++}else this[t(498)]&&e[t(475)][t(485)](this[t(498)])}}[a(375)](){return!1}[a(378)](e){const t=e;defined(t)&&(t.shaderProgram=t.shaderProgram&&t.shaderProgram.destroy())}destroy(){const e=a;return this[e(378)](this[e(498)]),this[e(378)](this[e(452)]),Cesium.destroyObject(this)}[a(454)](){}}function l(){const e=["_cascadeMatrices","_ready","pass","internalFormat","framebuffer","Pass","EllipsoidTangentPlane","sunDirectionWC","{clipshader}","update","createViewportQuadCommand","float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n      vec4 position = toEye(v_textureCoordinates,depth);","12298815wXZLaX","_cascadeDistances","createClippingPlane","currentTime","Renderbuffer","projectPointsOntoPlane","negate","Cartesian2","direction","clock","Texture","bufferView","texture","normalShadingSmooth","fromElements","createShadowMap","percentageChanged","RenderState","createPlane","src","getDepthStencilTexture","vtxfTexture","blending","BoundingSphere","_shadowMapCamera","viewer","fromCache","reverse","modelMatrix","Color","defaultTexture","fromPoints","replace","distance","SceneTransforms","_distance","center","length","_starttime","inverseTranspose","\nuniform sampler2D colorTexture;\nuniform sampler2D legendTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\n//多边形裁切\nuniform highp sampler2D u_clippingPlanes;\nuniform mat4 u_clippingPlanesMatrix;\nuniform vec4 u_clippingPlanesEdgeStyle;\n\n\nvec4 toEye( vec2 uv,  float depth){\n  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera =posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth( vec4 depth){\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\n\n{clipshader}\n\nvoid main()\n{\n\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\n\n    \n\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\n\n    if (clipDistance < clippingPlanesEdgeWidth)\n    {\n        vec4 finalColor = clippingPlanesEdgeColor;\n    }\n\n\n  //取colortexture的r通道\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 dcolor= texture2D(legendTexture, vec2(color.r,0.0));\n\n    gl_FragColor = vec4(dcolor.rgb,1.0);\n}","height","_lightDirectionEC","JulianDate","WindingOrder","_index","_viewportQuadCommand","_clearColorCommand","clear","canvas","addPostProcessStageX","1167275KSJQvV","_shadowMapMatrix","shadowMap","cross","Framebuffer","slice","_transformPositionUvToWorld","fromPointNormal","camera","getOriginCoordinateSystemPoint","inverse","ClippingPlane","Plane","edgeWidth","_clippingPlanesEnabled","alpha","clone","visibleAreaColor","commandList","uniformState","1278375LznoHx","enabled","fromDate","ShadowMap","_count","FRAMEBUFFER","671632uMktCE","_cameraPosition","push","BlendingState","PolygonPipeline","multiply","depthBias","_clippingPlanes","_shadowMapTexture","parseInt","Matrix4","_legendimage","clippingPlanesMatrix","DEPTH_STENCIL","updateClippingPlanes","_lastviewportQuadCommand","1523169QLFLFE","getColorTexture","transpose","now","colorFramebufferManager","LOG_DEPTH","OVERLAY","color","context","invisibleAreaColor","vec4 position = czm_windowToEyeCoordinates(fragCoord);","positions","Cartesian3","clockwisePositions","RenderbufferFormat","ClippingPlaneCollection","WHITE","getClippingFunction","2lRtnJy","_uniforms","subtract","_fb","normalize","682226idFORy","CLOCKWISE","_cascadeSplits","Cartesian4","view","then","clippingPlanesTexture","Transforms","globeDepth","_primitiveBias","_gl","readPixels","_clippingPlanesState","clippingPlanes","defines","isDestroyed","scene","6SlnrRB","destoryCommand","width","_lightPositionEC","_interval","legends","5696240dmPXmI","computeWindingOrder2D","defined","_textureSize","RED","ADDITIVE_BLEND","multiplyTransformation","normalOffsetScale","wgs84ToWindowCoordinates","OPAQUE","shadowMaps"];return(l=function(){return e})()}function c(e,t){const n=m();return(c=function(e,t){return n[e-=342]})(e,t)}function m(){const e=["2364462nkpSuA","fromColor","tollerance","174864PhrTNj","Primitive","Cartesian3","length","RED","MultiPolygon","features","ClassificationPrimitive","Color","GeometryInstance","35ErrtMz","438236adpIho","geometry","ColorGeometryInstanceAttribute","flat","341597lpJdvT","PerInstanceColorAppearance","entities","EllipsoidSurfaceAppearance","1977088UqdJVI","type","fromDegreesArray","CESIUM_3D_TILE","coordinates","15207NhMoFy","161OQIupy","_polygonHierarchy","withAlpha","maxcount","ClassificationType","VERTEX_FORMAT","map","41070TMrFQV","Polygon"];return(m=function(){return e})()}!function(e,t){const n=c,i=e();for(;;)try{if(263613===parseInt(n(348))/1+parseInt(n(344))/2+parseInt(n(357))/3+-parseInt(n(352))/4+parseInt(n(343))/5*(-parseInt(n(365))/6)+-parseInt(n(358))/7*(-parseInt(n(370))/8)+-parseInt(n(367))/9)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(m);const h=d;function d(e,t){const n=u();return(d=function(e,t){return n[e-=251]})(e,t)}function u(){const e=["softShadows","18QjhKNc","_usesDepthTexture","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","parseInt","   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","VERSION","); \n","_numberOfCascades","} \nvec3 getNormalEC() \n{ \n","createShadowReceiveFragmentShader","_primitiveBias","_terrainBias","    return normalize(","ENABLE_DAYNIGHT_SHADING","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","split","ShaderSource","slice","USE_NORMAL_SHADING","ENABLE_VERTEX_LIGHTING","debugCascadeColors","_isPointLight","sources","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","czm_shadow_receive_main","8YYBPGO","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","37642dlREMs","_pointBias","USE_CUBE_MAP_SHADOW","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","createShadowReceiveVertexShader","} \n","180902IGPTdu","length","normalShadingSmooth","SHADOW_MAP","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","16542uPuNcj",", 1.0); \n","2520045QPNeFX","ShadowMapShader","findPositionVarying","GENERATE_POSITION","2346516pOGzsm","6032007MelfBk","    return vec3(1.0); \n","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","1075440RYvEAA","USE_SOFT_SHADOWS","replaceMain","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","_polygonOffsetSupported","uniform sampler2D shadowMap_texture; \n","USE_SHADOW_DEPTH_TEXTURE","defines","_isSpotLight","normalShading","uniform samplerCube shadowMap_textureCube; \n","normalOffset","    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n","    return vec4(","USE_NORMAL_SHADING_SMOOTH","push","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","findNormalVarying","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","623YFxfIN"];return(u=function(){return e})()}!function(e,t){const n=d,i=e();for(;;)try{if(435456===parseInt(n(312))/1+-parseInt(n(318))/2*(parseInt(n(285))/3)+-parseInt(n(258))/4+parseInt(n(254))/5+-parseInt(n(252))/6*(-parseInt(n(283))/7)+-parseInt(n(310))/8*(-parseInt(n(259))/9)+parseInt(n(262))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(u);const p=Cesium[h(301)],f=Cesium.defined,C=Cesium[h(255)];let w;function g(e,t){const n=h;e?function(e){const t=h,n=Number[t(288)](Cesium[t(290)][t(300)](".")[1])>=101;w=C[t(294)],n?(C[t(316)]=function(e,n,i){const a=t,r=e[a(270)][a(302)](0),s=e[a(307)][a(302)](0);return r[a(278)](a(321)),n&&(i?r[a(278)]("GENERATE_POSITION_AND_NORMAL"):r[a(278)](a(257))),new p({defines:r,sources:s})},C[t(294)]=function(e,n,i,a,r){const s=t,o=p.findNormalVarying(e),l=!a&&f(o)||a&&r,c=p[s(256)](e),m=f(c),h=n[s(286)],d=n[s(267)],u=n[s(306)],C=n[s(271)],w=n._numberOfCascades>1,g=n.debugCascadeColors,_=n[s(284)],v=u?n._pointBias:a?n[s(296)]:n[s(295)],x=e[s(270)][s(302)](0),P=e.sources[s(302)](0),y=P.length;for(let e=0;e<y;++e)P[e]=p.replaceMain(P[e],s(309));u?x[s(278)](s(314)):h&&x[s(278)](s(269)),_&&!u&&x.push("USE_SOFT_SHADOWS"),w&&i&&a&&(l?x[s(278)](s(304)):x[s(278)](s(298))),i&&v[s(272)]&&l&&(x[s(278)](s(303)),v[s(320)]>0&&x[s(278)]("USE_NORMAL_SHADING_SMOOTH"));let E,D="";return D+=s(u?273:268),E=m?s(276)+c+s(253):s(266),D+=s(279)+E+s(293)+(l?s(297)+o+"); \n":s(260))+s(261)+(v[s(274)]&&l?s(287):"")+"} \n",D+=s(311),D+=s(265),a?D+=s(282):d||(D+=s(251)),D+=u?s(308):C?s(322):w?s(299)+(g?"    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n":""):s(315),D+="   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ",P[s(278)](D),new p({defines:x,sources:P})}):C.createShadowReceiveFragmentShader=function(e,n,i,a,r){const s=t,o=p[s(281)](e),l=!a&&f(o)||a&&r,c=p[s(256)](e),m=f(c),h=n[s(286)],d=n[s(267)],u=n[s(306)],C=n._isSpotLight,w=n[s(292)]>1,g=n[s(305)],_=n.softShadows,v=u?n[s(313)]:a?n._terrainBias:n[s(295)],x=e[s(270)][s(302)](0),P=e.sources[s(302)](0),y=P[s(319)];for(let e=0;e<y;++e)P[e]=p[s(264)](P[e],s(309));u?x[s(278)](s(314)):h&&x[s(278)](s(269)),_&&!u&&x[s(278)](s(263)),w&&i&&a&&(l?x[s(278)](s(304)):x[s(278)](s(298))),i&&v[s(272)]&&l&&(x[s(278)]("USE_NORMAL_SHADING"),v[s(320)]>0&&x[s(278)](s(277)));let E,D="";return D+=u?"uniform samplerCube shadowMap_textureCube; \n":s(268),E=m?s(276)+c+s(253):s(266),D+=s(280)+E+"} \nvec3 getNormalEC() \n{ \n"+(l?s(297)+o+s(291):s(260))+"} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n"+(v[s(274)]&&l?s(287):"")+s(317),D+="void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",D+=s(265),a?D+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":d||(D+=s(251)),D+=u?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":C?s(322):w?s(299)+(g?s(275):""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",D+=s(289),P[s(278)](D),new p({defines:x,sources:P})}}():C[n(294)]=w}const _=x;function v(){const e=["init","height","EllipsoidSurfaceAppearance","VERTEX_FORMAT","FRAMEBUFFER_COMPLETE","3938942RsPOEj","_option","setHeight","modelViewProjection","positions","canvas","divideByScalar","2frWlmt","setHours","width","BlendingState","parseInt","primitives","realMode","Matrix4","bufferView","checkFramebufferStatus","setSunAndMoonDirections","toCartesian","_isready","withAlpha","normalize","Cartographic","_lightCamera","Texture","_count","terrainProvider","TextureMinificationFilter","fromPoints","fromCartesian","multiply","update","flyToBoundingSphere","833177ltrSwj","_extraCmds","Resource","_realMode","_index","ClearCommand","_cameraPosition","readPixels","commandList","370284TSxbeK","TextureMagnificationFilter","ColorGeometryInstanceAttribute","polygonCmds","color","OPAQUE","now","Cartesian4","fetchImage","ShadowMap","computeSunPositionInEarthInertialFrame","add","DefaultImageId","DEPTH_STENCIL","_legendimage","scaleHeight","legend_0","samplePoints","internalFormat","initx","Transforms","defined","Color","Cartesian2","RenderState","renderState","113888DJDYzB","Cartesian3","context","src","clear","RenderbufferFormat","push","clampground","polygonprimitrive","addMinutes","RZType","Simon1994PlanetaryPositions","fromDate","GeometryInstance","inverse","forEach","Material","wgs84ToWindowCoordinates","dirty","image_1","modelMatrix","addMaterial","map","ALPHA_BLEND","camera","BoundingSphere","readyPromise","show","receiveCommand","Renderbuffer","_starttime","RZType2","then","setSamplePoints","eastNorthUpToFixedFrame","_samplePoints","direction","uniformMap","fromCssColorString","createFramebuffer","remove","Pass","center","FRAMEBUFFER","NEAREST","Framebuffer","sampleTerrainMostDetailed","fromCache","_context","#ffffff","sampleCallback","2646960kwUzlA","_materialCache","pickPosition","clone","equals","_sampleCallback","_shadowmap","vtxfTexture","HeadingPitchRange","_isSampleDone","position","scene","Camera","SceneTransforms","4621585edbnxJ","_clearColorCommand","multiplyByVector","fromTranslation","legends","PolygonHierarchy","4eeufJE","createReceiveDerivedCommand","63xPmmYt","27401280PkepnW","createIfNeeded","Matrix3","resolve","JulianDate","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","_fb","receiveShadows","centerWC","time","shadowMaps","PolygonGeometry","switchToPerspectiveFrustum","uniformState"];return(v=function(){return e})()}function x(e,t){const n=v();return(x=function(e,t){return n[e-=103]})(e,t)}!function(e,t){const n=x,i=e();for(;;)try{if(500330===-parseInt(n(123))/1*(-parseInt(n(258))/2)+parseInt(n(209))/3+parseInt(n(229))/4*(parseInt(n(223))/5)+-parseInt(n(132))/6+parseInt(n(251))/7+-parseInt(n(158))/8*(-parseInt(n(231))/9)+-parseInt(n(232))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(v);const P=_(237);Cesium[_(174)][_(168)]="RZType",Cesium.Material[_(210)][_(179)](Cesium[_(174)].RZType,{fabric:{type:Cesium.Material[_(168)],uniforms:{image:Cesium.Material[_(144)],legend:Cesium[_(174)][_(144)]},source:P},translucent:function(e){return!0}}),Cesium.Material[_(189)]=_(189),Cesium[_(174)][_(210)][_(179)](Cesium[_(174)][_(189)],{fabric:{type:Cesium[_(174)].RZType2,uniforms:{image:Cesium.Material[_(144)],legend:Cesium[_(174)][_(144)]},source:"\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,materialInput.st).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n"},translucent:function(e){return!0}});class y{constructor(e,t){const n=_;let i=this;if(this[n(252)]=t,this[n(193)]=t[n(149)],this._sampleCallback=t[n(208)],this._isSampleDone=!1,this[n(126)]=null!=t.realMode&&t[n(103)],t[n(165)]){t[n(255)]=t.positions[n(180)]((e=>Cesium[n(112)][n(119)](e)));const a=Cesium[n(204)](e[n(116)],t[n(255)]);Promise[n(235)](a)[n(190)]((function(a){const r=n;let s=-9999;a=a[r(180)]((e=>(e[r(247)]>s&&(s=e.height),Cesium.Cartographic[r(108)](e)))),t[r(247)]=s,t.positions=a,i.initx(e,t)}))}else i[n(151)](e,t)}[_(253)](e){const t=_;this[t(166)]&&this[t(147)](e)}[_(211)](e){const t=_;var n=viewer[t(220)][t(160)];const i=n._gl;if(i[t(106)](i[t(201)])===i[t(250)]){let i=Cesium[t(222)][t(175)](viewer[t(220)],e);return n[t(130)]({x:Number[t(262)](i.x),y:Number.parseInt(i.y),width:1,height:1,framebuffer:this._fb})[0]*(this[t(115)]/6)/255}return-1}refresh(){this[_(127)]=0}[_(147)](e){const t=_;let n=Cesium[t(152)][t(192)](this[t(240)]),i=Cesium[t(104)][t(172)](n,new(Cesium[t(104)])),a=e-this.center[t(247)],r=Cesium.Matrix4[t(226)](new Cesium.Cartesian3(0,0,a)),s=Cesium.Matrix4[t(120)](r,i,new(Cesium[t(104)]));this[t(166)][t(178)]=Cesium[t(104)][t(120)](n,s,new Cesium.Matrix4)}[_(151)](e,t){const n=_;let i=this;if(this[n(126)])this[n(246)](e,t);else{let a=t.positions[n(180)]((e=>{const i=n;let a=Cesium[i(112)][i(119)](e);return a[i(247)]=t[i(247)],Cesium.Cartographic[i(108)](a)})),r=Cesium[n(183)][n(118)](a);e[n(220)].camera[n(244)](),e[n(220)].camera[n(122)](r,{offset:new(Cesium[n(217)])(0,-1.57,0),complete:function(){i[n(246)](e,t)}})}}[_(246)](e,t){const i=_;let a=this;this.show=!0,this.secondsOfDay=0,this[i(146)]="";var r=e[i(220)][i(160)];if(t[i(227)]&&(this[i(146)]=n(t[i(227)]),Cesium[i(125)][i(233)](this[i(146)][i(161)])[i(140)]().then((function(t){const n=i;var r,s=e[n(220)][n(160)];r=Cesium.defined(t[n(150)])?new(Cesium[n(114)])({context:s,pixelFormat:t[n(150)],width:t[n(260)],height:t.height,source:{arrayBufferView:t[n(105)]}}):new(Cesium[n(114)])({context:s,source:t}),a.vtxfTexture=r}))),this[i(129)]=new(Cesium[i(159)]),t[i(255)]){var s=new(Cesium[i(203)])({context:r,colorTextures:[new(Cesium[i(114)])({context:r,width:r.canvas[i(260)],height:r[i(256)].height})],depthStencilRenderbuffer:new(Cesium[i(187)])({context:r,width:r[i(256)][i(260)],height:r[i(256)].height,format:Cesium[i(163)][i(145)]})});let n;if(this[i(238)]=s,!this[i(126)]){let a=t[i(255)][i(180)]((n=>{const a=i;let r=Cesium[a(112)].fromCartesian(n);r[a(247)]=t[a(247)],n=Cesium[a(112)].toCartesian(r);let s=Cesium[a(104)].multiplyByVector(e[a(220)][a(160)][a(245)][a(254)],new(Cesium[a(139)])(n.x,n.y,n.z,1),new(Cesium[a(139)])),o=Cesium[a(139)][a(143)](Cesium.Cartesian4[a(257)](Cesium[a(139)].divideByScalar(s,s.w,new Cesium.Cartesian4),2,new(Cesium[a(139)])),new(Cesium[a(139)])(.5,.5),new(Cesium[a(139)]));return o.x=o.x>1?1:o.x,o.x=o.x<0?0:o.x,o.y=o.y>1?1:o.y,o.y=o.y<0?0:o.y,new(Cesium[a(155)])(o.x,o.y)}));n=new(Cesium[i(228)])(a)}var o=new(Cesium[i(228)])(t[i(255)]);let a;a=n?new(Cesium[i(243)])({polygonHierarchy:o,height:t[i(247)],vertexFormat:Cesium[i(248)][i(249)],textureCoordinates:n}):new Cesium.PolygonGeometry({polygonHierarchy:o,height:t.height,vertexFormat:Cesium[i(248)][i(249)]}),this[i(200)]=Cesium.BoundingSphere[i(118)](t[i(255)])[i(200)],this[i(200)]=Cesium[i(112)].fromCartesian(this.center),this.center[i(247)]=t[i(247)],this[i(240)]=Cesium.Cartographic.toCartesian(this[i(200)]);var l=new(Cesium[i(171)])({geometry:a,attributes:{color:Cesium[i(134)].fromColor(Cesium[i(154)][i(196)](i(207))[i(110)](0))}});let c=new Cesium.Primitive({geometryInstances:l,asynchronous:!1,appearance:new Cesium.EllipsoidSurfaceAppearance({material:new Cesium.Material({fabric:{type:this[i(126)]?i(168):i(189),uniforms:{legend:this[i(146)]}},minificationFilter:Cesium[i(117)][i(202)],magnificationFilter:Cesium[i(133)].NEAREST})})});this[i(166)]=c;let m=new Date(Date[i(138)]());m[i(259)](16,0,0),this[i(127)]=0,this[i(115)]=48,m=Cesium[i(236)][i(170)](m),this[i(188)]=m;let h=this.setSunAndMoonDirections({time:m}),d=new Cesium.ShadowMap({context:e[i(220)][i(160)],lightCamera:h,enabled:!0});this[i(215)]=d,this[i(224)]=new(Cesium[i(128)])({color:new(Cesium[i(154)])(0,0,0,0),pass:Cesium[i(199)][i(137)],owner:this,framebuffer:this._fb}),this[i(109)]=!1,Cesium[i(156)][i(205)]({blending:Cesium[i(261)][i(181)]});let u=this;this[i(166)][i(184)][i(190)]((t=>{const n=i;g(!0);let a=t._colorCommands,r=a.map((t=>{const n=x;t[n(239)]=!0;let i=Cesium[n(141)][n(230)]([u[n(215)]],t,!0,e.scene[n(206)],{});i[n(186)][n(239)]=!1;const a=Cesium[n(212)](Cesium[n(261)].ADDITIVE_BLEND,!0),r=new Cesium.Color(0,0,0,0);return a[n(136)]=r,i[n(186)][n(157)].blending=a,i[n(186)].pass=7,i[n(186)].framebuffer=u._fb,i[n(186)]}));u[n(124)]=r,g(!1),u[n(135)]=a[n(180)]((e=>{const t=n;let i=Cesium[t(212)](e);return i[t(195)][t(177)]=function(){return s._colorTextures[0]},i[t(195)][t(148)]=function(){return u[t(216)]},i})),u[n(166)][n(185)]=!1,u[n(109)]=!0})),e[i(220)][i(263)][i(143)](this[i(166)])}}[_(197)](){const e=_;var t=viewer[e(220)][e(160)];return new(Cesium[e(203)])({context:t,colorTextures:[new(Cesium[e(114)])({context:t,width:t[e(256)][e(260)],height:t[e(256)][e(247)]})],depthStencilRenderbuffer:new(Cesium[e(187)])({context:t,width:t[e(256)][e(260)],height:t.canvas[e(247)],format:Cesium.RenderbufferFormat[e(145)]})})}[_(191)](e){this[_(193)]=e,this._isSampleDone=!1}[_(121)](e){const t=_;if(!this[t(185)])return;let n=this;if(this[t(109)]&&Cesium[t(153)](this[t(124)]))if(!e[t(182)][t(219)][t(213)](this[t(129)])&&this[t(126)]&&(this._index=0,this[t(218)]=!1,this._cameraPosition=Cesium[t(212)](e[t(182)].position)),0==this[t(127)]&&e[t(131)][t(164)](this[t(224)]),this[t(127)]<this._count){let i=Cesium[t(236)][t(167)](this[t(188)],10*this._index,new(Cesium[t(236)])),a=this[t(107)]({time:i});this._shadowmap[t(113)][t(219)]=a[t(219)],this[t(215)][t(113)][t(194)]=a[t(194)],this[t(215)][t(176)]=!0,e[t(242)][t(164)](this._shadowmap),this[t(124)][t(173)]((e=>{const i=t;e.modelMatrix=n[i(166)][i(178)]})),e[t(131)].push(...this[t(124)]),this[t(127)]++}else{if(this[t(193)]&&this[t(214)]&&!this[t(218)]){let e=this[t(193)][t(180)]((e=>Cesium.Cartographic[t(119)](e)));var a=function(e,t,n){var a=i,r=viewer.scene[a(364)];const s=r[a(361)];if(s[a(380)](s[a(401)])===s[a(372)])return t.map((t=>{var i=a;null!=n&&(t[i(405)]=n),t=Cesium[i(403)][i(363)](t);let s=Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene,t);return r.readPixels({x:Number.parseInt(s.x),y:Number[i(391)](s.y),width:1,height:1,framebuffer:e})}))}(this[t(238)],e,this[t(252)][t(247)]);this[t(214)](a),this[t(218)]=!0}this[t(135)][t(173)]((e=>{const i=t;e[i(178)]=n.polygonprimitrive[i(178)]})),e[t(131)][t(164)](...this[t(135)])}}[_(107)](e){const t=_;let n=new(Cesium[t(159)]),i=new(Cesium[t(234)]);Cesium[t(153)](Cesium[t(152)].computeIcrfToFixedMatrix(e[t(241)],i))||(i=Cesium[t(152)].computeTemeToPseudoFixedMatrix(e[t(241)],i));let a=Cesium[t(169)][t(142)](e.time,n);Cesium[t(234)][t(225)](i,a,a);let r=new Cesium.Cartesian3;Cesium.Cartesian3[t(111)](a,r);let s=new(Cesium[t(221)])(viewer[t(220)]);return s[t(219)]=a,s[t(194)]=r,s}[_(162)](){}destory(){const e=_;this[e(166)]&&viewer[e(220)].primitives[e(198)](this[e(166)])}}function E(e,t){var n=D();return(E=function(e,t){return n[e-=466]})(e,t)}function D(){var e=["1195hjrDxJ","1155cdIvJA","393AemByY","9CETTCR","12564zZXmVU","2607256dbhMjt","7502ZEgGts","90288AGpQtu","3868940yjQRhw","98608XleDyA","196ahDgxx","1964SaArai"];return(D=function(){return e})()}!function(e,t){for(var n=E,i=e();;)try{if(305946===parseInt(n(468))/1+-parseInt(n(477))/2*(-parseInt(n(473))/3)+-parseInt(n(470))/4*(-parseInt(n(471))/5)+parseInt(n(466))/6*(parseInt(n(469))/7)+-parseInt(n(476))/8*(parseInt(n(474))/9)+-parseInt(n(467))/10+-parseInt(n(472))/11*(parseInt(n(475))/12))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(D),e.RZPrimitive=o,e.RZPrimitiveX=y}));
