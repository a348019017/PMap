!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(e,n){var a=i();return(t=function(e,t){return a[e-=378]})(e,n)}function n(e,n){var i=t;const a=16*e[i(397)];var r=document[i(408)](i(406));r[i(409)]=a,r[i(389)]=16;var s=r.getContext("2d");s.beginPath();for(let t=0;t<e[i(397)];t++){let n=e[t][i(396)],a=16*t,r=0;s[i(391)]=n,s[i(421)](a,r,16,16)}var o=new Image;return o[i(395)]=r[i(424)](),o}function i(){var e=["getContext","src","color","length","871362wskkfE","2-3小时","1521796ScFkYW","parseInt","map","#a7f637","download","48nSdoIZ","canvas","href","createElement","width","scene","173877TydzyH","1230427GtLxFu","display","5-6小时","20QlrsxM","#f9a100","data","#f5f701","56dJmQnj","5295BsPvkB","fillRect","181811xHDDQn","context","toDataURL","_gl","wgs84ToWindowCoordinates","#0000f6","style","none","2172YusRhc","set","FRAMEBUFFER_COMPLETE","click","#06f4f7","setAttribute","Cartographic","54276XLrwGv","7小时以上","checkFramebufferStatus","readPixels","6-7小时","FRAMEBUFFER","34Logpmi","height","#f50205","fillStyle","#00baf6","body"];return(i=function(){return e})()}!function(e,n){for(var i=t,a=e();;)try{if(208577===-parseInt(i(411))/1+-parseInt(i(388))/2*(-parseInt(i(382))/3)+-parseInt(i(400))/4+parseInt(i(420))/5*(parseInt(i(430))/6)+parseInt(i(422))/7*(-parseInt(i(419))/8)+parseInt(i(398))/9*(-parseInt(i(415))/10)+parseInt(i(412))/11*(parseInt(i(405))/12))break;a.push(a.shift())}catch(e){a.push(a.shift())}}(i);const a=r;function r(e,t){const n=s();return(r=function(e,t){return n[e-=151]})(e,t)}function s(){const e=["fetchImage","FRAMEBUFFER_COMPLETE","colorFramebufferManager","viewer","916377ardTMj","src","clock","normal","Color","slice","color","inverse","_ready","_lightPositionEC","_cascadeMatrices","_lightDirectionEC","createViewportQuadCommand","readPixels","Cartesian3","ENABLE_CLIPPING_PLANES","edgeWidth","setHours","doneCallback","929904McDrQU","WindingOrder","createIfNeeded","addEventListener","_uniforms","Cartesian2","center","Plane","subtract","negate","multiplyTransformation","blending","modelMatrix","push","ADDITIVE_BLEND","createShadowMap","Texture","Renderbuffer","_viewportQuadCommand","GREEN","Matrix4","createClippingPlane","19036BdIadz","wgs84ToWindowCoordinates","shadowMaps","scene","{clipshader}","\nvarying vec2 v_textureCoordinates;\nuniform sampler2D colorTexture;   //这里可以不用colortexture，仅适用depthtexture即可\nuniform sampler2D depthTexture;\nuniform sampler2D shadowMap_texture;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec3 shadowMap_lightDirectionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\n\nuniform float helsing_alpha;\nuniform vec4 helsing_visibleAreaColor;\nuniform vec4 helsing_invisibleAreaColor;\n\n\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = 0.3;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    float visibility = _czm_shadowDepthCompare(shadowMap, uv, depth);\n\n    return visibility;\n}\n\nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n  \n} \n\n\nvoid main(){\n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    //float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n    // if(currentDepth.r >= 1.0){\n    //     gl_FragColor = color;\n    //     return;\n    // }\n    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n    \n    vec4 positionEC = toEye(v_textureCoordinates,depth);\n    depth = -positionEC.z;\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    //shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n\n    //shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015);\n\n    float maxDepth = shadowMap_cascadeSplits[1].w;\n    // Stop early if the eye depth exceeds the last cascade \n          if (depth > maxDepth) \n          { \n              gl_FragColor.rgb=color.rgb;\n              gl_FragColor.a=color.a;\n              return; \n          }\n          // Get the cascade based on the eye-space depth \n          vec4 weights = czm_cascadeWeights(depth); \n          // Apply normal offset\n          float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n          applyNormalOffset(positionEC, normalEC, nDotL); \n          // Transform position into the cascade \n          vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n          // Get visibility \n          shadowParameters.texCoords = shadowPosition.xy; \n          shadowParameters.depth = shadowPosition.z; \n          shadowParameters.nDotL = nDotL; \n          float visibility =  czm_shadowVisibility(shadowMap_texture, shadowParameters); \n          // Fade out shadows that are far away \n          float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n          float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n          visibility = mix(visibility, 1.0, fade); \n          //color.rgb*=visibility;\n          gl_FragColor.rgb=color.rgb;\n          gl_FragColor.a=color.a;\n          //gl_FragColor *= czm_cascadeColor(weights);;\n          //gl_FragColor = mix(color, helsing_visibleAreaColor, helsing_alpha);\n\n          float rd=0.020833;\n           vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n           vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n\n     // 可视域模式\n     if (visibility > 0.90){\n      gl_FragColor = helsing_visibleAreaColor;\n  }\n  else{\n      gl_FragColor = helsing_unvisibleAreaColor;\n  }\n    \n}","uniformState","\nuniform sampler2D colorTexture;\nuniform sampler2D legendTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\n//多边形裁切\nuniform highp sampler2D u_clippingPlanes;\nuniform mat4 u_clippingPlanesMatrix;\nuniform vec4 u_clippingPlanesEdgeStyle;\n\n\nvec4 toEye( vec2 uv,  float depth){\n  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera =posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth( vec4 depth){\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\n\n{clipshader}\n\nvoid main()\n{\n\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\n\n    \n\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\n\n    if (clipDistance < clippingPlanesEdgeWidth)\n    {\n        vec4 finalColor = clippingPlanesEdgeColor;\n    }\n\n\n  //取colortexture的r通道\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 dcolor= texture2D(legendTexture, vec2(color.r,0.0));\n\n    gl_FragColor = vec4(dcolor.rgb,1.0);\n}","shaderProgram","texture","clippingPlanesTexture","10DNGYZX","clear","fromElements","vec4 position = czm_windowToEyeCoordinates(fragCoord);","vtxfTexture","775104huvtJV","height","renderState","view","BoundingSphere","positions","normalOffsetScale","legends","getDepthStencilTexture","updateClippingPlanes","clippingPlanes","internalFormat","_distance","Cartesian4","computeWindingOrder2D","_lastviewportQuadCommand","PolygonPipeline","_fb","_cascadeSplits","defined","DEPTH_STENCIL","RED","9632722VTjICl","getOriginCoordinateSystemPoint","width","percentageChanged","now","maximumDistance","10838TjXPWo","enabled","update","createPlane","ClearCommand","clockwisePositions","refresh","destroyObject","canvas","clone","_clippingPlanesEnabled","direction","684216krdwFv","fromPointNormal","defaultTexture","_clippingPlanesState","75VTtYjp","ShaderSource","destroy","camera","RenderState","_cascadeDistances","BlendingState","14EhFzHB","pickPosition","RenderbufferFormat","OVERLAY","2yThogV","visibleAreaColor","context","pass","Framebuffer","globeDepth","changed","then","_count","checkFramebufferStatus","cross","_gl","multiply","sources","ClippingPlaneCollection","multiplyByPoint","_clearColorCommand","_legendimage","invisibleAreaColor","inverseTranspose","_textureSize","init","LOG_DEPTH","addPostProcessStageX","_firstdone","_index","addMinutes","commandList","WHITE","IDENTITY","EllipsoidTangentPlane","Resource","normalize","_shadowMapTexture","framebuffer","_starttime","Pass","clippingPlanesMatrix","eastNorthUpToFixedFrame","fromDate","shadowMap","_doneCallback","_shadowMapMatrix","ShadowMap","_clippingPlanes","SceneTransforms","sunDirectionWC","reverse","JulianDate","alpha","parseInt","_cameraPosition","destoryCommand","fromPoints"];return(s=function(){return e})()}!function(e,t){const n=r,i=e();for(;;)try{if(224060===parseInt(n(190))/1+parseInt(n(217))/2*(-parseInt(n(275))/3)+parseInt(n(316))/4*(-parseInt(n(206))/5)+-parseInt(n(162))/6+-parseInt(n(213))/7*(parseInt(n(294))/8)+parseInt(n(202))/9+-parseInt(n(157))/10*(-parseInt(n(184))/11))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(s);const o=a(151),l=a(153);class c{constructor(e,t){const n=a;this[n(309)](e,t),this[n(238)](t),this[n(240)]()}[a(171)](e,t){const n=a,i=e[n(172)];if(!defined(i))return!1;i.update(t);const{clippingPlanesState:r,enabled:s}=i;if(s){const t=e[n(298)];t[n(156)]=i[n(155)],t[n(254)]=Matrix4.transpose(Matrix4[n(304)](Matrix4[n(282)](i.modelMatrix,t[n(254)]),e._transformPositionUvToWorld,t[n(254)]),t.clippingPlanesMatrix)}return(e[n(205)]!==r||e[n(200)]!==s)&&(e._clippingPlanesState=r,e[n(200)]=s,!0)}[a(309)](e,t){const n=a;this[n(274)]=e,this[n(218)]=t[n(218)]||Cesium.Color[n(313)],this[n(235)]=t[n(235)]||Cesium[n(279)][n(183)],this[n(266)]=.5}[a(315)](e){const t=a;let n=e,i=Cesium[t(166)][t(270)](e)[t(300)],r=Cesium.Transforms[t(255)](i),s=Cesium[t(314)].inverseTransformation(r,new Cesium.Matrix4),o=n.length,l=[];for(let e=0;e<o;++e){let i=(e+1)%o,a=this[t(193)](n[e],n[i],s);l.push(a)}return new(Cesium[t(231)])({planes:l,modelMatrix:r,unionClippingRegions:!0})}[a(214)](e){const t=a;var n=viewer.scene[t(219)];const i=n[t(228)];if(i[t(226)](i.FRAMEBUFFER)===i[t(272)]){let i=Cesium[t(262)][t(317)](viewer.scene,e);return n[t(288)]({x:Number[t(267)](i.x),y:Number[t(267)](i.y),width:1,height:1,framebuffer:this[t(179)]})[0]*(this[t(225)]/6)/255}return-1}[a(193)](e,t,n){const i=a,r=this.getOriginCoordinateSystemPoint(e,n),s=this[i(185)](t,n),o=new(Cesium[i(289)])(0,0,-10),l=Cesium[i(289)][i(302)](s,r,new(Cesium[i(289)]));let c=Cesium[i(289)][i(227)](l,o,new Cesium.Cartesian3);c=Cesium[i(289)][i(249)](c,c);const m=Cesium[i(301)][i(203)](r,c);return new Cesium.ClippingPlane(m[i(278)],m.distance)}[a(185)](e,t){const n=a;return Cesium[n(314)][n(232)](t,e,new(Cesium[n(289)])(0,0,0))}[a(240)](){const e=a,t=this,n=this[e(257)]._primitiveBias;let i=viewer[e(319)][e(165)][e(222)][e(273)];const r=i.getColorTexture(0),s=i.getDepthStencilTexture(),l=new(Cesium[e(207)])({defines:[e(239)],sources:[o]});var c=viewer.scene.context[e(287)](l,{uniformMap:{colorTexture:function(){return r},depthTexture:function(){return s},helsing_alpha:function(){return t[e(266)]},helsing_visibleAreaColor:function(){return t.visibleAreaColor},helsing_invisibleAreaColor:function(){return t[e(235)]},shadowMap_cascadeSplits:function(){const n=e;return t[n(257)][n(180)]},shadowMap_cascadeMatrices:function(){const n=e;return t[n(257)][n(285)]},shadowMap_cascadeDistances:function(){const n=e;return t.shadowMap[n(211)]},shadowMap_texture:function(){const n=e;return t[n(257)][n(250)]},shadowMap_matrix:function(){const n=e;return t[n(257)][n(259)]},shadowMap_lightPositionEC:function(){const n=e;return t[n(257)][n(284)]},shadowMap_lightDirectionEC:function(){const n=e;return t[n(257)][n(286)]},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const i=e,a=new(Cesium[i(299)]);return a.x=1/t.shadowMap[i(237)].x,a.y=1/t[i(257)][i(237)].y,Cesium[i(175)].fromElements(a.x,a.y,n.depthBias,n.normalShadingSmooth,new(Cesium[i(175)]))},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){const i=e;return Cesium.Cartesian4[i(159)](n[i(168)],t[i(257)][i(174)],t[i(257)][i(189)],.3,new(Cesium[i(175)]))}}});c.pass=Cesium[e(253)][e(216)],this._viewportQuadCommand=c;var m=Cesium[e(210)].fromCache({depthMask:!1});const h=Cesium[e(199)](Cesium[e(212)][e(308)],!0),d=new(Cesium[e(279)])(0,0,0,0);h[e(281)]=d,m[e(305)]=h,this[e(312)][e(164)]=m,this[e(312)][e(251)]=t[e(179)],this._ready=!0}[a(195)](e){const t=a;let n=Cesium[t(247)][t(270)](e).projectPointsOntoPlane(e);return Cesium[t(178)][t(176)](n)===Cesium[t(295)].CLOCKWISE&&(e=e[t(280)]()[t(264)]()),e}[a(238)](e){const t=a;let i=this,r=new Date(Date[t(188)]());r[t(292)](8,0,0),this[t(242)]=0,this._count=48,this._interval=10,r=Cesium[t(265)][t(256)](r),this[t(252)]=r;const s=viewer[t(319)][t(165)][t(222)][t(273)][t(170)]();let o=new(Cesium[t(260)])({context:viewer[t(319)][t(219)],lightCamera:viewer[t(319)]._shadowMapCamera,enabled:!0});this.shadowMap=o,this[t(257)][t(191)]=!0;var c=viewer[t(319)][t(219)],m=new(Cesium[t(221)])({context:c,colorTextures:[new(Cesium[t(310)])({context:c,width:c[t(198)][t(186)],height:c[t(198)].height})],depthStencilRenderbuffer:new(Cesium[t(311)])({context:c,width:c[t(198)][t(186)],height:c.canvas[t(163)],format:Cesium[t(215)][t(182)]})});this._fb=m,this[t(258)]=e[t(293)],e.legends&&(this[t(234)]=n(e[t(169)]),Cesium[t(248)][t(296)](this[t(234)][t(276)])[t(271)]()[t(224)]((function(e){const n=t;var a,r=viewer[n(319)][n(219)];a=Cesium.defined(e.internalFormat)?new(Cesium[n(310)])({context:r,pixelFormat:e[n(173)],width:e[n(186)],height:e.height,source:{arrayBufferView:e.bufferView}}):new(Cesium[n(310)])({context:r,source:e}),i[n(161)]=a})));var h=Cesium[t(210)].fromCache({depthMask:!1});const d=new Cesium.ShaderSource({sources:[l],defines:[t(239)]});if(e.positions){e[t(167)]=this[t(195)](e[t(167)]),this[t(261)]=this.createClippingPlane(e.positions),d.defines[t(307)](t(290));let n=t(160),i="float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n      vec4 position = toEye(v_textureCoordinates,depth);",a=Cesium.getClippingFunction(this[t(261)],viewer[t(319)][t(219)]).replace(n,i),r=l.replace(t(320),a);d[t(230)][0]=r}const u=new(Cesium[t(314)]),p=new(Cesium[t(314)]);var f=c[t(287)](d,{uniformMap:{colorTexture:function(){return i[t(179)]._colorTextures[0]},depthTexture:function(){return s},legendTexture:function(){return i[t(161)]},u_clippingPlanes:function(){const e=t,n=i._clippingPlanes;return Cesium[e(181)](n)&&Cesium[e(181)](n[e(155)])?n.texture:viewer[e(319)][e(219)][e(204)]},u_clippingPlanesMatrix:function(){const e=t,n=i[e(261)],a=Cesium[e(181)](n)?Cesium[e(314)][e(229)](viewer[e(319)][e(219)].uniformState[e(165)],n[e(306)],u):Cesium[e(314)][e(246)];return Cesium[e(314)][e(236)](a,p)},u_clippingPlanesEdgeStyle:function(){const e=t,n=i[e(261)];if(Cesium.defined(n)){const t=n.edgeColor;return t.alpha=n[e(291)],t}return Cesium[e(279)][e(245)]}},renderState:h});f[t(220)]=Cesium[t(253)][t(216)],this[t(177)]=f,this._clearColorCommand=new(Cesium[t(194)])({color:new(Cesium[t(279)])(0,0,0,0),pass:Cesium.Pass.OPAQUE,owner:this,framebuffer:this[t(179)]}),this[t(268)]=new Cesium.Cartesian3,viewer[t(319)][t(209)][t(223)][t(297)]((()=>{i[t(242)]=0})),viewer[t(319)].camera[t(187)]=.01,this[t(283)]=!1,this[t(241)]=!1}[a(196)](){this[a(242)]=0}[a(192)](e){const t=a;if(this[t(283)]){var n=this[t(261)];if(Cesium.defined(n)&&n[t(191)]&&n[t(192)](e),0==this[t(242)]&&e[t(244)][t(307)](this[t(233)]),this._index<this[t(225)]){let n=Cesium[t(265)][t(243)](this[t(252)],10*this[t(242)],new(Cesium[t(265)]));viewer[t(277)].currentTime=n;const i=viewer[t(319)].context[t(152)];Cesium.Cartesian3[t(303)](i[t(263)],viewer.scene._shadowMapCamera[t(201)]),e[t(318)].push(this[t(257)]),this[t(312)]&&e[t(244)].push(this[t(312)]),this._index++}else this[t(177)]&&e.commandList[t(307)](this[t(177)]),!this._firstdone&&this[t(258)]&&(this[t(241)]=!0,this[t(258)]())}}isDestroyed(){return!1}[a(269)](e){const t=a,n=e;defined(n)&&(n[t(154)]=n[t(154)]&&n[t(154)][t(208)]())}[a(208)](){const e=a;return this.destoryCommand(this[e(233)]),this[e(269)](this[e(177)]),this[e(269)](this[e(312)]),Cesium[e(197)](this)}[a(158)](){}}function m(e,t){const n=h();return(m=function(e,t){return n[e-=383]})(e,t)}function h(){const e=["MultiPolygon","463761Ridrbg","5426248RzqUmG","CESIUM_3D_TILE","20481UUuTDQ","ClassificationType","1BAelqC","7077490pcQxzk","_polygonHierarchy","flat","maxdistance","ColorGeometryInstanceAttribute","features","fromDegreesArray","581522zBiCFO","tollerance","PolygonGeometry","Polygon","Cartesian3","292cTaica","fromDegreesArrayHeights","#ff0000","PerInstanceColorAppearance","geometry","2372994smlbSr","Color","coordinates","withAlpha","maxcount","RED","4310150nhRyNf","EllipsoidSurfaceAppearance","14kPbqrk","VERTEX_FORMAT","type","PolygonHierarchy","Primitive","map","ClassificationPrimitive"];return(h=function(){return e})()}!function(e,t){const n=m,i=e();for(;;)try{if(616401===parseInt(n(398))/1*(-parseInt(n(406))/2)+parseInt(n(396))/3*(-parseInt(n(411))/4)+parseInt(n(383))/5+-parseInt(n(416))/6*(parseInt(n(385))/7)+parseInt(n(394))/8+-parseInt(n(393))/9+parseInt(n(399))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(h);const d=g;!function(e,t){const n=g,i=e();for(;;)try{if(463161===parseInt(n(513))/1+-parseInt(n(565))/2*(parseInt(n(555))/3)+-parseInt(n(548))/4*(-parseInt(n(566))/5)+parseInt(n(544))/6+parseInt(n(560))/7+-parseInt(n(510))/8*(parseInt(n(519))/9)+-parseInt(n(509))/10*(parseInt(n(501))/11))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(_);const u=Cesium.ShaderSource,p=Cesium.defined,f=Cesium[d(523)];let C;function g(e,t){const n=_();return(g=function(e,t){return n[e-=497]})(e,t)}function w(e,t){const n=d;e?function(e){const t=d,n=Number[t(503)](Cesium[t(550)][t(530)](".")[1])>=101;C=f[t(561)],n?(f.createShadowReceiveVertexShader=function(e,n,i){const a=t,r=e[a(520)][a(500)](0),s=e[a(536)][a(500)](0);return r[a(526)](a(506)),n&&(i?r.push(a(514)):r[a(526)](a(559))),new u({defines:r,sources:s})},f[t(561)]=function(e,n,i,a,r){const s=t,o=u[s(502)](e),l=!a&&p(o)||a&&r,c=u[s(522)](e),m=p(c),h=n[s(524)],d=n[s(537)],f=n._isPointLight,C=n[s(521)],g=n._numberOfCascades>1,w=n[s(539)],_=n[s(556)],v=f?n[s(533)]:a?n[s(504)]:n._primitiveBias,x=e[s(520)][s(500)](0),y=e.sources[s(500)](0),P=y[s(529)];for(let e=0;e<P;++e)y[e]=u[s(562)](y[e],s(511));f?x[s(526)](s(546)):h&&x[s(526)](s(508)),_&&!f&&x[s(526)](s(525)),g&&i&&a&&(l?x[s(526)]("ENABLE_VERTEX_LIGHTING"):x[s(526)](s(540))),i&&v.normalShading&&l&&(x[s(526)](s(534)),v[s(538)]>0&&x.push(s(554)));let D,E="";return E+=f?"uniform samplerCube shadowMap_textureCube; \n":s(545),D=m?s(552)+c+s(528):"#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n",E+="uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n"+D+s(563)+(l?s(541)+o+s(515):s(547))+"} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n"+(v[s(499)]&&l?s(498):"")+"} \n",E+=s(549),E+=s(507),a?E+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":d||(E+=s(557)),E+=f?s(551):C?s(543):g?s(531)+(w?s(532):""):s(512),E+=s(564),y[s(526)](E),new u({defines:x,sources:y})}):f[t(561)]=function(e,n,i,a,r){const s=t,o=u.findNormalVarying(e),l=!a&&p(o)||a&&r,c=u[s(522)](e),m=p(c),h=n[s(524)],d=n[s(537)],f=n[s(497)],C=n[s(521)],g=n[s(558)]>1,w=n[s(539)],_=n[s(556)],v=f?n[s(533)]:a?n[s(504)]:n[s(505)],x=e[s(520)][s(500)](0),y=e.sources[s(500)](0),P=y[s(529)];for(let e=0;e<P;++e)y[e]=u.replaceMain(y[e],"czm_shadow_receive_main");f?x[s(526)](s(546)):h&&x[s(526)](s(508)),_&&!f&&x.push(s(525)),g&&i&&a&&(l?x[s(526)]("ENABLE_VERTEX_LIGHTING"):x[s(526)](s(540))),i&&v[s(542)]&&l&&(x[s(526)](s(534)),v[s(538)]>0&&x[s(526)](s(554)));let D,E="";return E+=s(f?527:545),D=m?s(552)+c+", 1.0); \n":s(516),E+=s(517)+D+s(563)+(l?s(541)+o+s(515):s(547))+s(553)+(v[s(499)]&&l?"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n":"")+"} \n",E+=s(549),E+=s(507),a?E+=s(535):d||(E+=s(557)),E+=f?s(551):C?s(543):g?s(531)+(w?"    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n":""):s(512),E+=s(518),y[s(526)](E),new u({defines:x,sources:y})}}():f[n(561)]=C}function _(){const e=["    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n","_pointBias","USE_NORMAL_SHADING","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","sources","_polygonOffsetSupported","normalShadingSmooth","debugCascadeColors","ENABLE_DAYNIGHT_SHADING","    return normalize(","normalShading","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","3233184fdWLLR","uniform sampler2D shadowMap_texture; \n","USE_CUBE_MAP_SHADOW","    return vec3(1.0); \n","71692ATHHzv","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","VERSION","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","    return vec4(","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","USE_NORMAL_SHADING_SMOOTH","24BHiKxC","softShadows","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","_numberOfCascades","GENERATE_POSITION","1804187HeQulN","createShadowReceiveFragmentShader","replaceMain","} \nvec3 getNormalEC() \n{ \n","   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ","189062vFNXSp","235CYUMvr","_isPointLight","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","normalOffset","slice","156948FnKKNB","findNormalVarying","parseInt","_terrainBias","_primitiveBias","SHADOW_MAP","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","USE_SHADOW_DEPTH_TEXTURE","240tUjOuw","13336frtrFH","czm_shadow_receive_main","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","461296xEKcqr","GENERATE_POSITION_AND_NORMAL","); \n","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","2907qjLhyU","defines","_isSpotLight","findPositionVarying","ShadowMapShader","_usesDepthTexture","USE_SOFT_SHADOWS","push","uniform samplerCube shadowMap_textureCube; \n",", 1.0); \n","length","split","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n"];return(_=function(){return e})()}const v=x;function x(e,t){const n=D();return(x=function(e,t){return n[e-=499]})(e,t)}!function(e,t){const n=x,i=e();for(;;)try{if(343482===-parseInt(n(541))/1+parseInt(n(579))/2+-parseInt(n(584))/3+-parseInt(n(625))/4*(parseInt(n(549))/5)+-parseInt(n(548))/6+-parseInt(n(530))/7*(-parseInt(n(573))/8)+-parseInt(n(640))/9*(-parseInt(n(644))/10))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(D);const y=v(574),P=v(501);function D(){const e=["PolygonGeometry","uniformMap","9527fFYEQX","Cartesian3","_samplePoints","Camera","color","checkFramebufferStatus","ShadowMap","setSunAndMoonDirections","initx","SceneTransforms","inverse","48844amupuk","sampleCallback","canvas","Transforms","_gl","FRAMEBUFFER_COMPLETE","destory","876906bsHUpU","494195bKErip","polygonCmds","readPixels","VERTEX_FORMAT","_sampleCallback","PolygonHierarchy","realMode","Pass","ADDITIVE_BLEND","fromCssColorString","Cartesian2","scene","blending","position","switchToPerspectiveFrustum","addMinutes","push","parseInt","fromTranslation","width","_starttime","Color","multiplyByVector","JulianDate","904BzFmgt","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","fetchImage","legends","then","withAlpha","1119384rJMKdI","Framebuffer","_shadowmap","EllipsoidSurfaceAppearance","RZType2","1507107rdICNl","primitives","Cartographic","samplePoints","addMaterial","now","divideByScalar","_option","flyToBoundingSphere","RenderbufferFormat","FRAMEBUFFER","Material","time","DefaultImageId","readyPromise","_context","_lightCamera","center","height","centerWC","clone","bufferView","remove","fromCartesian","Matrix4","Cartesian4","direction","clear","multiply","commandList","computeIcrfToFixedMatrix","_colorTextures","NEAREST","RZType","GeometryInstance","modelViewProjection","fromColor","Primitive","setHeight","Simon1994PlanetaryPositions","fromDate","16BPRLyE","add","image_1","init","camera","Resource","DEPTH_STENCIL","polygonprimitrive","_legendimage","terrainProvider","internalFormat","legend_0","scaleHeight","receiveShadows","resolve","9CSlICb","Texture","_extraCmds","BlendingState","7227170JOkDfs","_isSampleDone","show","vtxfTexture","secondsOfDay","HeadingPitchRange","_clearColorCommand","_realMode","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,materialInput.st).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","createIfNeeded","context","clampground","map","_count","_fb","pass","setSamplePoints","positions","framebuffer","_index","wgs84ToWindowCoordinates","ColorGeometryInstanceAttribute","pickPosition","ALPHA_BLEND","_colorCommands","defined","update","Renderbuffer","_isready","modelMatrix","toCartesian","BoundingSphere","receiveCommand","renderState","sampleTerrainMostDetailed"];return(D=function(){return e})()}Cesium.Material[v(617)]=v(617),Cesium[v(595)]._materialCache.addMaterial(Cesium[v(595)][v(617)],{fabric:{type:Cesium[v(595)][v(617)],uniforms:{image:Cesium[v(595)][v(597)],legend:Cesium[v(595)].DefaultImageId},source:y},translucent:function(e){return!0}}),Cesium[v(595)][v(583)]=v(583),Cesium[v(595)]._materialCache[v(588)](Cesium[v(595)][v(583)],{fabric:{type:Cesium[v(595)][v(583)],uniforms:{image:Cesium[v(595)][v(597)],legend:Cesium.Material[v(597)]},source:P},translucent:function(e){return!0}});class E{constructor(e,t){const n=v;let i=this;if(this[n(591)]=t,this._samplePoints=t[n(587)],this[n(553)]=t[n(542)],this._isSampleDone=!1,this[n(500)]=null!=t[n(555)]&&t[n(555)],t[n(504)]){t[n(510)]=t[n(510)][n(505)]((e=>Cesium[n(586)].fromCartesian(e)));const a=Cesium[n(527)](e[n(634)],t[n(510)]);Promise[n(639)](a).then((function(a){const r=n;let s=-9999;a=a[r(505)]((e=>(e[r(602)]>s&&(s=e[r(602)]),Cesium[r(586)][r(523)](e)))),t[r(602)]=s,t.positions=a,i[r(538)](e,t)}))}else i.initx(e,t)}[v(622)](e){const t=v;this[t(632)]&&this[t(637)](e)}[v(515)](e){const t=v;var n=viewer.scene[t(503)];const i=n[t(545)];if(i[t(535)](i[t(594)])===i[t(546)]){let i=Cesium[t(539)][t(513)](viewer[t(560)],e);return n[t(551)]({x:Number[t(566)](i.x),y:Number[t(566)](i.y),width:1,height:1,framebuffer:this._fb})[0]*(this[t(506)]/6)/255}return-1}refresh(){this[v(512)]=0}[v(637)](e){const t=v;let n=Cesium.Transforms.eastNorthUpToFixedFrame(this[t(603)]),i=Cesium[t(608)][t(540)](n,new(Cesium[t(608)])),a=e-this[t(601)][t(602)],r=Cesium[t(608)][t(567)](new Cesium.Cartesian3(0,0,a)),s=Cesium[t(608)][t(612)](r,i,new(Cesium[t(608)]));this[t(632)].modelMatrix=Cesium[t(608)][t(612)](n,s,new(Cesium[t(608)]))}[v(538)](e,t){const n=v;let i=this;if(this[n(500)])this[n(628)](e,t);else{let a=t[n(510)][n(505)]((e=>{const i=n;let a=Cesium[i(586)][i(607)](e);return a[i(602)]=t[i(602)],Cesium[i(586)][i(523)](a)})),r=Cesium.BoundingSphere.fromPoints(a);e.scene[n(629)][n(563)](),e.scene[n(629)][n(592)](r,{offset:new(Cesium[n(649)])(0,-1.57,0),complete:function(){i[n(628)](e,t)}})}}[v(628)](e,t){const i=v;let a=this;this[i(646)]=!0,this[i(648)]=0,this[i(633)]="";var r=e[i(560)][i(503)];if(t[i(576)]&&(this[i(633)]=n(t[i(576)]),Cesium[i(630)][i(502)](this[i(633)].src)[i(575)]()[i(577)]((function(t){const n=i;var r,s=e[n(560)].context;r=Cesium[n(518)](t.internalFormat)?new(Cesium[n(641)])({context:s,pixelFormat:t[n(635)],width:t[n(568)],height:t[n(602)],source:{arrayBufferView:t[n(605)]}}):new Cesium.Texture({context:s,source:t}),a.vtxfTexture=r}))),this._cameraPosition=new Cesium.Cartesian3,t[i(510)]){var s=new(Cesium[i(580)])({context:r,colorTextures:[new Cesium.Texture({context:r,width:r[i(543)][i(568)],height:r[i(543)].height})],depthStencilRenderbuffer:new Cesium.Renderbuffer({context:r,width:r.canvas.width,height:r[i(543)][i(602)],format:Cesium[i(593)][i(631)]})});let n;if(this._fb=s,!this[i(500)]){let a=t.positions[i(505)]((n=>{const a=i;let r=Cesium.Cartographic[a(607)](n);r[a(602)]=t[a(602)],n=Cesium[a(586)].toCartesian(r);let s=Cesium[a(608)][a(571)](e[a(560)][a(503)].uniformState[a(619)],new(Cesium[a(609)])(n.x,n.y,n.z,1),new(Cesium[a(609)])),o=Cesium[a(609)].add(Cesium[a(609)][a(590)](Cesium[a(609)][a(590)](s,s.w,new Cesium.Cartesian4),2,new(Cesium[a(609)])),new(Cesium[a(609)])(.5,.5),new(Cesium[a(609)]));return o.x=o.x>1?1:o.x,o.x=o.x<0?0:o.x,o.y=o.y>1?1:o.y,o.y=o.y<0?0:o.y,new(Cesium[a(559)])(o.x,o.y)}));n=new(Cesium[i(554)])(a)}var o=new(Cesium[i(554)])(t.positions);let a;a=n?new Cesium.PolygonGeometry({polygonHierarchy:o,height:t[i(602)],vertexFormat:Cesium[i(582)][i(552)],textureCoordinates:n}):new(Cesium[i(528)])({polygonHierarchy:o,height:t[i(602)],vertexFormat:Cesium[i(582)].VERTEX_FORMAT}),this.center=Cesium[i(524)].fromPoints(t.positions)[i(601)],this[i(601)]=Cesium[i(586)].fromCartesian(this[i(601)]),this[i(601)][i(602)]=t.height,this.centerWC=Cesium.Cartographic.toCartesian(this[i(601)]);var l=new(Cesium[i(618)])({geometry:a,attributes:{color:Cesium[i(514)][i(620)](Cesium[i(570)][i(558)]("#ffffff")[i(578)](0))}});let c=new(Cesium[i(621)])({geometryInstances:l,asynchronous:!1,appearance:new(Cesium[i(582)])({material:new Cesium.Material({fabric:{type:this._realMode?"RZType":"RZType2",uniforms:{legend:this[i(633)]}},minificationFilter:Cesium.TextureMinificationFilter[i(616)],magnificationFilter:Cesium.TextureMagnificationFilter[i(616)]})})});this[i(632)]=c;let m=new Date(Date[i(589)]());m.setHours(16,0,0),this[i(512)]=0,this[i(506)]=48,m=Cesium[i(572)][i(624)](m),this._starttime=m;let h=this[i(537)]({time:m}),d=new(Cesium[i(536)])({context:e[i(560)].context,lightCamera:h,enabled:!0});this[i(581)]=d,this[i(499)]=new Cesium.ClearCommand({color:new(Cesium[i(570)])(0,0,0,0),pass:Cesium[i(556)].OPAQUE,owner:this,framebuffer:this[i(507)]}),this._isready=!1,Cesium.RenderState.fromCache({blending:Cesium[i(643)][i(516)]});let u=this;this[i(632)][i(598)][i(577)]((t=>{const n=i;w(!0);let a=t[n(517)],r=a[n(505)]((t=>{const i=n;t[i(638)]=!0;let a=Cesium[i(536)].createReceiveDerivedCommand([u._shadowmap],t,!0,e[i(560)][i(599)],{});a[i(525)].receiveShadows=!1;const r=Cesium[i(604)](Cesium[i(643)][i(557)],!0),s=new(Cesium[i(570)])(0,0,0,0);return r[i(534)]=s,a.receiveCommand[i(526)][i(561)]=r,a.receiveCommand[i(508)]=7,a[i(525)][i(511)]=u[i(507)],a[i(525)]}));u[n(642)]=r,w(!1),u.polygonCmds=a[n(505)]((e=>{const t=n;let i=Cesium[t(604)](e);return i[t(529)][t(627)]=function(){return s[t(615)][0]},i[t(529)][t(636)]=function(){return u[t(647)]},i})),u[n(632)][n(646)]=!1,u[n(521)]=!0})),e[i(560)][i(585)][i(626)](this[i(632)])}}createFramebuffer(){const e=v;var t=viewer[e(560)][e(503)];return new Cesium.Framebuffer({context:t,colorTextures:[new Cesium.Texture({context:t,width:t[e(543)][e(568)],height:t[e(543)][e(602)]})],depthStencilRenderbuffer:new(Cesium[e(520)])({context:t,width:t[e(543)][e(568)],height:t[e(543)].height,format:Cesium[e(593)][e(631)]})})}[v(509)](e){const t=v;this[t(532)]=e,this[t(645)]=!1}[v(519)](e){const n=v;if(!this[n(646)])return;let i=this;if(this[n(521)]&&Cesium.defined(this[n(642)]))if(!e[n(629)][n(562)].equals(this._cameraPosition)&&this._realMode&&(this[n(512)]=0,this[n(645)]=!1,this._cameraPosition=Cesium[n(604)](e.camera.position)),0==this[n(512)]&&e[n(613)][n(565)](this[n(499)]),this[n(512)]<this[n(506)]){let t=Cesium[n(572)][n(564)](this[n(569)],10*this._index,new(Cesium[n(572)])),a=this.setSunAndMoonDirections({time:t});this[n(581)][n(600)].position=a[n(562)],this._shadowmap._lightCamera.direction=a[n(610)],this[n(581)].dirty=!0,e.shadowMaps.push(this[n(581)]),this[n(642)].forEach((e=>{const t=n;e[t(522)]=i.polygonprimitrive[t(522)]})),e[n(613)][n(565)](...this[n(642)]),this._index++}else{if(this[n(532)]&&this[n(553)]&&!this[n(645)]){let e=this[n(532)][n(505)]((e=>Cesium.Cartographic.fromCartesian(e)));var a=function(e,n,i){var a=t,r=viewer[a(410)][a(423)];const s=r._gl;if(s.checkFramebufferStatus(s[a(387)])===s[a(432)])return n[a(402)]((t=>{var n=a;null!=i&&(t[n(389)]=i),t=Cesium[n(381)].toCartesian(t);let s=Cesium.SceneTransforms[n(426)](viewer[n(410)],t);return r[n(385)]({x:Number[n(401)](s.x),y:Number[n(401)](s.y),width:1,height:1,framebuffer:e})}))}(this._fb,e,this[n(591)][n(602)]);this[n(553)](a),this[n(645)]=!0}this.polygonCmds.forEach((e=>{const t=n;e[t(522)]=i[t(632)].modelMatrix})),e[n(613)][n(565)](...this[n(550)])}}setSunAndMoonDirections(e){const t=v;let n=new(Cesium[t(531)]),i=new Cesium.Matrix3;Cesium[t(518)](Cesium[t(544)][t(614)](e[t(596)],i))||(i=Cesium[t(544)].computeTemeToPseudoFixedMatrix(e[t(596)],i));let a=Cesium[t(623)].computeSunPositionInEarthInertialFrame(e[t(596)],n);Cesium.Matrix3[t(571)](i,a,a);let r=new(Cesium[t(531)]);Cesium[t(531)].normalize(a,r);let s=new(Cesium[t(533)])(viewer[t(560)]);return s[t(562)]=a,s[t(610)]=r,s}[v(611)](){}[v(547)](){const e=v;this.polygonprimitrive&&viewer[e(560)][e(585)][e(606)](this.polygonprimitrive)}}function M(e,t){var n=S();return(M=function(e,t){return n[e-=434]})(e,t)}function S(){var e=["537413qAYqXS","1049975QFhlgo","2456008eEymZK","7xpKTpN","2oJatBP","6467432WviBvO","5828835DxIvsp","6959346yHTgnn","16589916yOoHQI"];return(S=function(){return e})()}!function(e,t){for(var n=M,i=e();;)try{if(991765===parseInt(n(441))/1*(parseInt(n(436))/2)+-parseInt(n(438))/3+parseInt(n(437))/4+-parseInt(n(442))/5+parseInt(n(439))/6*(-parseInt(n(435))/7)+parseInt(n(434))/8+parseInt(n(440))/9)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(S),e.RZPrimitive=c,e.RZPrimitiveX=E}));
