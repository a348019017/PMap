!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(){var e=["map","context","1967226vStPPB","toCartesian","146tfFiIW","none","#08f210","width","setAttribute","144iSBczl","appendChild","beginPath","695489LQNkEV","3-4小时","parseInt","set","#0000f6","#00baf6","data","getContext","2989710BEyflv","6-7小时","createElement","29649Jpyfzi","readPixels","1-2小时","257592Yvbalq","height","checkFramebufferStatus","4-5小时","330skMlyG","src","#f5f701","小于1小时","5-6小时","download","body","8glvaov","7小时以上","322690UbWJaW","SceneTransforms","createImageData","click","style","putImageData","fillRect","FRAMEBUFFER_COMPLETE","14mhckQD","href","color","display","scene","411444xVBXFa","canvas","#f9a100","_gl","fillStyle"];return(t=function(){return e})()}function n(e,a){var i=t();return(n=function(e,t){return i[e-=194]})(e,a)}function a(e,t){var a=n;const i=16*e.length;var s=document[a(223)](a(197));s.width=i,s[a(228)]=16;var o=s.getContext("2d");o[a(212)]();for(let t=0;t<e.length;t++){let n=e[t][a(250)],i=16*t,s=0;o[a(200)]=n,o[a(246)](i,s,16,16)}var r=new Image;return r[a(232)]=s.toDataURL(),r}!function(e,t){for(var a=n,i=e();;)try{if(634719===-parseInt(a(213))/1+-parseInt(a(205))/2*(parseInt(a(224))/3)+parseInt(a(238))/4*(parseInt(a(221))/5)+parseInt(a(203))/6*(-parseInt(a(248))/7)+-parseInt(a(227))/8*(-parseInt(a(210))/9)+-parseInt(a(240))/10+parseInt(a(231))/11*(parseInt(a(196))/12))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(t);const i=s;function s(e,t){const n=l();return(s=function(e,t){return n[e-=187]})(e,t)}!function(e,t){const n=s,a=e();for(;;)try{if(504364===-parseInt(n(262))/1*(parseInt(n(213))/2)+-parseInt(n(295))/3*(-parseInt(n(277))/4)+-parseInt(n(227))/5+parseInt(n(294))/6+parseInt(n(297))/7*(-parseInt(n(231))/8)+-parseInt(n(344))/9*(-parseInt(n(350))/10)+-parseInt(n(232))/11*(-parseInt(n(296))/12))break;a.push(a.shift())}catch(e){a.push(a.shift())}}(l);const o=i(328),r="\nuniform sampler2D colorTexture;\nuniform sampler2D legendTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\n//多边形裁切\nuniform highp sampler2D u_clippingPlanes;\nuniform mat4 u_clippingPlanesMatrix;\nuniform vec4 u_clippingPlanesEdgeStyle;\n\n\nvec4 toEye( vec2 uv,  float depth){\n  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera =posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth( vec4 depth){\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\n\n{clipshader}\n\nvoid main()\n{\n\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\n\n    \n\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\n\n    if (clipDistance < clippingPlanesEdgeWidth)\n    {\n        vec4 finalColor = clippingPlanesEdgeColor;\n    }\n\n\n  //取colortexture的r通道\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 dcolor= texture2D(legendTexture, vec2(color.r,0.0));\n\n    gl_FragColor = vec4(dcolor.rgb,1.0);\n}";function l(){const e=["isDestroyed","getClippingFunction","checkFramebufferStatus","Matrix4","normal","DEPTH_STENCIL","createIfNeeded","\nvarying vec2 v_textureCoordinates;\nuniform sampler2D colorTexture;   //这里可以不用colortexture，仅适用depthtexture即可\nuniform sampler2D depthTexture;\nuniform sampler2D shadowMap_texture;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec3 shadowMap_lightDirectionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\n\nuniform float helsing_alpha;\nuniform vec4 helsing_visibleAreaColor;\nuniform vec4 helsing_invisibleAreaColor;\n\n\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = 0.3;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    float visibility = _czm_shadowDepthCompare(shadowMap, uv, depth);\n\n    return visibility;\n}\n\nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n  \n} \n\n\nvoid main(){\n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    //float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n    // if(currentDepth.r >= 1.0){\n    //     gl_FragColor = color;\n    //     return;\n    // }\n    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n    \n    vec4 positionEC = toEye(v_textureCoordinates,depth);\n    depth = -positionEC.z;\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    //shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n\n    //shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015);\n\n    float maxDepth = shadowMap_cascadeSplits[1].w;\n    // Stop early if the eye depth exceeds the last cascade \n          if (depth > maxDepth) \n          { \n              gl_FragColor.rgb=color.rgb;\n              gl_FragColor.a=color.a;\n              return; \n          }\n          // Get the cascade based on the eye-space depth \n          vec4 weights = czm_cascadeWeights(depth); \n          // Apply normal offset\n          float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n          applyNormalOffset(positionEC, normalEC, nDotL); \n          // Transform position into the cascade \n          vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n          // Get visibility \n          shadowParameters.texCoords = shadowPosition.xy; \n          shadowParameters.depth = shadowPosition.z; \n          shadowParameters.nDotL = nDotL; \n          float visibility =  czm_shadowVisibility(shadowMap_texture, shadowParameters); \n          // Fade out shadows that are far away \n          float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n          float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n          visibility = mix(visibility, 1.0, fade); \n          //color.rgb*=visibility;\n          gl_FragColor.rgb=color.rgb;\n          gl_FragColor.a=color.a;\n          //gl_FragColor *= czm_cascadeColor(weights);;\n          //gl_FragColor = mix(color, helsing_visibleAreaColor, helsing_alpha);\n\n          float rd=0.020833;\n           vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n           vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n\n     // 可视域模式\n     if (visibility > 0.90){\n      gl_FragColor = helsing_visibleAreaColor;\n  }\n  else{\n      gl_FragColor = helsing_unvisibleAreaColor;\n  }\n    \n}","setHours","Pass","fromPointNormal","_gl","visibleAreaColor","positions","ClippingPlaneCollection","ADDITIVE_BLEND","Cartesian3","_interval","createShadowMap","_legendimage","parseInt","_shadowMapCamera","getDepthStencilTexture","4909338fKKWfK","center","defines","subtract","renderState","Transforms","10SQSnNe","scene","negate","_clippingPlanesState","pass","LOG_DEPTH","view","push","Color","direction","wgs84ToWindowCoordinates","_transformPositionUvToWorld","clippingPlanesTexture","normalShadingSmooth","colorFramebufferManager","fromDate","ClearCommand","ClippingPlane","color","vec4 position = czm_windowToEyeCoordinates(fragCoord);","distance","height","texture","updateClippingPlanes","_shadowMapTexture","Framebuffer","width","2VuQdzc","shadowMap","clockwisePositions","BlendingState","src","readPixels","Renderbuffer","transpose","CLOCKWISE","inverse","then","length","_uniforms","addPostProcessStageX","2769975bbCaka","_clippingPlanes","_clearColorCommand","multiply","2392fFABSG","710809LvfbZq","_doneCallback","Texture","context","inverseTransformation","GREEN","EllipsoidTangentPlane","{clipshader}","clippingPlanes","WHITE","pickPosition","enabled","SceneTransforms","uniformState","_distance","createViewportQuadCommand","Cartesian4","_lightDirectionEC","invisibleAreaColor","now","FRAMEBUFFER_COMPLETE","edgeColor","createPlane","OPAQUE","vtxfTexture","RenderbufferFormat","projectPointsOntoPlane","fromPoints","_ready","init","500246UiMgFv","globeDepth","modelMatrix","legends","_starttime","camera","fromElements","doneCallback","reverse","bufferView","cross","_count","createClippingPlane","_viewportQuadCommand","_clippingPlanesEnabled","28FmyddF","addMinutes","_fb","defined","shadowMaps","normalOffsetScale","clippingPlanesMatrix","_lastviewportQuadCommand","fetchImage","destroy","update","replace","commandList","_index","multiplyByPoint","eastNorthUpToFixedFrame","OVERLAY","480162FjYMmW","387069jqHhKd","12ynMHed","812VXdQYF","defaultTexture","Resource","_primitiveBias","_firstdone","maximumDistance","Plane","addEventListener","internalFormat","FRAMEBUFFER","ShaderSource","getOriginCoordinateSystemPoint","multiplyTransformation","sunDirectionWC","canvas","BoundingSphere","blending","percentageChanged","clear","viewer","normalize","destoryCommand","alpha","JulianDate"];return(l=function(){return e})()}class c{constructor(e,t){const n=i;this.createShadowMap(e,t),this[n(261)](t),this[n(226)]()}[i(209)](e,t){const n=i,a=e[n(240)];if(!defined(a))return!1;a[n(287)](t);const{clippingPlanesState:s,enabled:o}=a;if(o){const t=e[n(225)];t[n(198)]=a[n(208)],t[n(283)]=Matrix4[n(220)](Matrix4[n(309)](Matrix4[n(222)](a[n(264)],t.clippingPlanesMatrix),e[n(197)],t[n(283)]),t.clippingPlanesMatrix)}return(e[n(189)]!==s||e[n(276)]!==o)&&(e._clippingPlanesState=s,e[n(276)]=o,!0)}[i(339)](e,t){const n=i;this[n(316)]=e,this[n(333)]=t[n(333)]||Cesium[n(194)][n(237)],this[n(250)]=t.invisibleAreaColor||Cesium.Color.RED,this[n(319)]=.5}[i(274)](e){const t=i;let n=e,a=Cesium[t(312)][t(259)](e)[t(345)],s=Cesium[t(349)][t(292)](a),o=Cesium[t(324)][t(236)](s,new(Cesium[t(324)])),r=n[t(224)],l=[];for(let e=0;e<r;++e){let a=(e+1)%r,i=this[t(254)](n[e],n[a],o);l[t(193)](i)}return new(Cesium[t(335)])({planes:l,modelMatrix:s,unionClippingRegions:!0})}[i(242)](e){const t=i;var n=viewer[t(187)].context;const a=n[t(332)];if(a[t(323)](a[t(306)])===a[t(252)]){let a=Cesium[t(244)][t(196)](viewer[t(187)],e);return n[t(218)]({x:Number[t(341)](a.x),y:Number[t(341)](a.y),width:1,height:1,framebuffer:this[t(279)]})[0]*(this[t(273)]/6)/255}return-1}[i(254)](e,t,n){const a=i,s=this.getOriginCoordinateSystemPoint(e,n),o=this[a(308)](t,n),r=new(Cesium[a(337)])(0,0,-10),l=Cesium[a(337)][a(347)](o,s,new(Cesium[a(337)]));let c=Cesium[a(337)][a(272)](l,r,new(Cesium[a(337)]));c=Cesium[a(337)][a(317)](c,c);const m=Cesium[a(303)][a(331)](s,c);return new(Cesium[a(203)])(m[a(325)],m[a(206)])}getOriginCoordinateSystemPoint(e,t){const n=i;return Cesium[n(324)][n(291)](t,e,new(Cesium[n(337)])(0,0,0))}addPostProcessStageX(){const e=i,t=this,n=this.shadowMap[e(300)];let a=viewer[e(187)][e(192)][e(263)][e(200)];const s=a.getColorTexture(0),r=a[e(343)](),l=new(Cesium[e(307)])({defines:[e(191)],sources:[o]});var c=viewer.scene[e(235)][e(247)](l,{uniformMap:{colorTexture:function(){return s},depthTexture:function(){return r},helsing_alpha:function(){return t[e(319)]},helsing_visibleAreaColor:function(){return t[e(333)]},helsing_invisibleAreaColor:function(){return t[e(250)]},shadowMap_cascadeSplits:function(){return t[e(214)]._cascadeSplits},shadowMap_cascadeMatrices:function(){return t.shadowMap._cascadeMatrices},shadowMap_cascadeDistances:function(){return t[e(214)]._cascadeDistances},shadowMap_texture:function(){const n=e;return t[n(214)][n(210)]},shadowMap_matrix:function(){return t[e(214)]._shadowMapMatrix},shadowMap_lightPositionEC:function(){return t[e(214)]._lightPositionEC},shadowMap_lightDirectionEC:function(){const n=e;return t[n(214)][n(249)]},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const a=e,i=new Cesium.Cartesian2;return i.x=1/t[a(214)]._textureSize.x,i.y=1/t[a(214)]._textureSize.y,Cesium[a(248)].fromElements(i.x,i.y,n.depthBias,n[a(199)],new(Cesium[a(248)]))},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){const a=e;return Cesium.Cartesian4[a(268)](n[a(282)],t[a(214)][a(246)],t[a(214)][a(302)],.3,new(Cesium[a(248)]))}}});c[e(190)]=Cesium.Pass[e(293)],this[e(275)]=c;var m=Cesium.RenderState.fromCache({depthMask:!1});const h=Cesium.clone(Cesium[e(216)][e(336)],!0),d=new(Cesium[e(194)])(0,0,0,0);h[e(204)]=d,m[e(313)]=h,this[e(275)][e(348)]=m,this[e(275)].framebuffer=t[e(279)],this[e(260)]=!0}clockwisePositions(e){const t=i;let n=Cesium[t(238)][t(259)](e)[t(258)](e);return Cesium.PolygonPipeline.computeWindingOrder2D(n)===Cesium.WindingOrder[t(221)]&&(e=e.slice()[t(270)]()),e}init(e){const t=i;let n=this,s=new Date(Date[t(251)]());s[t(329)](8,0,0),this[t(290)]=0,this[t(273)]=48,this[t(338)]=10,s=Cesium.JulianDate[t(201)](s),this[t(266)]=s;const o=viewer[t(187)][t(192)].globeDepth[t(200)].getDepthStencilTexture();let l=new Cesium.ShadowMap({context:viewer[t(187)].context,lightCamera:viewer.scene[t(342)],enabled:!0});this[t(214)]=l,this[t(214)][t(243)]=!0;var c=viewer[t(187)][t(235)],m=new(Cesium[t(211)])({context:c,colorTextures:[new(Cesium[t(234)])({context:c,width:c.canvas.width,height:c[t(311)][t(207)]})],depthStencilRenderbuffer:new(Cesium[t(219)])({context:c,width:c.canvas.width,height:c[t(311)][t(207)],format:Cesium[t(257)][t(326)]})});this[t(279)]=m,this[t(233)]=e[t(269)],e[t(265)]&&(this._legendimage=a(e[t(265)]),Cesium[t(299)][t(327)](this[t(340)][t(217)])[t(285)]()[t(223)]((function(e){const a=t;var i,s=viewer[a(187)][a(235)];i=Cesium[a(280)](e.internalFormat)?new Cesium.Texture({context:s,pixelFormat:e[a(305)],width:e[a(212)],height:e[a(207)],source:{arrayBufferView:e[a(271)]}}):new(Cesium[a(234)])({context:s,source:e}),n[a(256)]=i})));var h=Cesium.RenderState.fromCache({depthMask:!1});const d=new(Cesium[t(307)])({sources:[r],defines:["LOG_DEPTH"]});if(e[t(334)]){e[t(334)]=this[t(215)](e[t(334)]),this._clippingPlanes=this.createClippingPlane(e[t(334)]),d[t(346)][t(193)]("ENABLE_CLIPPING_PLANES");let n=t(205),a="float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n      vec4 position = toEye(v_textureCoordinates,depth);",i=Cesium[t(322)](this._clippingPlanes,viewer[t(187)].context)[t(288)](n,a),s=r[t(288)](t(239),i);d.sources[0]=s}const u=new(Cesium[t(324)]),p=new Cesium.Matrix4;var f=c.createViewportQuadCommand(d,{uniformMap:{colorTexture:function(){return n._fb._colorTextures[0]},depthTexture:function(){return o},legendTexture:function(){return n[t(256)]},u_clippingPlanes:function(){const e=t,a=n[e(228)];return Cesium[e(280)](a)&&Cesium[e(280)](a[e(208)])?a[e(208)]:viewer[e(187)].context[e(298)]},u_clippingPlanesMatrix:function(){const e=t,a=n[e(228)],i=Cesium[e(280)](a)?Cesium[e(324)][e(230)](viewer[e(187)].context[e(245)][e(192)],a[e(264)],u):Cesium[e(324)].IDENTITY;return Cesium[e(324)].inverseTranspose(i,p)},u_clippingPlanesEdgeStyle:function(){const e=t,a=n._clippingPlanes;if(Cesium.defined(a)){const t=a[e(253)];return t[e(319)]=a.edgeWidth,t}return Cesium[e(194)][e(241)]}},renderState:h});f[t(190)]=Cesium[t(330)].OVERLAY,this[t(284)]=f,this[t(229)]=new(Cesium[t(202)])({color:new(Cesium[t(194)])(0,0,0,0),pass:Cesium[t(330)][t(255)],owner:this,framebuffer:this[t(279)]}),this._cameraPosition=new(Cesium[t(337)]),viewer.scene.camera.changed[t(304)]((()=>{n[t(290)]=0})),viewer[t(187)][t(267)][t(314)]=.01,this[t(260)]=!1,this._firstdone=!1}refresh(){this._index=0}[i(287)](e){const t=i;if(this[t(260)]){var n=this[t(228)];if(Cesium[t(280)](n)&&n[t(243)]&&n[t(287)](e),0==this[t(290)]&&e[t(289)][t(193)](this[t(229)]),this[t(290)]<this._count){let n=Cesium[t(320)][t(278)](this._starttime,10*this._index,new(Cesium[t(320)]));viewer.clock.currentTime=n;const a=viewer[t(187)][t(235)][t(245)];Cesium.Cartesian3[t(188)](a[t(310)],viewer[t(187)][t(342)][t(195)]),e[t(281)][t(193)](this[t(214)]),this[t(275)]&&e.commandList[t(193)](this[t(275)]),this[t(290)]++}else this[t(284)]&&e[t(289)].push(this[t(284)]),!this[t(301)]&&this[t(233)]&&(this[t(301)]=!0,this._doneCallback())}}[i(321)](){return!1}[i(318)](e){const t=i,n=e;defined(n)&&(n.shaderProgram=n.shaderProgram&&n.shaderProgram[t(286)]())}[i(286)](){const e=i;return this[e(318)](this._clearColorCommand),this[e(318)](this._lastviewportQuadCommand),this[e(318)](this[e(275)]),Cesium.destroyObject(this)}[i(315)](){}}function m(e,t){const n=h();return(m=function(e,t){return n[e-=456]})(e,t)}function h(){const e=["PolygonGeometry","geometry","entities","map","9JsfuHg","PerInstanceColorAppearance","tollerance","length","ClassificationPrimitive","142214TdekFY","5357090rxuZxY","VERTEX_FORMAT","2982836ZjYNQf","13810wdVlrW","Cartesian3","RED","Color","ClassificationType","26516glbuMG","fromDegreesArray","896dVKPoZ","type","CESIUM_3D_TILE","add","maxdistance","fromDegreesArrayHeights","flat","coordinates","Polygon","15800389mFCqJU","6IUAuOV","742482UzJYsB","withAlpha","PolygonHierarchy","MultiPolygon","GeometryInstance","1632ifZVDB","fromColor","Primitive","features"];return(h=function(){return e})()}!function(e,t){const n=m,a=e();for(;;)try{if(623257===parseInt(n(465))/1*(parseInt(n(486))/2)+parseInt(n(487))/3+parseInt(n(468))/4+parseInt(n(469))/5*(parseInt(n(492))/6)+parseInt(n(474))/7*(parseInt(n(476))/8)+parseInt(n(460))/9*(-parseInt(n(466))/10)+-parseInt(n(485))/11)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(h);const d=u;function u(e,t){const n=w();return(u=function(e,t){return n[e-=260]})(e,t)}!function(e,t){const n=u,a=e();for(;;)try{if(135110===-parseInt(n(268))/1*(-parseInt(n(330))/2)+-parseInt(n(321))/3+-parseInt(n(324))/4*(parseInt(n(272))/5)+parseInt(n(310))/6*(-parseInt(n(284))/7)+-parseInt(n(292))/8*(parseInt(n(290))/9)+parseInt(n(301))/10*(parseInt(n(280))/11)+-parseInt(n(316))/12*(-parseInt(n(262))/13))break;a.push(a.shift())}catch(e){a.push(a.shift())}}(w);const p=Cesium[d(312)],f=Cesium[d(270)],C=Cesium[d(323)];function w(){const e=["ENABLE_VERTEX_LIGHTING","USE_NORMAL_SHADING_SMOOTH",", 1.0); \n","slice","normalShadingSmooth","} \nvec3 getNormalEC() \n{ \n","USE_SOFT_SHADOWS","    return vec3(1.0); \n","174126HrLzMi","push","ShaderSource","_polygonOffsetSupported","normalShading","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","12twtMXI","uniform samplerCube shadowMap_textureCube; \n","replaceMain","_isPointLight","findNormalVarying","713151qCCoIm","softShadows","ShadowMapShader","60828xcVqSt","    return vec4(","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n","5316mFRZOv","USE_CUBE_MAP_SHADOW","USE_NORMAL_SHADING","VERSION","11158888dnyVpn","    return normalize(","_terrainBias","normalOffset","czm_shadow_receive_main","_primitiveBias","15Blyjme","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","defined","_numberOfCascades","65mriYEk","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","sources","    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n","GENERATE_POSITION_AND_NORMAL","createShadowReceiveFragmentShader","parseInt","USE_SHADOW_DEPTH_TEXTURE","979nTmvgZ","ENABLE_DAYNIGHT_SHADING","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","63WwAYib","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","} \n","uniform sampler2D shadowMap_texture; \n","_isSpotLight","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","407961iLiosj","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","16blfwDe","debugCascadeColors","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","length","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","_pointBias","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","_usesDepthTexture","findPositionVarying","2710yYkRvM"];return(w=function(){return e})()}let g;function _(e,t){const n=d;e?function(e){const t=d,n=Number[t(278)](Cesium[t(261)].split(".")[1])>=101;g=C[t(277)],n?(C.createShadowReceiveVertexShader=function(e,n,a){const i=t,s=e.defines[i(305)](0),o=e.sources[i(305)](0);return s[i(311)]("SHADOW_MAP"),n&&(a?s.push(i(276)):s[i(311)]("GENERATE_POSITION")),new p({defines:s,sources:o})},C[t(277)]=function(e,n,a,i,s){const o=t,r=p[o(320)](e),l=!i&&f(r)||i&&s,c=p[o(300)](e),m=f(c),h=n[o(299)],d=n[o(313)],u=n[o(319)],C=n[o(288)],w=n[o(271)]>1,g=n.debugCascadeColors,_=n[o(322)],v=u?n[o(297)]:i?n[o(264)]:n[o(267)],x=e.defines[o(305)](0),P=e[o(274)][o(305)](0),y=P.length;for(let e=0;e<y;++e)P[e]=p[o(318)](P[e],o(266));u?x[o(311)](o(331)):h&&x.push(o(279)),_&&!u&&x[o(311)]("USE_SOFT_SHADOWS"),w&&a&&i&&(l?x.push(o(302)):x.push(o(281))),a&&v[o(314)]&&l&&(x[o(311)](o(260)),v[o(306)]>0&&x[o(311)](o(303)));let D,E="";return E+=o(u?317:287),D=m?o(325)+c+", 1.0); \n":o(269),E+=o(298)+D+o(307)+(l?o(263)+r+"); \n":o(309))+o(294)+(v[o(265)]&&l?"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n":"")+o(286),E+=o(282),E+=o(327),i?E+=o(291):d||(E+=o(315)),E+=u?o(273):C?o(296):w?o(283)+(g?o(329):""):o(326),E+="   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ",P[o(311)](E),new p({defines:x,sources:P})}):C[t(277)]=function(e,n,a,i,s){const o=t,r=p[o(320)](e),l=!i&&f(r)||i&&s,c=p[o(300)](e),m=f(c),h=n._usesDepthTexture,d=n[o(313)],u=n._isPointLight,C=n[o(288)],w=n[o(271)]>1,g=n[o(293)],_=n[o(322)],v=u?n[o(297)]:i?n[o(264)]:n[o(267)],x=e.defines.slice(0),P=e.sources[o(305)](0),y=P[o(295)];for(let e=0;e<y;++e)P[e]=p[o(318)](P[e],o(266));u?x[o(311)](o(331)):h&&x.push("USE_SHADOW_DEPTH_TEXTURE"),_&&!u&&x[o(311)](o(308)),w&&a&&i&&(l?x[o(311)]("ENABLE_VERTEX_LIGHTING"):x[o(311)](o(281))),a&&v[o(314)]&&l&&(x[o(311)]("USE_NORMAL_SHADING"),v[o(306)]>0&&x[o(311)](o(303)));let D,E="";return E+=u?o(317):"uniform sampler2D shadowMap_texture; \n",D=m?o(325)+c+o(304):o(269),E+=o(289)+D+o(307)+(l?o(263)+r+"); \n":o(309))+"} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n"+(v[o(265)]&&l?o(285):"")+"} \n",E+=o(282),E+=o(327),i?E+=o(291):d||(E+=o(315)),E+=u?o(273):C?"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n":w?"    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n"+(g?o(275):""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",E+=o(328),P[o(311)](E),new p({defines:x,sources:P})}}():C[n(277)]=g}const v=y;!function(e,t){const n=y,a=e();for(;;)try{if(459972===-parseInt(n(614))/1*(parseInt(n(645))/2)+-parseInt(n(495))/3*(-parseInt(n(607))/4)+-parseInt(n(529))/5*(parseInt(n(539))/6)+parseInt(n(596))/7+-parseInt(n(528))/8+parseInt(n(542))/9*(-parseInt(n(518))/10)+parseInt(n(551))/11)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(D);const x=v(514),P=v(501);function y(e,t){const n=D();return(y=function(e,t){return n[e-=495]})(e,t)}function D(){const e=["_index","7007390IfoSWU","centerWC","Matrix4","_gl","receiveShadows","_samplePoints","_realMode","Color","Cartesian2","Camera","232568KRNsVF","1285475fBaWBM","BlendingState","wgs84ToWindowCoordinates","ColorGeometryInstanceAttribute","renderState","now","height","HeadingPitchRange","withAlpha","OPAQUE","18FUfRqB","realMode","Primitive","9MRKaSg","framebuffer","fromPoints","clampground","SceneTransforms","context","_sampleCallback","shadowMaps","clear","12118975wOanEA","Resource","time","fromCssColorString","fromCache","Cartesian4","push","sampleTerrainMostDetailed","Framebuffer","direction","canvas","_colorCommands","multiplyByVector","_count","_starttime","modelViewProjection","setSunAndMoonDirections","dirty","TextureMinificationFilter","sampleCallback","NEAREST","toCartesian","Material","VERTEX_FORMAT","refresh","camera","initx","ClearCommand","_legendimage","RZType2","divideByScalar","_fb","uniformMap","parseInt","setHeight","internalFormat","fromColor","width","clone","polygonCmds","_lightCamera","EllipsoidSurfaceAppearance","vtxfTexture","DefaultImageId","addMaterial","6082461BRgIIN","Cartesian3","legend_0","fromCartesian","_context","remove","init","Transforms","add","Pass","RZType","28elfLFs","modelMatrix","scaleHeight","resolve","_option","scene","computeIcrfToFixedMatrix","1718aqvTlB","receiveCommand","ShadowMap","TextureMagnificationFilter","FRAMEBUFFER_COMPLETE","update","setHours","createFramebuffer","readPixels","_isready","forEach","defined","DEPTH_STENCIL","fromDate","Simon1994PlanetaryPositions","multiply","polygonprimitrive","computeTemeToPseudoFixedMatrix","Renderbuffer","_isSampleDone","Cartographic","map","show","Matrix3","position","switchToPerspectiveFrustum","pickPosition","PolygonHierarchy","pass","center","RenderState","624nMAPxT","positions","RenderbufferFormat","_shadowmap","addMinutes","225615PCflIC","image_1","_colorTextures","blending","_cameraPosition","GeometryInstance","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,materialInput.st).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","ALPHA_BLEND","flyToBoundingSphere","src","primitives","Texture","_materialCache","JulianDate","legends","_extraCmds","BoundingSphere","createReceiveDerivedCommand","commandList","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","then","terrainProvider"];return(D=function(){return e})()}Cesium[v(573)][v(606)]="RZType",Cesium[v(573)][v(507)][v(595)](Cesium[v(573)][v(606)],{fabric:{type:Cesium[v(573)][v(606)],uniforms:{image:Cesium.Material[v(594)],legend:Cesium[v(573)][v(594)]},source:x},translucent:function(e){return!0}}),Cesium[v(573)].RZType2=v(580),Cesium[v(573)][v(507)][v(595)](Cesium[v(573)][v(580)],{fabric:{type:Cesium[v(573)][v(580)],uniforms:{image:Cesium[v(573)][v(594)],legend:Cesium[v(573)][v(594)]},source:P},translucent:function(e){return!0}});class E{constructor(e,t){const n=v;let a=this;if(this[n(611)]=t,this[n(523)]=t.samplePoints,this[n(548)]=t[n(570)],this[n(633)]=!1,this._realMode=null!=t.realMode&&t[n(540)],t[n(545)]){t[n(646)]=t[n(646)][n(635)]((e=>Cesium.Cartographic[n(599)](e)));const i=Cesium[n(558)](e[n(516)],t[n(646)]);Promise[n(610)](i)[n(515)]((function(i){const s=n;let o=-9999;i=i.map((e=>(e[s(535)]>o&&(o=e[s(535)]),Cesium.Cartographic.toCartesian(e)))),t[s(535)]=o,t[s(646)]=i,a[s(577)](e,t)}))}else a[n(577)](e,t)}[v(585)](e){this[v(630)]&&this.scaleHeight(e)}[v(640)](e){const t=v;var n=viewer.scene.context;const a=n[t(521)];if(a.checkFramebufferStatus(a.FRAMEBUFFER)===a[t(618)]){let a=Cesium[t(546)][t(531)](viewer[t(612)],e);return n[t(622)]({x:Number[t(584)](a.x),y:Number[t(584)](a.y),width:1,height:1,framebuffer:this[t(582)]})[0]*(this[t(564)]/6)/255}return-1}[v(575)](){this[v(517)]=0}[v(609)](e){const t=v;let n=Cesium[t(603)].eastNorthUpToFixedFrame(this[t(519)]),a=Cesium[t(520)].inverse(n,new Cesium.Matrix4),i=e-this[t(643)][t(535)],s=Cesium.Matrix4.fromTranslation(new(Cesium[t(597)])(0,0,i)),o=Cesium[t(520)].multiply(s,a,new(Cesium[t(520)]));this[t(630)][t(608)]=Cesium[t(520)][t(629)](n,o,new(Cesium[t(520)]))}[v(577)](e,t){const n=v;let a=this;if(this[n(524)])this[n(602)](e,t);else{let i=t[n(646)][n(635)]((e=>{const a=n;let i=Cesium.Cartographic.fromCartesian(e);return i[a(535)]=t[a(535)],Cesium[a(634)][a(572)](i)})),s=Cesium[n(511)][n(544)](i);e.scene[n(576)][n(639)](),e.scene[n(576)][n(503)](s,{offset:new(Cesium[n(536)])(0,-1.57,0),complete:function(){a[n(602)](e,t)}})}}[v(602)](e,t){const n=v;let i=this;this[n(636)]=!0,this.secondsOfDay=0,this[n(579)]="";var s=e.scene[n(547)];if(t[n(509)]&&(this[n(579)]=a(t.legends),Cesium[n(552)].createIfNeeded(this[n(579)][n(504)]).fetchImage()[n(515)]((function(t){const a=n;var s,o=e[a(612)][a(547)];s=Cesium[a(625)](t[a(586)])?new(Cesium[a(506)])({context:o,pixelFormat:t[a(586)],width:t[a(588)],height:t[a(535)],source:{arrayBufferView:t.bufferView}}):new(Cesium[a(506)])({context:o,source:t}),i[a(593)]=s}))),this._cameraPosition=new(Cesium[n(597)]),t.positions){var o=new(Cesium[n(559)])({context:s,colorTextures:[new Cesium.Texture({context:s,width:s[n(561)].width,height:s.canvas[n(535)]})],depthStencilRenderbuffer:new(Cesium[n(632)])({context:s,width:s.canvas[n(588)],height:s.canvas[n(535)],format:Cesium[n(647)][n(626)]})});let a;if(this[n(582)]=o,!this[n(524)]){let i=t.positions[n(635)]((a=>{const i=n;let s=Cesium[i(634)][i(599)](a);s[i(535)]=t[i(535)],a=Cesium[i(634)][i(572)](s);let o=Cesium[i(520)][i(563)](e[i(612)][i(547)].uniformState[i(566)],new Cesium.Cartesian4(a.x,a.y,a.z,1),new(Cesium[i(556)])),r=Cesium.Cartesian4.add(Cesium[i(556)][i(581)](Cesium[i(556)][i(581)](o,o.w,new(Cesium[i(556)])),2,new(Cesium[i(556)])),new(Cesium[i(556)])(.5,.5),new(Cesium[i(556)]));return r.x=r.x>1?1:r.x,r.x=r.x<0?0:r.x,r.y=r.y>1?1:r.y,r.y=r.y<0?0:r.y,new(Cesium[i(526)])(r.x,r.y)}));a=new(Cesium[n(641)])(i)}var r=new(Cesium[n(641)])(t[n(646)]);let i;i=a?new Cesium.PolygonGeometry({polygonHierarchy:r,height:t[n(535)],vertexFormat:Cesium[n(592)][n(574)],textureCoordinates:a}):new Cesium.PolygonGeometry({polygonHierarchy:r,height:t[n(535)],vertexFormat:Cesium.EllipsoidSurfaceAppearance[n(574)]}),this[n(643)]=Cesium[n(511)][n(544)](t.positions)[n(643)],this[n(643)]=Cesium[n(634)][n(599)](this.center),this[n(643)][n(535)]=t[n(535)],this[n(519)]=Cesium.Cartographic[n(572)](this.center);var l=new(Cesium[n(500)])({geometry:i,attributes:{color:Cesium[n(532)][n(587)](Cesium[n(525)][n(554)]("#ffffff")[n(537)](0))}});let c=new(Cesium[n(541)])({geometryInstances:l,asynchronous:!1,appearance:new(Cesium[n(592)])({material:new Cesium.Material({fabric:{type:this._realMode?n(606):"RZType2",uniforms:{legend:this[n(579)]}},minificationFilter:Cesium[n(569)][n(571)],magnificationFilter:Cesium[n(617)][n(571)]})})});this[n(630)]=c;let m=new Date(Date[n(534)]());m[n(620)](16,0,0),this[n(517)]=0,this[n(564)]=48,m=Cesium[n(508)][n(627)](m),this[n(565)]=m;let h=this[n(567)]({time:m}),d=new(Cesium[n(616)])({context:e.scene[n(547)],lightCamera:h,enabled:!0});this[n(648)]=d,this._clearColorCommand=new(Cesium[n(578)])({color:new(Cesium[n(525)])(0,0,0,0),pass:Cesium[n(605)][n(538)],owner:this,framebuffer:this._fb}),this._isready=!1,Cesium[n(644)][n(555)]({blending:Cesium.BlendingState[n(502)]});let u=this;this.polygonprimitrive.readyPromise[n(515)]((t=>{const a=n;_(!0);let i=t[a(562)],s=i.map((t=>{const n=a;t[n(522)]=!0;let i=Cesium[n(616)][n(512)]([u._shadowmap],t,!0,e[n(612)][n(600)],{});i[n(615)][n(522)]=!1;const s=Cesium[n(589)](Cesium[n(530)].ADDITIVE_BLEND,!0),o=new(Cesium[n(525)])(0,0,0,0);return s.color=o,i[n(615)][n(533)][n(498)]=s,i[n(615)][n(642)]=7,i[n(615)][n(543)]=u[n(582)],i[n(615)]}));u._extraCmds=s,_(!1),u.polygonCmds=i.map((e=>{const t=a;let n=Cesium[t(589)](e);return n[t(583)][t(496)]=function(){return o[t(497)][0]},n.uniformMap[t(598)]=function(){return u[t(593)]},n})),u[a(630)][a(636)]=!1,u[a(623)]=!0})),e[n(612)][n(505)][n(604)](this[n(630)])}}[v(621)](){const e=v;var t=viewer[e(612)][e(547)];return new(Cesium[e(559)])({context:t,colorTextures:[new Cesium.Texture({context:t,width:t.canvas[e(588)],height:t.canvas[e(535)]})],depthStencilRenderbuffer:new(Cesium[e(632)])({context:t,width:t.canvas[e(588)],height:t[e(561)][e(535)],format:Cesium.RenderbufferFormat[e(626)]})})}setSamplePoints(e){const t=v;this[t(523)]=e,this[t(633)]=!1}[v(619)](e){const t=v;if(!this.show)return;let a=this;if(this[t(623)]&&Cesium[t(625)](this[t(510)]))if(!e.camera[t(638)].equals(this[t(499)])&&this[t(524)]&&(this[t(517)]=0,this[t(633)]=!1,this._cameraPosition=Cesium.clone(e.camera[t(638)])),0==this[t(517)]&&e.commandList.push(this._clearColorCommand),this[t(517)]<this[t(564)]){let n=Cesium[t(508)][t(649)](this._starttime,10*this[t(517)],new Cesium.JulianDate),i=this[t(567)]({time:n});this[t(648)][t(591)][t(638)]=i.position,this[t(648)]._lightCamera.direction=i[t(560)],this[t(648)][t(568)]=!0,e[t(549)][t(557)](this[t(648)]),this[t(510)][t(624)]((e=>{const n=t;e[n(608)]=a[n(630)].modelMatrix})),e[t(513)][t(557)](...this[t(510)]),this[t(517)]++}else{if(this[t(523)]&&this[t(548)]&&!this[t(633)]){let e=this[t(523)][t(635)]((e=>Cesium.Cartographic.fromCartesian(e)));var i=function(e,t,a){var i=n,s=viewer[i(195)][i(202)];const o=s[i(199)];if(o.checkFramebufferStatus(o.FRAMEBUFFER)===o[i(247)])return t[i(201)]((t=>{var n=i;null!=a&&(t.height=a),t=Cesium.Cartographic[n(204)](t);let o=Cesium[n(241)].wgs84ToWindowCoordinates(viewer[n(195)],t);return s.readPixels({x:Number[n(215)](o.x),y:Number[n(215)](o.y),width:1,height:1,framebuffer:e})}))}(this[t(582)],e,this[t(611)].height);this._sampleCallback(i),this[t(633)]=!0}this.polygonCmds[t(624)]((e=>{const n=t;e[n(608)]=a[n(630)][n(608)]})),e[t(513)][t(557)](...this[t(590)])}}[v(567)](e){const t=v;let n=new(Cesium[t(597)]),a=new(Cesium[t(637)]);Cesium[t(625)](Cesium[t(603)][t(613)](e[t(553)],a))||(a=Cesium.Transforms[t(631)](e[t(553)],a));let i=Cesium[t(628)].computeSunPositionInEarthInertialFrame(e[t(553)],n);Cesium[t(637)].multiplyByVector(a,i,i);let s=new(Cesium[t(597)]);Cesium[t(597)].normalize(i,s);let o=new(Cesium[t(527)])(viewer[t(612)]);return o[t(638)]=i,o[t(560)]=s,o}[v(550)](){}destory(){const e=v;this[e(630)]&&viewer.scene.primitives[e(601)](this[e(630)])}}function M(e,t){var n=S();return(M=function(e,t){return n[e-=114]})(e,t)}function S(){var e=["54066FEnpvU","9457560dXBtmr","252PcpFZK","7784139hsnTOj","8tSptnK","26XeKqxn","269756egWCJV","33QvYnPe","29006FgZENd","260235WPNsCA","9395100OEpCBB"];return(S=function(){return e})()}!function(e,t){for(var n=M,a=e();;)try{if(991211===-parseInt(n(121))/1*(-parseInt(n(124))/2)+parseInt(n(123))/3*(parseInt(n(122))/4)+parseInt(n(115))/5+parseInt(n(116))/6*(-parseInt(n(118))/7)+parseInt(n(120))/8*(-parseInt(n(114))/9)+-parseInt(n(117))/10+-parseInt(n(119))/11)break;a.push(a.shift())}catch(e){a.push(a.shift())}}(S),e.RZPrimitive=c,e.RZPrimitiveX=E}));
