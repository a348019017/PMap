!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(){var e=["#0000f6","879306DguQfL","FRAMEBUFFER_COMPLETE","none","22QfhBQd","getContext","261862bncCji","26761XxBAHW","appendChild","color","checkFramebufferStatus","2-3小时","7995180upZuqw","fillRect","12348sWvaMi","style","3-4小时","5-6小时","2qbvWUp","840ZssGBm","data","parseInt","7小时以上","小于1小时","60shnCgz","download","#f9a100","beginPath","display","2943080OevWFS","4-5小时","FRAMEBUFFER","createImageData","Cartographic","setAttribute","height","createElement","#f50205","href","492705XJCrFQ","canvas","click","944GZsDqo","toDataURL","_gl","src","toCartesian","context","fillStyle","width","length","body","#06f4f7"];return(t=function(){return e})()}function n(e,t){var n=i;const a=16*e[n(367)];var s=document[n(353)](n(357));s.width=a,s[n(405)]=16;var r=s[n(375)]("2d");r[n(397)]();for(let t=0;t<e.length;t++){let i=e[t][n(379)],a=16*t,s=0;r[n(365)]=i,r[n(383)](a,s,16,16)}var o=new Image;return o[n(362)]=s[n(360)](),o}function i(e,n){var a=t();return(i=function(e,t){return a[e-=353]})(e,n)}function a(){const e=["_transformPositionUvToWorld","context","ClearCommand","init","_interval","readPixels","percentageChanged","createViewportQuadCommand","WHITE","center","ADDITIVE_BLEND","defined","pickPosition","Pass","Renderbuffer","601771nxgwmB","fetchImage","wgs84ToWindowCoordinates","_starttime","clone","replace","SceneTransforms","clockwisePositions","createIfNeeded","IDENTITY","uniformState","Cartesian2","createShadowMap","16ocyzbK","_uniforms","fromPoints","then","Transforms","OPAQUE","viewer","Framebuffer","framebuffer","negate","ClippingPlaneCollection","inverseTransformation","vtxfTexture","pass","computeWindingOrder2D","normalOffsetScale","globeDepth","500vfrADj","1593SZnEkC","clippingPlanesMatrix","commandList","camera","_index","_count","vec4 position = czm_windowToEyeCoordinates(fragCoord);","changed","sunDirectionWC","sources","slice","3413711IOTAEu","LOG_DEPTH","getClippingFunction","shadowMap","inverseTranspose","_gl","createPlane","_primitiveBias","_fb","Cartesian3","update","length","clock","push","refresh","reverse","_distance","destoryCommand","shadowMaps","28588thOCNJ","blending","isDestroyed","src","normalize","1962184FQFptP","multiplyTransformation","shaderProgram","_cameraPosition","{clipshader}","PolygonPipeline","maximumDistance","Plane","Texture","addPostProcessStageX","DEPTH_STENCIL","OVERLAY","1399812ZzpPbP","clippingPlanes","80940bgnlOL","\nvarying vec2 v_textureCoordinates;\nuniform sampler2D colorTexture;   //这里可以不用colortexture，仅适用depthtexture即可\nuniform sampler2D depthTexture;\nuniform sampler2D shadowMap_texture;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec3 shadowMap_lightDirectionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\n\nuniform float helsing_alpha;\nuniform vec4 helsing_visibleAreaColor;\nuniform vec4 helsing_invisibleAreaColor;\n\n\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = 0.3;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    float visibility = _czm_shadowDepthCompare(shadowMap, uv, depth);\n\n    return visibility;\n}\n\nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n  \n} \n\n\nvoid main(){\n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    //float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n    // if(currentDepth.r >= 1.0){\n    //     gl_FragColor = color;\n    //     return;\n    // }\n    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n    \n    vec4 positionEC = toEye(v_textureCoordinates,depth);\n    depth = -positionEC.z;\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    //shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n\n    //shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015);\n\n    float maxDepth = shadowMap_cascadeSplits[1].w;\n    // Stop early if the eye depth exceeds the last cascade \n          if (depth > maxDepth) \n          { \n              gl_FragColor.rgb=color.rgb;\n              gl_FragColor.a=color.a;\n              return; \n          }\n          // Get the cascade based on the eye-space depth \n          vec4 weights = czm_cascadeWeights(depth); \n          // Apply normal offset\n          float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n          applyNormalOffset(positionEC, normalEC, nDotL); \n          // Transform position into the cascade \n          vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n          // Get visibility \n          shadowParameters.texCoords = shadowPosition.xy; \n          shadowParameters.depth = shadowPosition.z; \n          shadowParameters.nDotL = nDotL; \n          float visibility =  czm_shadowVisibility(shadowMap_texture, shadowParameters); \n          // Fade out shadows that are far away \n          float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n          float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n          visibility = mix(visibility, 1.0, fade); \n          //color.rgb*=visibility;\n          gl_FragColor.rgb=color.rgb;\n          gl_FragColor.a=color.a;\n          //gl_FragColor *= czm_cascadeColor(weights);;\n          //gl_FragColor = mix(color, helsing_visibleAreaColor, helsing_alpha);\n\n          float rd=0.020833;\n           vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n           vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n\n     // 可视域模式\n     if (visibility > 0.90){\n      gl_FragColor = helsing_visibleAreaColor;\n  }\n  else{\n      gl_FragColor = helsing_unvisibleAreaColor;\n  }\n    \n}","texture","ENABLE_CLIPPING_PLANES","_clearColorCommand","canvas","Color","_shadowMapTexture","_lightPositionEC","CLOCKWISE","GREEN","edgeWidth","now","_textureSize","setHours","ShaderSource","_lastviewportQuadCommand","_shadowMapCamera","modelMatrix","_clippingPlanes","Resource","checkFramebufferStatus","_clippingPlanesState","JulianDate","distance","ShadowMap","colorFramebufferManager","_ready","FRAMEBUFFER","destroy","multiply","\nuniform sampler2D colorTexture;\nuniform sampler2D legendTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\n//多边形裁切\nuniform highp sampler2D u_clippingPlanes;\nuniform mat4 u_clippingPlanesMatrix;\nuniform vec4 u_clippingPlanesEdgeStyle;\n\n\nvec4 toEye( vec2 uv,  float depth){\n  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera =posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth( vec4 depth){\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\n\n{clipshader}\n\nvoid main()\n{\n\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\n\n    \n\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\n\n    if (clipDistance < clippingPlanesEdgeWidth)\n    {\n        vec4 finalColor = clippingPlanesEdgeColor;\n    }\n\n\n  //取colortexture的r通道\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 dcolor= texture2D(legendTexture, vec2(color.r,0.0));\n\n    gl_FragColor = vec4(dcolor.rgb,1.0);\n}","float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n      vec4 position = toEye(v_textureCoordinates,depth);","RenderbufferFormat","Matrix4","visibleAreaColor","_lightDirectionEC","_colorTextures","width","legends","alpha","124130ILjCDH","Cartesian4","eastNorthUpToFixedFrame","getColorTexture","_cascadeDistances","scene","view","getOriginCoordinateSystemPoint","RenderState","currentTime","invisibleAreaColor","positions","getDepthStencilTexture","BlendingState","projectPointsOntoPlane","_legendimage","fromCache","edgeColor","direction","ClippingPlane","internalFormat","bufferView","parseInt","_viewportQuadCommand","fromPointNormal","renderState"];return(a=function(){return e})()}!function(e,t){for(var n=i,a=e();;)try{if(388008===parseInt(n(376))/1*(-parseInt(n(388))/2)+-parseInt(n(371))/3+parseInt(n(399))/4+-parseInt(n(389))/5*(parseInt(n(384))/6)+parseInt(n(377))/7*(-parseInt(n(359))/8)+parseInt(n(356))/9*(-parseInt(n(394))/10)+parseInt(n(374))/11*(parseInt(n(382))/12))break;a.push(a.shift())}catch(e){a.push(a.shift())}}(t);const s=r;function r(e,t){const n=a();return(r=function(e,t){return n[e-=167]})(e,t)}!function(e,t){const n=r,i=e();for(;;)try{if(614602===-parseInt(n(202))/1+-parseInt(n(268))/2+-parseInt(n(282))/3+-parseInt(n(263))/4*(parseInt(n(232))/5)+-parseInt(n(280))/6+-parseInt(n(244))/7*(-parseInt(n(215))/8)+-parseInt(n(233))/9*(-parseInt(n(323))/10))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(a);const o=s(283),l=s(313);class c{constructor(e,t){const n=s;this.createShadowMap(e,t),this[n(190)](t),this.addPostProcessStageX()}updateClippingPlanes(e,t){const n=s,i=e[n(281)];if(!defined(i))return!1;i[n(254)](t);const{clippingPlanesState:a,enabled:r}=i;if(r){const t=e[n(216)];t.clippingPlanesTexture=i[n(284)],t[n(234)]=Matrix4.transpose(Matrix4[n(269)](Matrix4.inverse(i.modelMatrix,t[n(234)]),e[n(187)],t[n(234)]),t[n(234)])}return(e[n(304)]!==a||e._clippingPlanesEnabled!==r)&&(e[n(304)]=a,e._clippingPlanesEnabled=r,!0)}[s(214)](e,t){const n=s;this[n(221)]=e,this[n(317)]=t.visibleAreaColor||Cesium[n(288)][n(292)],this[n(171)]=t[n(171)]||Cesium[n(288)].RED,this.alpha=.5}createClippingPlane(e){const t=s;let n=e,i=Cesium.BoundingSphere[t(217)](e)[t(196)],a=Cesium[t(219)][t(325)](i),r=Cesium[t(316)][t(226)](a,new(Cesium[t(316)])),o=n[t(255)],l=[];for(let e=0;e<o;++e){let i=(e+1)%o,a=this[t(250)](n[e],n[i],r);l[t(257)](a)}return new(Cesium[t(225)])({planes:l,modelMatrix:a,unionClippingRegions:!0})}[s(199)](e){const t=s;var n=viewer[t(328)][t(188)];const i=n[t(249)];if(i[t(303)](i[t(310)])===i.FRAMEBUFFER_COMPLETE){let i=Cesium[t(208)][t(204)](viewer[t(328)],e);return n[t(192)]({x:Number.parseInt(i.x),y:Number[t(183)](i.y),width:1,height:1,framebuffer:this[t(252)]})[0]*(this[t(238)]/6)/255}return-1}[s(250)](e,t,n){const i=s,a=this[i(168)](e,n),r=this[i(168)](t,n),o=new(Cesium[i(253)])(0,0,-10),l=Cesium.Cartesian3.subtract(r,a,new(Cesium[i(253)]));let c=Cesium[i(253)].cross(l,o,new(Cesium[i(253)]));c=Cesium[i(253)][i(267)](c,c);const m=Cesium[i(275)][i(185)](a,c);return new(Cesium[i(180)])(m.normal,m[i(306)])}getOriginCoordinateSystemPoint(e,t){const n=s;return Cesium[n(316)].multiplyByPoint(t,e,new(Cesium[n(253)])(0,0,0))}[s(277)](){const e=s,t=this,n=this[e(247)][e(251)];let i=viewer.scene[e(167)][e(231)][e(308)];const a=i[e(326)](0),r=i[e(173)](),l=new(Cesium[e(297)])({defines:[e(245)],sources:[o]});var c=viewer[e(328)][e(188)][e(194)](l,{uniformMap:{colorTexture:function(){return a},depthTexture:function(){return r},helsing_alpha:function(){return t[e(322)]},helsing_visibleAreaColor:function(){return t[e(317)]},helsing_invisibleAreaColor:function(){return t.invisibleAreaColor},shadowMap_cascadeSplits:function(){return t[e(247)]._cascadeSplits},shadowMap_cascadeMatrices:function(){return t[e(247)]._cascadeMatrices},shadowMap_cascadeDistances:function(){const n=e;return t[n(247)][n(327)]},shadowMap_texture:function(){const n=e;return t[n(247)][n(289)]},shadowMap_matrix:function(){return t.shadowMap._shadowMapMatrix},shadowMap_lightPositionEC:function(){const n=e;return t[n(247)][n(290)]},shadowMap_lightDirectionEC:function(){const n=e;return t[n(247)][n(318)]},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const i=e,a=new(Cesium[i(213)]);return a.x=1/t[i(247)][i(295)].x,a.y=1/t[i(247)]._textureSize.y,Cesium[i(324)].fromElements(a.x,a.y,n.depthBias,n.normalShadingSmooth,new(Cesium[i(324)]))},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){const i=e;return Cesium[i(324)].fromElements(n[i(230)],t[i(247)][i(260)],t[i(247)][i(274)],.3,new(Cesium[i(324)]))}}});c[e(228)]=Cesium.Pass.OVERLAY,this[e(184)]=c;var m=Cesium[e(169)].fromCache({});const h=Cesium[e(206)](Cesium[e(174)][e(197)],!0),d=new Cesium.Color(0,0,0,0);h.color=d,m[e(264)]=h,this._viewportQuadCommand[e(186)]=m,this._viewportQuadCommand[e(223)]=t[e(252)],this._ready=!0}[s(209)](e){const t=s;let n=Cesium.EllipsoidTangentPlane[t(217)](e)[t(175)](e);return Cesium[t(273)][t(229)](n)===Cesium.WindingOrder[t(291)]&&(e=e[t(243)]()[t(259)]()),e}[s(190)](e){const t=s;let i=this,a=new Date(Date[t(294)]());a[t(296)](8,0,0),this._index=0,this._count=48,this[t(191)]=10,a=Cesium.JulianDate.fromDate(a),this[t(205)]=a;const r=viewer.scene[t(167)][t(231)][t(308)][t(173)]();let o=new(Cesium[t(307)])({context:viewer.scene[t(188)],lightCamera:viewer[t(328)][t(299)],enabled:!0});this[t(247)]=o,this[t(247)].enabled=!0;var c=viewer.scene.context,m=new(Cesium[t(222)])({context:c,colorTextures:[new(Cesium[t(276)])({context:c,width:c.canvas[t(320)],height:c[t(287)].height})],depthStencilRenderbuffer:new(Cesium[t(201)])({context:c,width:c[t(287)][t(320)],height:c[t(287)].height,format:Cesium[t(315)][t(278)]})});this._fb=m,e[t(321)]&&(this[t(176)]=n(e[t(321)]),Cesium[t(302)][t(210)](this[t(176)][t(266)])[t(203)]()[t(218)]((function(e){const n=t;var a,s=viewer[n(328)][n(188)];a=Cesium[n(198)](e[n(181)])?new(Cesium[n(276)])({context:s,pixelFormat:e[n(181)],width:e[n(320)],height:e.height,source:{arrayBufferView:e[n(182)]}}):new(Cesium[n(276)])({context:s,source:e}),i[n(227)]=a})));var h=Cesium.RenderState[t(177)]({});const d=new(Cesium[t(297)])({sources:[l],defines:[t(245)]});if(e.positions){e.positions=this[t(209)](e.positions),this[t(301)]=this.createClippingPlane(e[t(172)]),d.defines.push(t(285));let n=t(239),i=t(314),a=Cesium[t(246)](this._clippingPlanes,viewer[t(328)].context)[t(207)](n,i),s=l[t(207)](t(272),a);d[t(242)][0]=s}const u=new(Cesium[t(316)]),p=new(Cesium[t(316)]);var f=c[t(194)](d,{uniformMap:{colorTexture:function(){const e=t;return i._fb[e(319)][0]},depthTexture:function(){return r},legendTexture:function(){return i.vtxfTexture},u_clippingPlanes:function(){const e=t,n=i[e(301)];return Cesium.defined(n)&&Cesium[e(198)](n.texture)?n[e(284)]:viewer[e(328)][e(188)].defaultTexture},u_clippingPlanesMatrix:function(){const e=t,n=i[e(301)],a=Cesium[e(198)](n)?Cesium.Matrix4[e(312)](viewer.scene[e(188)][e(212)][e(167)],n[e(300)],u):Cesium[e(316)][e(211)];return Cesium[e(316)][e(248)](a,p)},u_clippingPlanesEdgeStyle:function(){const e=t,n=i[e(301)];if(Cesium.defined(n)){const t=n[e(178)];return t[e(322)]=n[e(293)],t}return Cesium.Color[e(195)]}},renderState:h});f[t(228)]=Cesium.Pass[t(279)],this[t(298)]=f,this[t(286)]=new(Cesium[t(189)])({color:new(Cesium[t(288)])(0,0,0,0),pass:Cesium[t(200)][t(220)],owner:this,framebuffer:this._fb}),this[t(271)]=new(Cesium[t(253)]),viewer[t(328)][t(236)][t(240)].addEventListener((()=>{i[t(237)]=0})),viewer[t(328)][t(236)][t(193)]=.01,this[t(309)]=!1}[s(258)](){this._index=0}[s(254)](e){const t=s;if(this._ready){var n=this[t(301)];if(Cesium[t(198)](n)&&n.enabled&&n[t(254)](e),0==this._index&&e[t(235)][t(257)](this[t(286)]),this[t(237)]<this[t(238)]){let n=Cesium[t(305)].addMinutes(this[t(205)],10*this[t(237)],new(Cesium[t(305)]));viewer[t(256)][t(170)]=n;const i=viewer[t(328)][t(188)][t(212)];Cesium.Cartesian3[t(224)](i[t(241)],viewer[t(328)][t(299)][t(179)]),e[t(262)][t(257)](this[t(247)]),this[t(184)]&&e.commandList[t(257)](this._viewportQuadCommand),this._index++}else this[t(298)]&&e[t(235)][t(257)](this._lastviewportQuadCommand)}}[s(265)](){return!1}[s(261)](e){const t=s,n=e;defined(n)&&(n[t(270)]=n[t(270)]&&n[t(270)][t(311)]())}destroy(){const e=s;return this[e(261)](this[e(298)]),this[e(261)](this[e(184)]),Cesium.destroyObject(this)}clear(){}}function m(e,t){const n=h();return(m=function(e,t){return n[e-=342]})(e,t)}function h(){const e=["2364462nkpSuA","fromColor","tollerance","174864PhrTNj","Primitive","Cartesian3","length","RED","MultiPolygon","features","ClassificationPrimitive","Color","GeometryInstance","35ErrtMz","438236adpIho","geometry","ColorGeometryInstanceAttribute","flat","341597lpJdvT","PerInstanceColorAppearance","entities","EllipsoidSurfaceAppearance","1977088UqdJVI","type","fromDegreesArray","CESIUM_3D_TILE","coordinates","15207NhMoFy","161OQIupy","_polygonHierarchy","withAlpha","maxcount","ClassificationType","VERTEX_FORMAT","map","41070TMrFQV","Polygon"];return(h=function(){return e})()}!function(e,t){const n=m,i=e();for(;;)try{if(263613===parseInt(n(348))/1+parseInt(n(344))/2+parseInt(n(357))/3+-parseInt(n(352))/4+parseInt(n(343))/5*(-parseInt(n(365))/6)+-parseInt(n(358))/7*(-parseInt(n(370))/8)+-parseInt(n(367))/9)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(h);const d=u;function u(e,t){const n=p();return(u=function(e,t){return n[e-=251]})(e,t)}function p(){const e=["softShadows","18QjhKNc","_usesDepthTexture","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","parseInt","   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","VERSION","); \n","_numberOfCascades","} \nvec3 getNormalEC() \n{ \n","createShadowReceiveFragmentShader","_primitiveBias","_terrainBias","    return normalize(","ENABLE_DAYNIGHT_SHADING","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","split","ShaderSource","slice","USE_NORMAL_SHADING","ENABLE_VERTEX_LIGHTING","debugCascadeColors","_isPointLight","sources","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","czm_shadow_receive_main","8YYBPGO","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","37642dlREMs","_pointBias","USE_CUBE_MAP_SHADOW","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","createShadowReceiveVertexShader","} \n","180902IGPTdu","length","normalShadingSmooth","SHADOW_MAP","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","16542uPuNcj",", 1.0); \n","2520045QPNeFX","ShadowMapShader","findPositionVarying","GENERATE_POSITION","2346516pOGzsm","6032007MelfBk","    return vec3(1.0); \n","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","1075440RYvEAA","USE_SOFT_SHADOWS","replaceMain","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","_polygonOffsetSupported","uniform sampler2D shadowMap_texture; \n","USE_SHADOW_DEPTH_TEXTURE","defines","_isSpotLight","normalShading","uniform samplerCube shadowMap_textureCube; \n","normalOffset","    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n","    return vec4(","USE_NORMAL_SHADING_SMOOTH","push","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","findNormalVarying","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","623YFxfIN"];return(p=function(){return e})()}!function(e,t){const n=u,i=e();for(;;)try{if(435456===parseInt(n(312))/1+-parseInt(n(318))/2*(parseInt(n(285))/3)+-parseInt(n(258))/4+parseInt(n(254))/5+-parseInt(n(252))/6*(-parseInt(n(283))/7)+-parseInt(n(310))/8*(-parseInt(n(259))/9)+parseInt(n(262))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(p);const f=Cesium[d(301)],C=Cesium.defined,w=Cesium[d(255)];let g;function _(e,t){const n=d;e?function(e){const t=d,n=Number[t(288)](Cesium[t(290)][t(300)](".")[1])>=101;g=w[t(294)],n?(w[t(316)]=function(e,n,i){const a=t,s=e[a(270)][a(302)](0),r=e[a(307)][a(302)](0);return s[a(278)](a(321)),n&&(i?s[a(278)]("GENERATE_POSITION_AND_NORMAL"):s[a(278)](a(257))),new f({defines:s,sources:r})},w[t(294)]=function(e,n,i,a,s){const r=t,o=f.findNormalVarying(e),l=!a&&C(o)||a&&s,c=f[r(256)](e),m=C(c),h=n[r(286)],d=n[r(267)],u=n[r(306)],p=n[r(271)],w=n._numberOfCascades>1,g=n.debugCascadeColors,_=n[r(284)],v=u?n._pointBias:a?n[r(296)]:n[r(295)],x=e[r(270)][r(302)](0),P=e.sources[r(302)](0),y=P.length;for(let e=0;e<y;++e)P[e]=f.replaceMain(P[e],r(309));u?x[r(278)](r(314)):h&&x[r(278)](r(269)),_&&!u&&x.push("USE_SOFT_SHADOWS"),w&&i&&a&&(l?x[r(278)](r(304)):x[r(278)](r(298))),i&&v[r(272)]&&l&&(x[r(278)](r(303)),v[r(320)]>0&&x[r(278)]("USE_NORMAL_SHADING_SMOOTH"));let E,D="";return D+=r(u?273:268),E=m?r(276)+c+r(253):r(266),D+=r(279)+E+r(293)+(l?r(297)+o+"); \n":r(260))+r(261)+(v[r(274)]&&l?r(287):"")+"} \n",D+=r(311),D+=r(265),a?D+=r(282):d||(D+=r(251)),D+=u?r(308):p?r(322):w?r(299)+(g?"    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n":""):r(315),D+="   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ",P[r(278)](D),new f({defines:x,sources:P})}):w.createShadowReceiveFragmentShader=function(e,n,i,a,s){const r=t,o=f[r(281)](e),l=!a&&C(o)||a&&s,c=f[r(256)](e),m=C(c),h=n[r(286)],d=n[r(267)],u=n[r(306)],p=n._isSpotLight,w=n[r(292)]>1,g=n[r(305)],_=n.softShadows,v=u?n[r(313)]:a?n._terrainBias:n[r(295)],x=e[r(270)][r(302)](0),P=e.sources[r(302)](0),y=P[r(319)];for(let e=0;e<y;++e)P[e]=f[r(264)](P[e],r(309));u?x[r(278)](r(314)):h&&x[r(278)](r(269)),_&&!u&&x[r(278)](r(263)),w&&i&&a&&(l?x[r(278)](r(304)):x[r(278)](r(298))),i&&v[r(272)]&&l&&(x[r(278)]("USE_NORMAL_SHADING"),v[r(320)]>0&&x[r(278)](r(277)));let E,D="";return D+=u?"uniform samplerCube shadowMap_textureCube; \n":r(268),E=m?r(276)+c+r(253):r(266),D+=r(280)+E+"} \nvec3 getNormalEC() \n{ \n"+(l?r(297)+o+r(291):r(260))+"} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n"+(v[r(274)]&&l?r(287):"")+r(317),D+="void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",D+=r(265),a?D+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":d||(D+=r(251)),D+=u?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":p?r(322):w?r(299)+(g?r(275):""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",D+=r(289),P[r(278)](D),new f({defines:x,sources:P})}}():w[n(294)]=g}const v=P;function x(){const e=["init","height","EllipsoidSurfaceAppearance","VERTEX_FORMAT","FRAMEBUFFER_COMPLETE","3938942RsPOEj","_option","setHeight","modelViewProjection","positions","canvas","divideByScalar","2frWlmt","setHours","width","BlendingState","parseInt","primitives","realMode","Matrix4","bufferView","checkFramebufferStatus","setSunAndMoonDirections","toCartesian","_isready","withAlpha","normalize","Cartographic","_lightCamera","Texture","_count","terrainProvider","TextureMinificationFilter","fromPoints","fromCartesian","multiply","update","flyToBoundingSphere","833177ltrSwj","_extraCmds","Resource","_realMode","_index","ClearCommand","_cameraPosition","readPixels","commandList","370284TSxbeK","TextureMagnificationFilter","ColorGeometryInstanceAttribute","polygonCmds","color","OPAQUE","now","Cartesian4","fetchImage","ShadowMap","computeSunPositionInEarthInertialFrame","add","DefaultImageId","DEPTH_STENCIL","_legendimage","scaleHeight","legend_0","samplePoints","internalFormat","initx","Transforms","defined","Color","Cartesian2","RenderState","renderState","113888DJDYzB","Cartesian3","context","src","clear","RenderbufferFormat","push","clampground","polygonprimitrive","addMinutes","RZType","Simon1994PlanetaryPositions","fromDate","GeometryInstance","inverse","forEach","Material","wgs84ToWindowCoordinates","dirty","image_1","modelMatrix","addMaterial","map","ALPHA_BLEND","camera","BoundingSphere","readyPromise","show","receiveCommand","Renderbuffer","_starttime","RZType2","then","setSamplePoints","eastNorthUpToFixedFrame","_samplePoints","direction","uniformMap","fromCssColorString","createFramebuffer","remove","Pass","center","FRAMEBUFFER","NEAREST","Framebuffer","sampleTerrainMostDetailed","fromCache","_context","#ffffff","sampleCallback","2646960kwUzlA","_materialCache","pickPosition","clone","equals","_sampleCallback","_shadowmap","vtxfTexture","HeadingPitchRange","_isSampleDone","position","scene","Camera","SceneTransforms","4621585edbnxJ","_clearColorCommand","multiplyByVector","fromTranslation","legends","PolygonHierarchy","4eeufJE","createReceiveDerivedCommand","63xPmmYt","27401280PkepnW","createIfNeeded","Matrix3","resolve","JulianDate","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","_fb","receiveShadows","centerWC","time","shadowMaps","PolygonGeometry","switchToPerspectiveFrustum","uniformState"];return(x=function(){return e})()}function P(e,t){const n=x();return(P=function(e,t){return n[e-=103]})(e,t)}!function(e,t){const n=P,i=e();for(;;)try{if(500330===-parseInt(n(123))/1*(-parseInt(n(258))/2)+parseInt(n(209))/3+parseInt(n(229))/4*(parseInt(n(223))/5)+-parseInt(n(132))/6+parseInt(n(251))/7+-parseInt(n(158))/8*(-parseInt(n(231))/9)+-parseInt(n(232))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(x);const y=v(237);Cesium[v(174)][v(168)]="RZType",Cesium.Material[v(210)][v(179)](Cesium[v(174)].RZType,{fabric:{type:Cesium.Material[v(168)],uniforms:{image:Cesium.Material[v(144)],legend:Cesium[v(174)][v(144)]},source:y},translucent:function(e){return!0}}),Cesium.Material[v(189)]=v(189),Cesium[v(174)][v(210)][v(179)](Cesium[v(174)][v(189)],{fabric:{type:Cesium[v(174)].RZType2,uniforms:{image:Cesium.Material[v(144)],legend:Cesium[v(174)][v(144)]},source:"\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,materialInput.st).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n"},translucent:function(e){return!0}});class E{constructor(e,t){const n=v;let i=this;if(this[n(252)]=t,this[n(193)]=t[n(149)],this._sampleCallback=t[n(208)],this._isSampleDone=!1,this[n(126)]=null!=t.realMode&&t[n(103)],t[n(165)]){t[n(255)]=t.positions[n(180)]((e=>Cesium[n(112)][n(119)](e)));const a=Cesium[n(204)](e[n(116)],t[n(255)]);Promise[n(235)](a)[n(190)]((function(a){const s=n;let r=-9999;a=a[s(180)]((e=>(e[s(247)]>r&&(r=e.height),Cesium.Cartographic[s(108)](e)))),t[s(247)]=r,t.positions=a,i.initx(e,t)}))}else i[n(151)](e,t)}[v(253)](e){const t=v;this[t(166)]&&this[t(147)](e)}[v(211)](e){const t=v;var n=viewer[t(220)][t(160)];const i=n._gl;if(i[t(106)](i[t(201)])===i[t(250)]){let i=Cesium[t(222)][t(175)](viewer[t(220)],e);return n[t(130)]({x:Number[t(262)](i.x),y:Number.parseInt(i.y),width:1,height:1,framebuffer:this._fb})[0]*(this[t(115)]/6)/255}return-1}refresh(){this[v(127)]=0}[v(147)](e){const t=v;let n=Cesium[t(152)][t(192)](this[t(240)]),i=Cesium[t(104)][t(172)](n,new(Cesium[t(104)])),a=e-this.center[t(247)],s=Cesium.Matrix4[t(226)](new Cesium.Cartesian3(0,0,a)),r=Cesium.Matrix4[t(120)](s,i,new(Cesium[t(104)]));this[t(166)][t(178)]=Cesium[t(104)][t(120)](n,r,new Cesium.Matrix4)}[v(151)](e,t){const n=v;let i=this;if(this[n(126)])this[n(246)](e,t);else{let a=t.positions[n(180)]((e=>{const i=n;let a=Cesium[i(112)][i(119)](e);return a[i(247)]=t[i(247)],Cesium.Cartographic[i(108)](a)})),s=Cesium[n(183)][n(118)](a);e[n(220)].camera[n(244)](),e[n(220)].camera[n(122)](s,{offset:new(Cesium[n(217)])(0,-1.57,0),complete:function(){i[n(246)](e,t)}})}}[v(246)](e,t){const i=v;let a=this;this.show=!0,this.secondsOfDay=0,this[i(146)]="";var s=e[i(220)][i(160)];if(t[i(227)]&&(this[i(146)]=n(t[i(227)]),Cesium[i(125)][i(233)](this[i(146)][i(161)])[i(140)]().then((function(t){const n=i;var s,r=e[n(220)][n(160)];s=Cesium.defined(t[n(150)])?new(Cesium[n(114)])({context:r,pixelFormat:t[n(150)],width:t[n(260)],height:t.height,source:{arrayBufferView:t[n(105)]}}):new(Cesium[n(114)])({context:r,source:t}),a.vtxfTexture=s}))),this[i(129)]=new(Cesium[i(159)]),t[i(255)]){var r=new(Cesium[i(203)])({context:s,colorTextures:[new(Cesium[i(114)])({context:s,width:s.canvas[i(260)],height:s[i(256)].height})],depthStencilRenderbuffer:new(Cesium[i(187)])({context:s,width:s[i(256)][i(260)],height:s[i(256)].height,format:Cesium[i(163)][i(145)]})});let n;if(this[i(238)]=r,!this[i(126)]){let a=t[i(255)][i(180)]((n=>{const a=i;let s=Cesium[a(112)].fromCartesian(n);s[a(247)]=t[a(247)],n=Cesium[a(112)].toCartesian(s);let r=Cesium[a(104)].multiplyByVector(e[a(220)][a(160)][a(245)][a(254)],new(Cesium[a(139)])(n.x,n.y,n.z,1),new(Cesium[a(139)])),o=Cesium[a(139)][a(143)](Cesium.Cartesian4[a(257)](Cesium[a(139)].divideByScalar(r,r.w,new Cesium.Cartesian4),2,new(Cesium[a(139)])),new(Cesium[a(139)])(.5,.5),new(Cesium[a(139)]));return o.x=o.x>1?1:o.x,o.x=o.x<0?0:o.x,o.y=o.y>1?1:o.y,o.y=o.y<0?0:o.y,new(Cesium[a(155)])(o.x,o.y)}));n=new(Cesium[i(228)])(a)}var o=new(Cesium[i(228)])(t[i(255)]);let a;a=n?new(Cesium[i(243)])({polygonHierarchy:o,height:t[i(247)],vertexFormat:Cesium[i(248)][i(249)],textureCoordinates:n}):new Cesium.PolygonGeometry({polygonHierarchy:o,height:t.height,vertexFormat:Cesium[i(248)][i(249)]}),this[i(200)]=Cesium.BoundingSphere[i(118)](t[i(255)])[i(200)],this[i(200)]=Cesium[i(112)].fromCartesian(this.center),this.center[i(247)]=t[i(247)],this[i(240)]=Cesium.Cartographic.toCartesian(this[i(200)]);var l=new(Cesium[i(171)])({geometry:a,attributes:{color:Cesium[i(134)].fromColor(Cesium[i(154)][i(196)](i(207))[i(110)](0))}});let c=new Cesium.Primitive({geometryInstances:l,asynchronous:!1,appearance:new Cesium.EllipsoidSurfaceAppearance({material:new Cesium.Material({fabric:{type:this[i(126)]?i(168):i(189),uniforms:{legend:this[i(146)]}},minificationFilter:Cesium[i(117)][i(202)],magnificationFilter:Cesium[i(133)].NEAREST})})});this[i(166)]=c;let m=new Date(Date[i(138)]());m[i(259)](16,0,0),this[i(127)]=0,this[i(115)]=48,m=Cesium[i(236)][i(170)](m),this[i(188)]=m;let h=this.setSunAndMoonDirections({time:m}),d=new Cesium.ShadowMap({context:e[i(220)][i(160)],lightCamera:h,enabled:!0});this[i(215)]=d,this[i(224)]=new(Cesium[i(128)])({color:new(Cesium[i(154)])(0,0,0,0),pass:Cesium[i(199)][i(137)],owner:this,framebuffer:this._fb}),this[i(109)]=!1,Cesium[i(156)][i(205)]({blending:Cesium[i(261)][i(181)]});let u=this;this[i(166)][i(184)][i(190)]((t=>{const n=i;_(!0);let a=t._colorCommands,s=a.map((t=>{const n=P;t[n(239)]=!0;let i=Cesium[n(141)][n(230)]([u[n(215)]],t,!0,e.scene[n(206)],{});i[n(186)][n(239)]=!1;const a=Cesium[n(212)](Cesium[n(261)].ADDITIVE_BLEND,!0),s=new Cesium.Color(0,0,0,0);return a[n(136)]=s,i[n(186)][n(157)].blending=a,i[n(186)].pass=7,i[n(186)].framebuffer=u._fb,i[n(186)]}));u[n(124)]=s,_(!1),u[n(135)]=a[n(180)]((e=>{const t=n;let i=Cesium[t(212)](e);return i[t(195)][t(177)]=function(){return r._colorTextures[0]},i[t(195)][t(148)]=function(){return u[t(216)]},i})),u[n(166)][n(185)]=!1,u[n(109)]=!0})),e[i(220)][i(263)][i(143)](this[i(166)])}}[v(197)](){const e=v;var t=viewer[e(220)][e(160)];return new(Cesium[e(203)])({context:t,colorTextures:[new(Cesium[e(114)])({context:t,width:t[e(256)][e(260)],height:t[e(256)][e(247)]})],depthStencilRenderbuffer:new(Cesium[e(187)])({context:t,width:t[e(256)][e(260)],height:t.canvas[e(247)],format:Cesium.RenderbufferFormat[e(145)]})})}[v(191)](e){this[v(193)]=e,this._isSampleDone=!1}[v(121)](e){const t=v;if(!this[t(185)])return;let n=this;if(this[t(109)]&&Cesium[t(153)](this[t(124)]))if(!e[t(182)][t(219)][t(213)](this[t(129)])&&this[t(126)]&&(this._index=0,this[t(218)]=!1,this._cameraPosition=Cesium[t(212)](e[t(182)].position)),0==this[t(127)]&&e[t(131)][t(164)](this[t(224)]),this[t(127)]<this._count){let i=Cesium[t(236)][t(167)](this[t(188)],10*this._index,new(Cesium[t(236)])),a=this[t(107)]({time:i});this._shadowmap[t(113)][t(219)]=a[t(219)],this[t(215)][t(113)][t(194)]=a[t(194)],this[t(215)][t(176)]=!0,e[t(242)][t(164)](this._shadowmap),this[t(124)][t(173)]((e=>{const i=t;e.modelMatrix=n[i(166)][i(178)]})),e[t(131)].push(...this[t(124)]),this[t(127)]++}else{if(this[t(193)]&&this[t(214)]&&!this[t(218)]){let e=this[t(193)][t(180)]((e=>Cesium.Cartographic[t(119)](e)));var a=function(e,t,n){var a=i,s=viewer.scene[a(364)];const r=s[a(361)];if(r[a(380)](r[a(401)])===r[a(372)])return t.map((t=>{var i=a;null!=n&&(t[i(405)]=n),t=Cesium[i(403)][i(363)](t);let r=Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene,t);return s.readPixels({x:Number.parseInt(r.x),y:Number[i(391)](r.y),width:1,height:1,framebuffer:e})}))}(this[t(238)],e,this[t(252)][t(247)]);this[t(214)](a),this[t(218)]=!0}this[t(135)][t(173)]((e=>{const i=t;e[i(178)]=n.polygonprimitrive[i(178)]})),e[t(131)][t(164)](...this[t(135)])}}[v(107)](e){const t=v;let n=new(Cesium[t(159)]),i=new(Cesium[t(234)]);Cesium[t(153)](Cesium[t(152)].computeIcrfToFixedMatrix(e[t(241)],i))||(i=Cesium[t(152)].computeTemeToPseudoFixedMatrix(e[t(241)],i));let a=Cesium[t(169)][t(142)](e.time,n);Cesium[t(234)][t(225)](i,a,a);let s=new Cesium.Cartesian3;Cesium.Cartesian3[t(111)](a,s);let r=new(Cesium[t(221)])(viewer[t(220)]);return r[t(219)]=a,r[t(194)]=s,r}[v(162)](){}destory(){const e=v;this[e(166)]&&viewer[e(220)].primitives[e(198)](this[e(166)])}}function D(e,t){var n=S();return(D=function(e,t){return n[e-=466]})(e,t)}function S(){var e=["1195hjrDxJ","1155cdIvJA","393AemByY","9CETTCR","12564zZXmVU","2607256dbhMjt","7502ZEgGts","90288AGpQtu","3868940yjQRhw","98608XleDyA","196ahDgxx","1964SaArai"];return(S=function(){return e})()}!function(e,t){for(var n=D,i=e();;)try{if(305946===parseInt(n(468))/1+-parseInt(n(477))/2*(-parseInt(n(473))/3)+-parseInt(n(470))/4*(-parseInt(n(471))/5)+parseInt(n(466))/6*(parseInt(n(469))/7)+-parseInt(n(476))/8*(parseInt(n(474))/9)+-parseInt(n(467))/10+-parseInt(n(472))/11*(parseInt(n(475))/12))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(S),e.RZPrimitive=c,e.RZPrimitiveX=E}));
