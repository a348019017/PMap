!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pmap_rz={})}(this,(function(e){"use strict";function t(){var e=["#0000f6","879306DguQfL","FRAMEBUFFER_COMPLETE","none","22QfhBQd","getContext","261862bncCji","26761XxBAHW","appendChild","color","checkFramebufferStatus","2-3小时","7995180upZuqw","fillRect","12348sWvaMi","style","3-4小时","5-6小时","2qbvWUp","840ZssGBm","data","parseInt","7小时以上","小于1小时","60shnCgz","download","#f9a100","beginPath","display","2943080OevWFS","4-5小时","FRAMEBUFFER","createImageData","Cartographic","setAttribute","height","createElement","#f50205","href","492705XJCrFQ","canvas","click","944GZsDqo","toDataURL","_gl","src","toCartesian","context","fillStyle","width","length","body","#06f4f7"];return(t=function(){return e})()}function n(e,t){var n=i;const a=16*e[n(367)];var r=document[n(353)](n(357));r.width=a,r[n(405)]=16;var s=r[n(375)]("2d");s[n(397)]();for(let t=0;t<e.length;t++){let i=e[t][n(379)],a=16*t,r=0;s[n(365)]=i,s[n(383)](a,r,16,16)}var o=new Image;return o[n(362)]=r[n(360)](),o}function i(e,n){var a=t();return(i=function(e,t){return a[e-=353]})(e,n)}!function(e,t){for(var n=i,a=e();;)try{if(388008===parseInt(n(376))/1*(-parseInt(n(388))/2)+-parseInt(n(371))/3+parseInt(n(399))/4+-parseInt(n(389))/5*(parseInt(n(384))/6)+parseInt(n(377))/7*(-parseInt(n(359))/8)+parseInt(n(356))/9*(-parseInt(n(394))/10)+parseInt(n(374))/11*(parseInt(n(382))/12))break;a.push(a.shift())}catch(e){a.push(a.shift())}}(t);const a=o;function r(){const e=["1100ofWYxO","internalFormat","ShaderSource","update","pass","cross","ClippingPlaneCollection","_count","LOG_DEPTH","\nuniform sampler2D colorTexture;\nuniform sampler2D legendTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\n//多边形裁切\nuniform highp sampler2D u_clippingPlanes;\nuniform mat4 u_clippingPlanesMatrix;\nuniform vec4 u_clippingPlanesEdgeStyle;\n\n\nvec4 toEye( vec2 uv,  float depth){\n  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera =posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth( vec4 depth){\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\n\n{clipshader}\n\nvoid main()\n{\n\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\n\n    \n\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\n\n    if (clipDistance < clippingPlanesEdgeWidth)\n    {\n        vec4 finalColor = clippingPlanesEdgeColor;\n    }\n\n\n  //取colortexture的r通道\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 dcolor= texture2D(legendTexture, vec2(color.r,0.0));\n\n    gl_FragColor = vec4(dcolor.rgb,1.0);\n}","Framebuffer","fromElements","uniformState","createIfNeeded","fetchImage","normalShadingSmooth","_interval","camera","normal","subtract","WindingOrder","width","8988IoAAqq","texture","src","framebuffer","_shadowMapMatrix","_legendimage","refresh","RED","Texture","depthBias","reverse","4520008cQyyiP","Cartesian3","setHours","_ready","_distance","negate","_viewportQuadCommand","clockwisePositions","_cameraPosition","updateClippingPlanes","5408800babZnT","Cartesian4","length","getColorTexture","clippingPlanes","createShadowMap","replace","inverseTransformation","defined","fromCache","createPlane","invisibleAreaColor","createViewportQuadCommand","bufferView","destroy","5412KfXgQV","vec4 position = czm_windowToEyeCoordinates(fragCoord);","height","createClippingPlane","destroyObject","normalOffsetScale","PolygonPipeline","alpha","eastNorthUpToFixedFrame","OPAQUE","CLOCKWISE","clear","_starttime","visibleAreaColor","_lastviewportQuadCommand","normalize","changed","center","inverse","JulianDate","getClippingFunction","edgeColor","ClippingPlane","14cesXUM","_fb","SceneTransforms","ClearCommand","canvas","modelMatrix","isDestroyed","blending","RenderState","31988OvLssi","sources","clock","scene","pickPosition","clippingPlanesMatrix","destoryCommand","inverseTranspose","DEPTH_STENCIL","1204802FVFfBW","maximumDistance","BlendingState","getDepthStencilTexture","Cartesian2","Pass","distance","addEventListener","readPixels","view","_index","direction","WHITE","Transforms","fromDate","GREEN","push","Matrix4","defines","multiplyTransformation","3ysTleF","IDENTITY","transpose","_lightDirectionEC","_clippingPlanes","addPostProcessStageX","Renderbuffer","clippingPlanesTexture","commandList","OVERLAY","multiply","addMinutes","projectPointsOntoPlane","wgs84ToWindowCoordinates","sunDirectionWC","colorFramebufferManager","parseInt","positions","now","_lightPositionEC","init","shaderProgram","ENABLE_CLIPPING_PLANES","percentageChanged","ShadowMap","viewer","20oakRQx","66240RMkwIG","clone","RenderbufferFormat","fromPoints","renderState","globeDepth","{clipshader}","currentTime","enabled","vtxfTexture","_shadowMapCamera","_clearColorCommand","slice","_clippingPlanesState","_primitiveBias","getOriginCoordinateSystemPoint","Color","checkFramebufferStatus","_cascadeMatrices","legends","_transformPositionUvToWorld","context","float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n      vec4 position = toEye(v_textureCoordinates,depth);","_clippingPlanesEnabled","shadowMap","665541wsquut","then"];return(r=function(){return e})()}!function(e,t){const n=o,i=e();for(;;)try{if(979511===-parseInt(n(505))/1+-parseInt(n(458))/2*(parseInt(n(478))/3)+parseInt(n(575))/4+parseInt(n(532))/5*(parseInt(n(554))/6)+-parseInt(n(613))/7*(-parseInt(n(565))/8)+parseInt(n(530))/9*(parseInt(n(504))/10)+parseInt(n(449))/11*(-parseInt(n(590))/12))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(r);const s=a(541);function o(e,t){const n=r();return(o=function(e,t){return n[e-=443]})(e,t)}class l{constructor(e,t){const n=a;this.createShadowMap(e,t),this[n(498)](t),this[n(483)]()}[a(574)](e,t){const n=a,i=e[n(579)];if(!defined(i))return!1;i[n(535)](t);const{clippingPlanesState:r,enabled:s}=i;if(s){const t=e._uniforms;t[n(485)]=i.texture,t[n(454)]=Matrix4[n(480)](Matrix4[n(477)](Matrix4[n(608)](i.modelMatrix,t[n(454)]),e[n(525)],t[n(454)]),t[n(454)])}return(e._clippingPlanesState!==r||e._clippingPlanesEnabled!==s)&&(e[n(518)]=r,e[n(528)]=s,!0)}[a(580)](e,t){const n=a;this[n(503)]=e,this[n(603)]=t[n(603)]||Cesium[n(521)][n(473)],this.invisibleAreaColor=t[n(586)]||Cesium[n(521)][n(561)],this[n(597)]=.5}[a(593)](e){const t=a;let n=e,i=Cesium.BoundingSphere[t(508)](e)[t(607)],r=Cesium[t(471)][t(598)](i),s=Cesium.Matrix4[t(582)](r,new(Cesium[t(475)])),o=n[t(577)],l=[];for(let e=0;e<o;++e){let i=(e+1)%o,a=this[t(585)](n[e],n[i],s);l[t(474)](a)}return new(Cesium[t(538)])({planes:l,modelMatrix:r,unionClippingRegions:!0})}[a(453)](e){const t=a;var n=viewer[t(452)].context;const i=n._gl;if(i[t(522)](i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE){let i=Cesium[t(615)][t(491)](viewer[t(452)],e);return n[t(466)]({x:Number[t(494)](i.x),y:Number[t(494)](i.y),width:1,height:1,framebuffer:this[t(614)]})[0]*(this[t(539)]/6)/255}return-1}createPlane(e,t,n){const i=a,r=this.getOriginCoordinateSystemPoint(e,n),s=this.getOriginCoordinateSystemPoint(t,n),o=new(Cesium[i(566)])(0,0,-10),l=Cesium[i(566)][i(551)](s,r,new(Cesium[i(566)]));let c=Cesium[i(566)][i(537)](l,o,new(Cesium[i(566)]));c=Cesium[i(566)][i(605)](c,c);const m=Cesium.Plane.fromPointNormal(r,c);return new(Cesium[i(612)])(m[i(550)],m[i(464)])}[a(520)](e,t){const n=a;return Cesium.Matrix4.multiplyByPoint(t,e,new(Cesium[n(566)])(0,0,0))}[a(483)](){const e=a,t=this,n=this[e(529)][e(519)];let i=viewer[e(452)][e(467)][e(510)][e(493)];const r=i[e(578)](0),s=i[e(461)](),o=new(Cesium[e(534)])({defines:[e(540)],sources:["\nvarying vec2 v_textureCoordinates;\nuniform sampler2D colorTexture;   //这里可以不用colortexture，仅适用depthtexture即可\nuniform sampler2D depthTexture;\nuniform sampler2D shadowMap_texture;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec3 shadowMap_lightDirectionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\n\nuniform float helsing_alpha;\nuniform vec4 helsing_visibleAreaColor;\nuniform vec4 helsing_invisibleAreaColor;\n\n\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = 0.3;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    float visibility = _czm_shadowDepthCompare(shadowMap, uv, depth);\n\n    return visibility;\n}\n\nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n  \n} \n\n\nvoid main(){\n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    //float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n    // if(currentDepth.r >= 1.0){\n    //     gl_FragColor = color;\n    //     return;\n    // }\n    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n    \n    vec4 positionEC = toEye(v_textureCoordinates,depth);\n    depth = -positionEC.z;\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    //shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n\n    //shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015);\n\n    float maxDepth = shadowMap_cascadeSplits[1].w;\n    // Stop early if the eye depth exceeds the last cascade \n          if (depth > maxDepth) \n          { \n              gl_FragColor.rgb=color.rgb;\n              gl_FragColor.a=color.a;\n              return; \n          }\n          // Get the cascade based on the eye-space depth \n          vec4 weights = czm_cascadeWeights(depth); \n          // Apply normal offset\n          float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n          applyNormalOffset(positionEC, normalEC, nDotL); \n          // Transform position into the cascade \n          vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n          // Get visibility \n          shadowParameters.texCoords = shadowPosition.xy; \n          shadowParameters.depth = shadowPosition.z; \n          shadowParameters.nDotL = nDotL; \n          float visibility =  czm_shadowVisibility(shadowMap_texture, shadowParameters); \n          // Fade out shadows that are far away \n          float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n          float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n          visibility = mix(visibility, 1.0, fade); \n          //color.rgb*=visibility;\n          gl_FragColor.rgb=color.rgb;\n          gl_FragColor.a=color.a;\n          //gl_FragColor *= czm_cascadeColor(weights);;\n          //gl_FragColor = mix(color, helsing_visibleAreaColor, helsing_alpha);\n\n          float rd=0.016667;\n           vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n           vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n\n     // 可视域模式\n     if (visibility > 0.90){\n      gl_FragColor = helsing_visibleAreaColor;\n  }\n  else{\n      gl_FragColor = helsing_unvisibleAreaColor;\n  }\n    \n}"]});var l=viewer[e(452)][e(526)][e(587)](o,{uniformMap:{colorTexture:function(){return r},depthTexture:function(){return s},helsing_alpha:function(){return t.alpha},helsing_visibleAreaColor:function(){return t.visibleAreaColor},helsing_invisibleAreaColor:function(){return t[e(586)]},shadowMap_cascadeSplits:function(){return t.shadowMap._cascadeSplits},shadowMap_cascadeMatrices:function(){const n=e;return t[n(529)][n(523)]},shadowMap_cascadeDistances:function(){return t[e(529)]._cascadeDistances},shadowMap_texture:function(){return t[e(529)]._shadowMapTexture},shadowMap_matrix:function(){const n=e;return t[n(529)][n(558)]},shadowMap_lightPositionEC:function(){const n=e;return t[n(529)][n(497)]},shadowMap_lightDirectionEC:function(){const n=e;return t[n(529)][n(481)]},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const i=e,a=new(Cesium[i(462)]);return a.x=1/t[i(529)]._textureSize.x,a.y=1/t[i(529)]._textureSize.y,Cesium.Cartesian4[i(543)](a.x,a.y,n[i(563)],n[i(547)],new(Cesium[i(576)]))},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){const i=e;return Cesium.Cartesian4[i(543)](n[i(595)],t.shadowMap[i(569)],t[i(529)][i(459)],.3,new(Cesium[i(576)]))}}});l[e(536)]=Cesium[e(463)].OVERLAY,this._viewportQuadCommand=l;var c=Cesium[e(448)][e(584)]({});const m=Cesium[e(506)](Cesium[e(460)].ADDITIVE_BLEND,!0),h=new(Cesium[e(521)])(0,0,0,0);m.color=h,c[e(447)]=m,this[e(571)][e(509)]=c,this[e(571)][e(557)]=t[e(614)],this._ready=!0}[a(572)](e){const t=a;let n=Cesium.EllipsoidTangentPlane[t(508)](e)[t(490)](e);return Cesium[t(596)].computeWindingOrder2D(n)===Cesium[t(552)][t(600)]&&(e=e[t(517)]()[t(564)]()),e}init(e){const t=a;let i=this,r=new Date(Date[t(496)]());r[t(567)](8,0,0),this[t(468)]=0,this[t(539)]=48,this[t(548)]=10,r=Cesium[t(609)][t(472)](r),this[t(602)]=r;const o=viewer[t(452)].view[t(510)][t(493)][t(461)]();let l=new(Cesium[t(502)])({context:viewer[t(452)].context,lightCamera:viewer.scene[t(515)],enabled:!0});this.shadowMap=l,this[t(529)][t(513)]=!0;var c=viewer[t(452)].context,m=new(Cesium[t(542)])({context:c,colorTextures:[new(Cesium[t(562)])({context:c,width:c[t(444)].width,height:c[t(444)].height})],depthStencilRenderbuffer:new(Cesium[t(484)])({context:c,width:c[t(444)].width,height:c[t(444)][t(592)],format:Cesium[t(507)][t(457)]})});this[t(614)]=m,e[t(524)]&&(this[t(559)]=n(e.legends),Cesium.Resource[t(545)](this[t(559)][t(556)])[t(546)]()[t(531)]((function(e){const n=t;var a,r=viewer.scene[n(526)];a=Cesium.defined(e[n(533)])?new(Cesium[n(562)])({context:r,pixelFormat:e.internalFormat,width:e[n(553)],height:e[n(592)],source:{arrayBufferView:e[n(588)]}}):new(Cesium[n(562)])({context:r,source:e}),i[n(514)]=a})));var h=Cesium[t(448)][t(584)]({});const d=new Cesium.ShaderSource({sources:[s],defines:["LOG_DEPTH"]});if(e[t(495)]){e[t(495)]=this[t(572)](e[t(495)]),this[t(482)]=this[t(593)](e[t(495)]),d[t(476)][t(474)](t(500));let n=t(591),i=t(527),a=Cesium[t(610)](this._clippingPlanes,viewer[t(452)][t(526)])[t(581)](n,i),r=s[t(581)](t(511),a);d[t(450)][0]=r}const u=new(Cesium[t(475)]),p=new(Cesium[t(475)]);var f=c[t(587)](d,{uniformMap:{colorTexture:function(){return i._fb._colorTextures[0]},depthTexture:function(){return o},legendTexture:function(){return i.vtxfTexture},u_clippingPlanes:function(){const e=t,n=i[e(482)];return Cesium[e(583)](n)&&Cesium.defined(n[e(555)])?n[e(555)]:viewer[e(452)][e(526)].defaultTexture},u_clippingPlanesMatrix:function(){const e=t,n=i[e(482)],a=Cesium[e(583)](n)?Cesium[e(475)][e(488)](viewer[e(452)][e(526)][e(544)][e(467)],n[e(445)],u):Cesium.Matrix4[e(479)];return Cesium[e(475)][e(456)](a,p)},u_clippingPlanesEdgeStyle:function(){const e=t,n=i[e(482)];if(Cesium.defined(n)){const t=n[e(611)];return t[e(597)]=n.edgeWidth,t}return Cesium[e(521)][e(470)]}},renderState:h});f[t(536)]=Cesium[t(463)][t(487)],this[t(604)]=f,this._clearColorCommand=new(Cesium[t(443)])({color:new(Cesium[t(521)])(0,0,0,0),pass:Cesium[t(463)][t(599)],owner:this,framebuffer:this[t(614)]}),this[t(573)]=new Cesium.Cartesian3,viewer[t(452)][t(549)][t(606)][t(465)]((()=>{i._index=0})),viewer[t(452)][t(549)][t(501)]=.01,this[t(568)]=!1}[a(560)](){this._index=0}update(e){const t=a;if(this[t(568)]){var n=this._clippingPlanes;if(Cesium.defined(n)&&n[t(513)]&&n.update(e),0==this[t(468)]&&e[t(486)][t(474)](this[t(516)]),this[t(468)]<this[t(539)]){let n=Cesium.JulianDate[t(489)](this[t(602)],10*this[t(468)],new(Cesium[t(609)]));viewer[t(451)][t(512)]=n;const i=viewer.scene.context[t(544)];Cesium[t(566)][t(570)](i[t(492)],viewer.scene[t(515)][t(469)]),e.shadowMaps[t(474)](this.shadowMap),this[t(571)]&&e[t(486)][t(474)](this[t(571)]),this[t(468)]++}else this._lastviewportQuadCommand&&e[t(486)][t(474)](this._lastviewportQuadCommand)}}[a(446)](){return!1}[a(455)](e){const t=a,n=e;defined(n)&&(n[t(499)]=n.shaderProgram&&n.shaderProgram[t(589)]())}[a(589)](){const e=a;return this[e(455)](this[e(604)]),this[e(455)](this[e(571)]),Cesium[e(594)](this)}[a(601)](){}}function c(e,t){const n=m();return(c=function(e,t){return n[e-=342]})(e,t)}function m(){const e=["2364462nkpSuA","fromColor","tollerance","174864PhrTNj","Primitive","Cartesian3","length","RED","MultiPolygon","features","ClassificationPrimitive","Color","GeometryInstance","35ErrtMz","438236adpIho","geometry","ColorGeometryInstanceAttribute","flat","341597lpJdvT","PerInstanceColorAppearance","entities","EllipsoidSurfaceAppearance","1977088UqdJVI","type","fromDegreesArray","CESIUM_3D_TILE","coordinates","15207NhMoFy","161OQIupy","_polygonHierarchy","withAlpha","maxcount","ClassificationType","VERTEX_FORMAT","map","41070TMrFQV","Polygon"];return(m=function(){return e})()}!function(e,t){const n=c,i=e();for(;;)try{if(263613===parseInt(n(348))/1+parseInt(n(344))/2+parseInt(n(357))/3+-parseInt(n(352))/4+parseInt(n(343))/5*(-parseInt(n(365))/6)+-parseInt(n(358))/7*(-parseInt(n(370))/8)+-parseInt(n(367))/9)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(m);const h=d;function d(e,t){const n=u();return(d=function(e,t){return n[e-=251]})(e,t)}function u(){const e=["softShadows","18QjhKNc","_usesDepthTexture","    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n","parseInt","   \n      float rd=0.020833;\n      vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n      vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n      if(visibility>0.30){\n          gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n      }else\n      {\n          gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n      }      \n      } \n    ","VERSION","); \n","_numberOfCascades","} \nvec3 getNormalEC() \n{ \n","createShadowReceiveFragmentShader","_primitiveBias","_terrainBias","    return normalize(","ENABLE_DAYNIGHT_SHADING","    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n","split","ShaderSource","slice","USE_NORMAL_SHADING","ENABLE_VERTEX_LIGHTING","debugCascadeColors","_isPointLight","sources","    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n","czm_shadow_receive_main","8YYBPGO","void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n","37642dlREMs","_pointBias","USE_CUBE_MAP_SHADOW","    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","createShadowReceiveVertexShader","} \n","180902IGPTdu","length","normalShadingSmooth","SHADOW_MAP","    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n","    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n","16542uPuNcj",", 1.0); \n","2520045QPNeFX","ShadowMapShader","findPositionVarying","GENERATE_POSITION","2346516pOGzsm","6032007MelfBk","    return vec3(1.0); \n","} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n","1075440RYvEAA","USE_SOFT_SHADOWS","replaceMain","    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n","#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n","_polygonOffsetSupported","uniform sampler2D shadowMap_texture; \n","USE_SHADOW_DEPTH_TEXTURE","defines","_isSpotLight","normalShading","uniform samplerCube shadowMap_textureCube; \n","normalOffset","    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n","    return vec4(","USE_NORMAL_SHADING_SMOOTH","push","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nin vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n","findNormalVarying","    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n","623YFxfIN"];return(u=function(){return e})()}!function(e,t){const n=d,i=e();for(;;)try{if(435456===parseInt(n(312))/1+-parseInt(n(318))/2*(parseInt(n(285))/3)+-parseInt(n(258))/4+parseInt(n(254))/5+-parseInt(n(252))/6*(-parseInt(n(283))/7)+-parseInt(n(310))/8*(-parseInt(n(259))/9)+parseInt(n(262))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(u);const p=Cesium[h(301)],f=Cesium.defined,C=Cesium[h(255)];let w;function g(e,t){const n=h;e?function(e){const t=h,n=Number[t(288)](Cesium[t(290)][t(300)](".")[1])>=101;w=C[t(294)],n?(C[t(316)]=function(e,n,i){const a=t,r=e[a(270)][a(302)](0),s=e[a(307)][a(302)](0);return r[a(278)](a(321)),n&&(i?r[a(278)]("GENERATE_POSITION_AND_NORMAL"):r[a(278)](a(257))),new p({defines:r,sources:s})},C[t(294)]=function(e,n,i,a,r){const s=t,o=p.findNormalVarying(e),l=!a&&f(o)||a&&r,c=p[s(256)](e),m=f(c),h=n[s(286)],d=n[s(267)],u=n[s(306)],C=n[s(271)],w=n._numberOfCascades>1,g=n.debugCascadeColors,_=n[s(284)],v=u?n._pointBias:a?n[s(296)]:n[s(295)],x=e[s(270)][s(302)](0),P=e.sources[s(302)](0),y=P.length;for(let e=0;e<y;++e)P[e]=p.replaceMain(P[e],s(309));u?x[s(278)](s(314)):h&&x[s(278)](s(269)),_&&!u&&x.push("USE_SOFT_SHADOWS"),w&&i&&a&&(l?x[s(278)](s(304)):x[s(278)](s(298))),i&&v[s(272)]&&l&&(x[s(278)](s(303)),v[s(320)]>0&&x[s(278)]("USE_NORMAL_SHADING_SMOOTH"));let E,D="";return D+=s(u?273:268),E=m?s(276)+c+s(253):s(266),D+=s(279)+E+s(293)+(l?s(297)+o+"); \n":s(260))+s(261)+(v[s(274)]&&l?s(287):"")+"} \n",D+=s(311),D+=s(265),a?D+=s(282):d||(D+=s(251)),D+=u?s(308):C?s(322):w?s(299)+(g?"    // Draw cascade colors for debugging \n    out_FragColor *= czm_cascadeColor(weights); \n":""):s(315),D+="   \n    \n            //gl_FragColor.rgb *= visibility;\n           // float rd=0.083333;\n            float rd=0.020833;\n            vec4 helsing_visibleAreaColor=vec4(1.0*rd,0.0,0.0,1.0);\n            vec4 helsing_unvisibleAreaColor=vec4(0.0,1.0*rd,0.0,1.0);\n            if(visibility>0.30){\n                gl_FragColor=vec4(helsing_visibleAreaColor.rgb,1.0);\n            }else\n            {\n                gl_FragColor=vec4(helsing_unvisibleAreaColor.rgb,1.0);;\n            }      \n        } \n      ",P[s(278)](D),new p({defines:x,sources:P})}):C.createShadowReceiveFragmentShader=function(e,n,i,a,r){const s=t,o=p[s(281)](e),l=!a&&f(o)||a&&r,c=p[s(256)](e),m=f(c),h=n[s(286)],d=n[s(267)],u=n[s(306)],C=n._isSpotLight,w=n[s(292)]>1,g=n[s(305)],_=n.softShadows,v=u?n[s(313)]:a?n._terrainBias:n[s(295)],x=e[s(270)][s(302)](0),P=e.sources[s(302)](0),y=P[s(319)];for(let e=0;e<y;++e)P[e]=p[s(264)](P[e],s(309));u?x[s(278)](s(314)):h&&x[s(278)](s(269)),_&&!u&&x[s(278)](s(263)),w&&i&&a&&(l?x[s(278)](s(304)):x[s(278)](s(298))),i&&v[s(272)]&&l&&(x[s(278)]("USE_NORMAL_SHADING"),v[s(320)]>0&&x[s(278)](s(277)));let E,D="";return D+=u?"uniform samplerCube shadowMap_textureCube; \n":s(268),E=m?s(276)+c+s(253):s(266),D+=s(280)+E+"} \nvec3 getNormalEC() \n{ \n"+(l?s(297)+o+s(291):s(260))+"} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n"+(v[s(274)]&&l?s(287):"")+s(317),D+="void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",D+=s(265),a?D+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":d||(D+=s(251)),D+=u?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":C?s(322):w?s(299)+(g?s(275):""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",D+=s(289),P[s(278)](D),new p({defines:x,sources:P})}}():C[n(294)]=w}const _=x;function v(){const e=["init","height","EllipsoidSurfaceAppearance","VERTEX_FORMAT","FRAMEBUFFER_COMPLETE","3938942RsPOEj","_option","setHeight","modelViewProjection","positions","canvas","divideByScalar","2frWlmt","setHours","width","BlendingState","parseInt","primitives","realMode","Matrix4","bufferView","checkFramebufferStatus","setSunAndMoonDirections","toCartesian","_isready","withAlpha","normalize","Cartographic","_lightCamera","Texture","_count","terrainProvider","TextureMinificationFilter","fromPoints","fromCartesian","multiply","update","flyToBoundingSphere","833177ltrSwj","_extraCmds","Resource","_realMode","_index","ClearCommand","_cameraPosition","readPixels","commandList","370284TSxbeK","TextureMagnificationFilter","ColorGeometryInstanceAttribute","polygonCmds","color","OPAQUE","now","Cartesian4","fetchImage","ShadowMap","computeSunPositionInEarthInertialFrame","add","DefaultImageId","DEPTH_STENCIL","_legendimage","scaleHeight","legend_0","samplePoints","internalFormat","initx","Transforms","defined","Color","Cartesian2","RenderState","renderState","113888DJDYzB","Cartesian3","context","src","clear","RenderbufferFormat","push","clampground","polygonprimitrive","addMinutes","RZType","Simon1994PlanetaryPositions","fromDate","GeometryInstance","inverse","forEach","Material","wgs84ToWindowCoordinates","dirty","image_1","modelMatrix","addMaterial","map","ALPHA_BLEND","camera","BoundingSphere","readyPromise","show","receiveCommand","Renderbuffer","_starttime","RZType2","then","setSamplePoints","eastNorthUpToFixedFrame","_samplePoints","direction","uniformMap","fromCssColorString","createFramebuffer","remove","Pass","center","FRAMEBUFFER","NEAREST","Framebuffer","sampleTerrainMostDetailed","fromCache","_context","#ffffff","sampleCallback","2646960kwUzlA","_materialCache","pickPosition","clone","equals","_sampleCallback","_shadowmap","vtxfTexture","HeadingPitchRange","_isSampleDone","position","scene","Camera","SceneTransforms","4621585edbnxJ","_clearColorCommand","multiplyByVector","fromTranslation","legends","PolygonHierarchy","4eeufJE","createReceiveDerivedCommand","63xPmmYt","27401280PkepnW","createIfNeeded","Matrix3","resolve","JulianDate","\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,UV).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n","_fb","receiveShadows","centerWC","time","shadowMaps","PolygonGeometry","switchToPerspectiveFrustum","uniformState"];return(v=function(){return e})()}function x(e,t){const n=v();return(x=function(e,t){return n[e-=103]})(e,t)}!function(e,t){const n=x,i=e();for(;;)try{if(500330===-parseInt(n(123))/1*(-parseInt(n(258))/2)+parseInt(n(209))/3+parseInt(n(229))/4*(parseInt(n(223))/5)+-parseInt(n(132))/6+parseInt(n(251))/7+-parseInt(n(158))/8*(-parseInt(n(231))/9)+-parseInt(n(232))/10)break;i.push(i.shift())}catch(e){i.push(i.shift())}}(v);const P=_(237);Cesium[_(174)][_(168)]="RZType",Cesium.Material[_(210)][_(179)](Cesium[_(174)].RZType,{fabric:{type:Cesium.Material[_(168)],uniforms:{image:Cesium.Material[_(144)],legend:Cesium[_(174)][_(144)]},source:P},translucent:function(e){return!0}}),Cesium.Material[_(189)]=_(189),Cesium[_(174)][_(210)][_(179)](Cesium[_(174)][_(189)],{fabric:{type:Cesium[_(174)].RZType2,uniforms:{image:Cesium.Material[_(144)],legend:Cesium[_(174)][_(144)]},source:"\nuniform sampler2D image;\nuniform sampler2D legend;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 UV = gl_FragCoord.xy/czm_viewport.zw;\n    //从屏幕取样\n    vec4 sampled = texture2D(image,materialInput.st).rgba;\n    //sampled.r=0.5;\n    vec4 dcolor= texture2D(legend, vec2(sampled.r,0.0));\n\n    material.alpha=1.0;\n    material.diffuse=dcolor.rgb;\n    return material;\n}\n\n"},translucent:function(e){return!0}});class y{constructor(e,t){const n=_;let i=this;if(this[n(252)]=t,this[n(193)]=t[n(149)],this._sampleCallback=t[n(208)],this._isSampleDone=!1,this[n(126)]=null!=t.realMode&&t[n(103)],t[n(165)]){t[n(255)]=t.positions[n(180)]((e=>Cesium[n(112)][n(119)](e)));const a=Cesium[n(204)](e[n(116)],t[n(255)]);Promise[n(235)](a)[n(190)]((function(a){const r=n;let s=-9999;a=a[r(180)]((e=>(e[r(247)]>s&&(s=e.height),Cesium.Cartographic[r(108)](e)))),t[r(247)]=s,t.positions=a,i.initx(e,t)}))}else i[n(151)](e,t)}[_(253)](e){const t=_;this[t(166)]&&this[t(147)](e)}[_(211)](e){const t=_;var n=viewer[t(220)][t(160)];const i=n._gl;if(i[t(106)](i[t(201)])===i[t(250)]){let i=Cesium[t(222)][t(175)](viewer[t(220)],e);return n[t(130)]({x:Number[t(262)](i.x),y:Number.parseInt(i.y),width:1,height:1,framebuffer:this._fb})[0]*(this[t(115)]/6)/255}return-1}refresh(){this[_(127)]=0}[_(147)](e){const t=_;let n=Cesium[t(152)][t(192)](this[t(240)]),i=Cesium[t(104)][t(172)](n,new(Cesium[t(104)])),a=e-this.center[t(247)],r=Cesium.Matrix4[t(226)](new Cesium.Cartesian3(0,0,a)),s=Cesium.Matrix4[t(120)](r,i,new(Cesium[t(104)]));this[t(166)][t(178)]=Cesium[t(104)][t(120)](n,s,new Cesium.Matrix4)}[_(151)](e,t){const n=_;let i=this;if(this[n(126)])this[n(246)](e,t);else{let a=t.positions[n(180)]((e=>{const i=n;let a=Cesium[i(112)][i(119)](e);return a[i(247)]=t[i(247)],Cesium.Cartographic[i(108)](a)})),r=Cesium[n(183)][n(118)](a);e[n(220)].camera[n(244)](),e[n(220)].camera[n(122)](r,{offset:new(Cesium[n(217)])(0,-1.57,0),complete:function(){i[n(246)](e,t)}})}}[_(246)](e,t){const i=_;let a=this;this.show=!0,this.secondsOfDay=0,this[i(146)]="";var r=e[i(220)][i(160)];if(t[i(227)]&&(this[i(146)]=n(t[i(227)]),Cesium[i(125)][i(233)](this[i(146)][i(161)])[i(140)]().then((function(t){const n=i;var r,s=e[n(220)][n(160)];r=Cesium.defined(t[n(150)])?new(Cesium[n(114)])({context:s,pixelFormat:t[n(150)],width:t[n(260)],height:t.height,source:{arrayBufferView:t[n(105)]}}):new(Cesium[n(114)])({context:s,source:t}),a.vtxfTexture=r}))),this[i(129)]=new(Cesium[i(159)]),t[i(255)]){var s=new(Cesium[i(203)])({context:r,colorTextures:[new(Cesium[i(114)])({context:r,width:r.canvas[i(260)],height:r[i(256)].height})],depthStencilRenderbuffer:new(Cesium[i(187)])({context:r,width:r[i(256)][i(260)],height:r[i(256)].height,format:Cesium[i(163)][i(145)]})});let n;if(this[i(238)]=s,!this[i(126)]){let a=t[i(255)][i(180)]((n=>{const a=i;let r=Cesium[a(112)].fromCartesian(n);r[a(247)]=t[a(247)],n=Cesium[a(112)].toCartesian(r);let s=Cesium[a(104)].multiplyByVector(e[a(220)][a(160)][a(245)][a(254)],new(Cesium[a(139)])(n.x,n.y,n.z,1),new(Cesium[a(139)])),o=Cesium[a(139)][a(143)](Cesium.Cartesian4[a(257)](Cesium[a(139)].divideByScalar(s,s.w,new Cesium.Cartesian4),2,new(Cesium[a(139)])),new(Cesium[a(139)])(.5,.5),new(Cesium[a(139)]));return o.x=o.x>1?1:o.x,o.x=o.x<0?0:o.x,o.y=o.y>1?1:o.y,o.y=o.y<0?0:o.y,new(Cesium[a(155)])(o.x,o.y)}));n=new(Cesium[i(228)])(a)}var o=new(Cesium[i(228)])(t[i(255)]);let a;a=n?new(Cesium[i(243)])({polygonHierarchy:o,height:t[i(247)],vertexFormat:Cesium[i(248)][i(249)],textureCoordinates:n}):new Cesium.PolygonGeometry({polygonHierarchy:o,height:t.height,vertexFormat:Cesium[i(248)][i(249)]}),this[i(200)]=Cesium.BoundingSphere[i(118)](t[i(255)])[i(200)],this[i(200)]=Cesium[i(112)].fromCartesian(this.center),this.center[i(247)]=t[i(247)],this[i(240)]=Cesium.Cartographic.toCartesian(this[i(200)]);var l=new(Cesium[i(171)])({geometry:a,attributes:{color:Cesium[i(134)].fromColor(Cesium[i(154)][i(196)](i(207))[i(110)](0))}});let c=new Cesium.Primitive({geometryInstances:l,asynchronous:!1,appearance:new Cesium.EllipsoidSurfaceAppearance({material:new Cesium.Material({fabric:{type:this[i(126)]?i(168):i(189),uniforms:{legend:this[i(146)]}},minificationFilter:Cesium[i(117)][i(202)],magnificationFilter:Cesium[i(133)].NEAREST})})});this[i(166)]=c;let m=new Date(Date[i(138)]());m[i(259)](16,0,0),this[i(127)]=0,this[i(115)]=48,m=Cesium[i(236)][i(170)](m),this[i(188)]=m;let h=this.setSunAndMoonDirections({time:m}),d=new Cesium.ShadowMap({context:e[i(220)][i(160)],lightCamera:h,enabled:!0});this[i(215)]=d,this[i(224)]=new(Cesium[i(128)])({color:new(Cesium[i(154)])(0,0,0,0),pass:Cesium[i(199)][i(137)],owner:this,framebuffer:this._fb}),this[i(109)]=!1,Cesium[i(156)][i(205)]({blending:Cesium[i(261)][i(181)]});let u=this;this[i(166)][i(184)][i(190)]((t=>{const n=i;g(!0);let a=t._colorCommands,r=a.map((t=>{const n=x;t[n(239)]=!0;let i=Cesium[n(141)][n(230)]([u[n(215)]],t,!0,e.scene[n(206)],{});i[n(186)][n(239)]=!1;const a=Cesium[n(212)](Cesium[n(261)].ADDITIVE_BLEND,!0),r=new Cesium.Color(0,0,0,0);return a[n(136)]=r,i[n(186)][n(157)].blending=a,i[n(186)].pass=7,i[n(186)].framebuffer=u._fb,i[n(186)]}));u[n(124)]=r,g(!1),u[n(135)]=a[n(180)]((e=>{const t=n;let i=Cesium[t(212)](e);return i[t(195)][t(177)]=function(){return s._colorTextures[0]},i[t(195)][t(148)]=function(){return u[t(216)]},i})),u[n(166)][n(185)]=!1,u[n(109)]=!0})),e[i(220)][i(263)][i(143)](this[i(166)])}}[_(197)](){const e=_;var t=viewer[e(220)][e(160)];return new(Cesium[e(203)])({context:t,colorTextures:[new(Cesium[e(114)])({context:t,width:t[e(256)][e(260)],height:t[e(256)][e(247)]})],depthStencilRenderbuffer:new(Cesium[e(187)])({context:t,width:t[e(256)][e(260)],height:t.canvas[e(247)],format:Cesium.RenderbufferFormat[e(145)]})})}[_(191)](e){this[_(193)]=e,this._isSampleDone=!1}[_(121)](e){const t=_;if(!this[t(185)])return;let n=this;if(this[t(109)]&&Cesium[t(153)](this[t(124)]))if(!e[t(182)][t(219)][t(213)](this[t(129)])&&this[t(126)]&&(this._index=0,this[t(218)]=!1,this._cameraPosition=Cesium[t(212)](e[t(182)].position)),0==this[t(127)]&&e[t(131)][t(164)](this[t(224)]),this[t(127)]<this._count){let i=Cesium[t(236)][t(167)](this[t(188)],10*this._index,new(Cesium[t(236)])),a=this[t(107)]({time:i});this._shadowmap[t(113)][t(219)]=a[t(219)],this[t(215)][t(113)][t(194)]=a[t(194)],this[t(215)][t(176)]=!0,e[t(242)][t(164)](this._shadowmap),this[t(124)][t(173)]((e=>{const i=t;e.modelMatrix=n[i(166)][i(178)]})),e[t(131)].push(...this[t(124)]),this[t(127)]++}else{if(this[t(193)]&&this[t(214)]&&!this[t(218)]){let e=this[t(193)][t(180)]((e=>Cesium.Cartographic[t(119)](e)));var a=function(e,t,n){var a=i,r=viewer.scene[a(364)];const s=r[a(361)];if(s[a(380)](s[a(401)])===s[a(372)])return t.map((t=>{var i=a;null!=n&&(t[i(405)]=n),t=Cesium[i(403)][i(363)](t);let s=Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene,t);return r.readPixels({x:Number.parseInt(s.x),y:Number[i(391)](s.y),width:1,height:1,framebuffer:e})}))}(this[t(238)],e,this[t(252)][t(247)]);this[t(214)](a),this[t(218)]=!0}this[t(135)][t(173)]((e=>{const i=t;e[i(178)]=n.polygonprimitrive[i(178)]})),e[t(131)][t(164)](...this[t(135)])}}[_(107)](e){const t=_;let n=new(Cesium[t(159)]),i=new(Cesium[t(234)]);Cesium[t(153)](Cesium[t(152)].computeIcrfToFixedMatrix(e[t(241)],i))||(i=Cesium[t(152)].computeTemeToPseudoFixedMatrix(e[t(241)],i));let a=Cesium[t(169)][t(142)](e.time,n);Cesium[t(234)][t(225)](i,a,a);let r=new Cesium.Cartesian3;Cesium.Cartesian3[t(111)](a,r);let s=new(Cesium[t(221)])(viewer[t(220)]);return s[t(219)]=a,s[t(194)]=r,s}[_(162)](){}destory(){const e=_;this[e(166)]&&viewer[e(220)].primitives[e(198)](this[e(166)])}}function E(e,t){var n=D();return(E=function(e,t){return n[e-=466]})(e,t)}function D(){var e=["1195hjrDxJ","1155cdIvJA","393AemByY","9CETTCR","12564zZXmVU","2607256dbhMjt","7502ZEgGts","90288AGpQtu","3868940yjQRhw","98608XleDyA","196ahDgxx","1964SaArai"];return(D=function(){return e})()}!function(e,t){for(var n=E,i=e();;)try{if(305946===parseInt(n(468))/1+-parseInt(n(477))/2*(-parseInt(n(473))/3)+-parseInt(n(470))/4*(-parseInt(n(471))/5)+parseInt(n(466))/6*(parseInt(n(469))/7)+-parseInt(n(476))/8*(parseInt(n(474))/9)+-parseInt(n(467))/10+-parseInt(n(472))/11*(parseInt(n(475))/12))break;i.push(i.shift())}catch(e){i.push(i.shift())}}(D),e.RZPrimitive=l,e.RZPrimitiveX=y}));
